{"sha":"d15bc06466e345651f53ef7a7f5a771ac4880446","node_id":"MDY6Q29tbWl0NDc4NTkyNTI2OmQxNWJjMDY0NjZlMzQ1NjUxZjUzZWY3YTdmNWE3NzFhYzQ4ODA0NDY=","commit":{"author":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2016-12-29T01:47:12Z"},"committer":{"name":"Sijie Guo","email":"sijieg@twitter.com","date":"2016-12-29T10:13:30Z"},"message":"DL-163: clean up direct zookeeper and bookkeeper usage and use metadata/data store abstraction\n\n- introduce NamespaceDriver class to manage metadata/data store abstractions\n- clean up direct zookeeper and bookkeeper usage and use metadata/data store abstraction\n- separate MetadataAccessor from DistributedLogManager\n- remove deprecated classes","tree":{"sha":"23a00d2bc1d7a0b34d9855c8002d8421e82b3292","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/trees/23a00d2bc1d7a0b34d9855c8002d8421e82b3292"},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/git/commits/d15bc06466e345651f53ef7a7f5a771ac4880446","comment_count":0,"verification":{"verified":false,"reason":"unsigned","signature":null,"payload":null}},"url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/d15bc06466e345651f53ef7a7f5a771ac4880446","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/d15bc06466e345651f53ef7a7f5a771ac4880446","comments_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/d15bc06466e345651f53ef7a7f5a771ac4880446/comments","author":null,"committer":null,"parents":[{"sha":"a83b233a79300c0bf1b3dcac0a24fef628ad48f8","url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/commits/a83b233a79300c0bf1b3dcac0a24fef628ad48f8","html_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/commit/a83b233a79300c0bf1b3dcac0a24fef628ad48f8"}],"stats":{"total":4620,"additions":2131,"deletions":2489},"files":[{"sha":"cebbc337db176f339f9f3b0ed65f7f3f433b6215","filename":"src/main/java/com/twitter/distributedlog/BKAsyncLogReader.java","status":"modified","additions":0,"deletions":2,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKAsyncLogReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKAsyncLogReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKAsyncLogReader.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -594,8 +594,6 @@ public void run() {\n                 }\n                 lastProcessTime.reset().start();\n \n-                lastProcessTime.reset().start();\n-\n                 // If the oldest pending promise is interrupted then we must mark\n                 // the reader in error and abort all pending reads since we dont\n                 // know the last consumed read"},{"sha":"9432e8a1bee401157370bcf644ba665f612f2470","filename":"src/main/java/com/twitter/distributedlog/BKAsyncLogWriter.java","status":"modified","additions":0,"deletions":1,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKAsyncLogWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKAsyncLogWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKAsyncLogWriter.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -24,7 +24,6 @@\n import com.twitter.distributedlog.exceptions.WriteCancelledException;\n import com.twitter.distributedlog.exceptions.WriteException;\n import com.twitter.distributedlog.feature.CoreFeatureKeys;\n-import com.twitter.distributedlog.stats.OpStatsListener;\n import com.twitter.distributedlog.util.FailpointUtils;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.util.Future;"},{"sha":"a3959b0e03e21173e2e10f6f80d4f1719c16ecf5","filename":"src/main/java/com/twitter/distributedlog/BKDistributedLogManager.java","status":"modified","additions":74,"deletions":380,"changes":454,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogManager.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -20,12 +20,6 @@\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Optional;\n import com.google.common.base.Preconditions;\n-import com.google.common.base.Ticker;\n-import com.twitter.distributedlog.bk.DynamicQuorumConfigProvider;\n-import com.twitter.distributedlog.bk.LedgerAllocator;\n-import com.twitter.distributedlog.bk.LedgerAllocatorDelegator;\n-import com.twitter.distributedlog.bk.QuorumConfigProvider;\n-import com.twitter.distributedlog.bk.SimpleLedgerAllocator;\n import com.twitter.distributedlog.callback.LogSegmentListener;\n import com.twitter.distributedlog.config.DynamicDistributedLogConfiguration;\n import com.twitter.distributedlog.exceptions.AlreadyClosedException;\n@@ -34,27 +28,22 @@\n import com.twitter.distributedlog.exceptions.UnexpectedException;\n import com.twitter.distributedlog.function.CloseAsyncCloseableFunction;\n import com.twitter.distributedlog.function.GetVersionedValueFunction;\n-import com.twitter.distributedlog.impl.logsegment.BKLogSegmentEntryStore;\n import com.twitter.distributedlog.injector.AsyncFailureInjector;\n-import com.twitter.distributedlog.injector.AsyncRandomFailureInjector;\n import com.twitter.distributedlog.logsegment.LogSegmentEntryStore;\n+import com.twitter.distributedlog.logsegment.LogSegmentEntryWriter;\n import com.twitter.distributedlog.metadata.LogMetadataForReader;\n import com.twitter.distributedlog.metadata.LogMetadataForWriter;\n-import com.twitter.distributedlog.impl.metadata.ZKLogStreamMetadataStore;\n import com.twitter.distributedlog.io.AsyncCloseable;\n import com.twitter.distributedlog.lock.DistributedLock;\n import com.twitter.distributedlog.lock.NopDistributedLock;\n import com.twitter.distributedlog.lock.ZKDistributedLock;\n import com.twitter.distributedlog.logsegment.LogSegmentFilter;\n import com.twitter.distributedlog.logsegment.LogSegmentMetadataCache;\n-import com.twitter.distributedlog.metadata.BKDLConfig;\n import com.twitter.distributedlog.metadata.LogStreamMetadataStore;\n+import com.twitter.distributedlog.namespace.NamespaceDriver;\n import com.twitter.distributedlog.stats.BroadCastStatsLogger;\n-import com.twitter.distributedlog.subscription.SubscriptionStateStore;\n import com.twitter.distributedlog.subscription.SubscriptionsStore;\n-import com.twitter.distributedlog.subscription.ZKSubscriptionStateStore;\n-import com.twitter.distributedlog.subscription.ZKSubscriptionsStore;\n-import com.twitter.distributedlog.util.ConfUtils;\n+import com.twitter.distributedlog.util.Allocator;\n import com.twitter.distributedlog.util.DLUtils;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.MonitoredFuturePool;\n@@ -65,24 +54,20 @@\n import com.twitter.distributedlog.util.Utils;\n import com.twitter.util.ExceptionalFunction;\n import com.twitter.util.ExceptionalFunction0;\n-import com.twitter.util.ExecutorServiceFuturePool;\n import com.twitter.util.Function;\n import com.twitter.util.Future;\n-import com.twitter.util.FuturePool;\n import com.twitter.util.FutureEventListener;\n import com.twitter.util.Promise;\n import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.stats.AlertStatsLogger;\n-import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n-import org.jboss.netty.util.HashedWheelTimer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import scala.runtime.AbstractFunction0;\n import scala.runtime.AbstractFunction1;\n import scala.runtime.BoxedUnit;\n \n+import java.io.Closeable;\n import java.io.IOException;\n import java.net.URI;\n import java.util.HashSet;\n@@ -91,6 +76,9 @@\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.TimeUnit;\n \n+import static com.twitter.distributedlog.namespace.NamespaceDriver.Role.READER;\n+import static com.twitter.distributedlog.namespace.NamespaceDriver.Role.WRITER;\n+\n /**\n  * <h3>Metrics</h3>\n  * <ul>\n@@ -112,7 +100,7 @@\n  * for details.\n  * </ul>\n  */\n-class BKDistributedLogManager extends ZKMetadataAccessor implements DistributedLogManager {\n+class BKDistributedLogManager implements DistributedLogManager {\n     static final Logger LOG = LoggerFactory.getLogger(BKDistributedLogManager.class);\n \n     static final Function<LogRecordWithDLSN, Long> RECORD_2_TXID_FUNCTION =\n@@ -131,137 +119,55 @@ public DLSN apply(LogRecordWithDLSN record) {\n                 }\n             };\n \n+    private final URI uri;\n+    private final String name;\n     private final String clientId;\n     private final int regionId;\n     private final String streamIdentifier;\n     private final DistributedLogConfiguration conf;\n     private final DynamicDistributedLogConfiguration dynConf;\n+    private final NamespaceDriver driver;\n     private Promise<Void> closePromise;\n     private final OrderedScheduler scheduler;\n-    private final OrderedScheduler readAheadScheduler;\n-    private boolean ownExecutor;\n     private final FeatureProvider featureProvider;\n+    private final AsyncFailureInjector failureInjector;\n     private final StatsLogger statsLogger;\n     private final StatsLogger perLogStatsLogger;\n     final AlertStatsLogger alertStatsLogger;\n \n-    // log stream metadata stores\n-    private final LogStreamMetadataStore writerMetadataStore;\n-    private final LogStreamMetadataStore readerMetadataStore;\n     // log segment metadata cache\n     private final LogSegmentMetadataCache logSegmentMetadataCache;\n \n-    // bookkeeper clients\n-    // NOTE: The actual bookkeeper client is initialized lazily when it is referenced by\n-    //       {@link com.twitter.distributedlog.BookKeeperClient#get()}. So it is safe to\n-    //       keep builders and their client wrappers here, as they will be used when\n-    //       instantiating readers or writers.\n-    private final BookKeeperClientBuilder writerBKCBuilder;\n-    private final BookKeeperClient writerBKC;\n-    private final LogSegmentEntryStore writerEntryStore;\n-    private final boolean ownWriterBKC;\n-    private final BookKeeperClientBuilder readerBKCBuilder;\n-    private final BookKeeperClient readerBKC;\n-    private final LogSegmentEntryStore readerEntryStore;\n-    private final boolean ownReaderBKC;\n-\n     //\n     // Writer Related Variables\n     //\n-    private final LedgerAllocator ledgerAllocator;\n     private final PermitLimiter writeLimiter;\n \n     //\n     // Reader Related Variables\n     ///\n     // read handler for listener.\n     private BKLogReadHandler readHandlerForListener = null;\n-    private FuturePool readerFuturePool = null;\n     private final PendingReaders pendingReaders;\n \n-    // Failure Injector\n-    private final AsyncFailureInjector failureInjector;\n-\n-    /**\n-     * Create a DLM for testing.\n-     *\n-     * @param name log name\n-     * @param conf distributedlog configuration\n-     * @param uri uri location for the log\n-     * @param writerZKCBuilder zookeeper builder for writers\n-     * @param readerZKCBuilder zookeeper builder for readers\n-     * @param zkcForWriterBKC zookeeper builder for bookkeeper shared by writers\n-     * @param zkcForReaderBKC zookeeper builder for bookkeeper shared by readers\n-     * @param writerBKCBuilder bookkeeper builder for writers\n-     * @param readerBKCBuilder bookkeeper builder for readers\n-     * @param featureProvider provider to offer features\n-     * @param writeLimiter write limiter\n-     * @param statsLogger stats logger to receive stats\n-     * @throws IOException\n-     */\n-    BKDistributedLogManager(String name,\n-                            DistributedLogConfiguration conf,\n-                            URI uri,\n-                            ZooKeeperClientBuilder writerZKCBuilder,\n-                            ZooKeeperClientBuilder readerZKCBuilder,\n-                            ZooKeeperClient zkcForWriterBKC,\n-                            ZooKeeperClient zkcForReaderBKC,\n-                            BookKeeperClientBuilder writerBKCBuilder,\n-                            BookKeeperClientBuilder readerBKCBuilder,\n-                            FeatureProvider featureProvider,\n-                            PermitLimiter writeLimiter,\n-                            StatsLogger statsLogger) throws IOException {\n-        this(name,\n-             conf,\n-             ConfUtils.getConstDynConf(conf),\n-             uri,\n-             writerZKCBuilder,\n-             readerZKCBuilder,\n-             zkcForWriterBKC,\n-             zkcForReaderBKC,\n-             writerBKCBuilder,\n-             readerBKCBuilder,\n-             null,\n-             null,\n-             new LogSegmentMetadataCache(conf, Ticker.systemTicker()),\n-             OrderedScheduler.newBuilder().name(\"BKDL-\" + name).corePoolSize(1).build(),\n-             null,\n-             null,\n-             null,\n-             DistributedLogConstants.UNKNOWN_CLIENT_ID,\n-             DistributedLogConstants.LOCAL_REGION_ID,\n-             null,\n-             writeLimiter,\n-             featureProvider,\n-             statsLogger,\n-             NullStatsLogger.INSTANCE);\n-        this.ownExecutor = true;\n-    }\n+    // resource to close\n+    private final Optional<AsyncCloseable> resourcesCloseable;\n \n     /**\n      * Create a {@link DistributedLogManager} with supplied resources.\n      *\n      * @param name log name\n      * @param conf distributedlog configuration\n+     * @param dynConf dynamic distributedlog configuration\n      * @param uri uri location for the log\n-     * @param writerZKCBuilder zookeeper builder for writers\n-     * @param readerZKCBuilder zookeeper builder for readers\n-     * @param zkcForWriterBKC zookeeper builder for bookkeeper shared by writers\n-     * @param zkcForReaderBKC zookeeper builder for bookkeeper shared by readers\n-     * @param writerBKCBuilder bookkeeper builder for writers\n-     * @param readerBKCBuilder bookkeeper builder for readers\n-     * @param writerMetadataStore writer metadata store\n-     * @param readerMetadataStore reader metadata store\n+     * @param driver namespace driver\n+     * @param logSegmentMetadataCache log segment metadata cache\n      * @param scheduler ordered scheduled used by readers and writers\n-     * @param readAheadScheduler readAhead scheduler used by readers\n-     * @param channelFactory client socket channel factory to build bookkeeper clients\n-     * @param requestTimer request timer to build bookkeeper clients\n      * @param clientId client id that used to initiate the locks\n      * @param regionId region id that would be encrypted as part of log segment metadata\n      *                 to indicate which region that the log segment will be created\n-     * @param ledgerAllocator ledger allocator to allocate ledgers\n-     * @param featureProvider provider to offer features\n      * @param writeLimiter write limiter\n+     * @param featureProvider provider to offer features\n      * @param statsLogger stats logger to receive stats\n      * @param perLogStatsLogger stats logger to receive per log stats\n      * @throws IOException\n@@ -270,148 +176,48 @@ public DLSN apply(LogRecordWithDLSN record) {\n                             DistributedLogConfiguration conf,\n                             DynamicDistributedLogConfiguration dynConf,\n                             URI uri,\n-                            ZooKeeperClientBuilder writerZKCBuilder,\n-                            ZooKeeperClientBuilder readerZKCBuilder,\n-                            ZooKeeperClient zkcForWriterBKC,\n-                            ZooKeeperClient zkcForReaderBKC,\n-                            BookKeeperClientBuilder writerBKCBuilder,\n-                            BookKeeperClientBuilder readerBKCBuilder,\n-                            LogStreamMetadataStore writerMetadataStore,\n-                            LogStreamMetadataStore readerMetadataStore,\n+                            NamespaceDriver driver,\n                             LogSegmentMetadataCache logSegmentMetadataCache,\n                             OrderedScheduler scheduler,\n-                            OrderedScheduler readAheadScheduler,\n-                            ClientSocketChannelFactory channelFactory,\n-                            HashedWheelTimer requestTimer,\n                             String clientId,\n                             Integer regionId,\n-                            LedgerAllocator ledgerAllocator,\n                             PermitLimiter writeLimiter,\n                             FeatureProvider featureProvider,\n+                            AsyncFailureInjector failureInjector,\n                             StatsLogger statsLogger,\n-                            StatsLogger perLogStatsLogger) throws IOException {\n-        super(name, conf, uri, writerZKCBuilder, readerZKCBuilder, statsLogger);\n+                            StatsLogger perLogStatsLogger,\n+                            Optional<AsyncCloseable> resourcesCloseable) {\n+        this.name = name;\n         this.conf = conf;\n         this.dynConf = dynConf;\n+        this.uri = uri;\n+        this.driver = driver;\n+        this.logSegmentMetadataCache = logSegmentMetadataCache;\n         this.scheduler = scheduler;\n-        this.readAheadScheduler = null == readAheadScheduler ? scheduler : readAheadScheduler;\n         this.statsLogger = statsLogger;\n         this.perLogStatsLogger = BroadCastStatsLogger.masterslave(perLogStatsLogger, statsLogger);\n-        this.ownExecutor = false;\n         this.pendingReaders = new PendingReaders(scheduler);\n         this.regionId = regionId;\n         this.clientId = clientId;\n         this.streamIdentifier = conf.getUnpartitionedStreamName();\n-        this.ledgerAllocator = ledgerAllocator;\n         this.writeLimiter = writeLimiter;\n-\n-        // Failure Injection\n-        this.failureInjector = AsyncRandomFailureInjector.newBuilder()\n-                .injectDelays(conf.getEIInjectReadAheadDelay(),\n-                              conf.getEIInjectReadAheadDelayPercent(),\n-                              conf.getEIInjectMaxReadAheadDelayMs())\n-                .injectErrors(false, 10)\n-                .injectStops(conf.getEIInjectReadAheadStall(), 10)\n-                .injectCorruption(conf.getEIInjectReadAheadBrokenEntries())\n-                .build();\n-\n-        if (null == writerMetadataStore) {\n-            this.writerMetadataStore = new ZKLogStreamMetadataStore(\n-                    clientId,\n-                    conf,\n-                    writerZKC,\n-                    scheduler,\n-                    statsLogger);\n-        } else {\n-            this.writerMetadataStore = writerMetadataStore;\n-        }\n-        if (null == readerMetadataStore) {\n-            this.readerMetadataStore = new ZKLogStreamMetadataStore(\n-                    clientId,\n-                    conf,\n-                    readerZKC,\n-                    scheduler,\n-                    statsLogger);\n-        } else {\n-            this.readerMetadataStore = readerMetadataStore;\n-        }\n-        this.logSegmentMetadataCache = logSegmentMetadataCache;\n-\n-        // create the bkc for writers\n-        if (null == writerBKCBuilder) {\n-            // resolve uri\n-            BKDLConfig bkdlConfig = BKDLConfig.resolveDLConfig(writerZKC, uri);\n-            BKDLConfig.propagateConfiguration(bkdlConfig, conf);\n-            this.writerBKCBuilder = BookKeeperClientBuilder.newBuilder()\n-                    .dlConfig(conf)\n-                    .name(String.format(\"bk:%s:dlm_writer_shared\", name))\n-                    .ledgersPath(bkdlConfig.getBkLedgersPath())\n-                    .channelFactory(channelFactory)\n-                    .requestTimer(requestTimer)\n-                    .statsLogger(statsLogger);\n-            if (null == zkcForWriterBKC) {\n-                this.writerBKCBuilder.zkServers(bkdlConfig.getBkZkServersForWriter());\n-            } else {\n-                this.writerBKCBuilder.zkc(zkcForWriterBKC);\n-            }\n-            this.ownWriterBKC = true;\n-        } else {\n-            this.writerBKCBuilder = writerBKCBuilder;\n-            this.ownWriterBKC = false;\n-        }\n-        this.writerBKC = this.writerBKCBuilder.build();\n-        this.writerEntryStore = new BKLogSegmentEntryStore(\n-                conf,\n-                writerBKC,\n-                scheduler,\n-                statsLogger,\n-                failureInjector);\n-\n-        // create the bkc for readers\n-        if (null == readerBKCBuilder) {\n-            // resolve uri\n-            BKDLConfig bkdlConfig = BKDLConfig.resolveDLConfig(writerZKC, uri);\n-            BKDLConfig.propagateConfiguration(bkdlConfig, conf);\n-            if (bkdlConfig.getBkZkServersForWriter().equals(bkdlConfig.getBkZkServersForReader())) {\n-                this.readerBKCBuilder = this.writerBKCBuilder;\n-                this.ownReaderBKC = false;\n-            } else {\n-                this.readerBKCBuilder = BookKeeperClientBuilder.newBuilder()\n-                        .dlConfig(conf)\n-                        .name(String.format(\"bk:%s:dlm_reader_shared\", name))\n-                        .ledgersPath(bkdlConfig.getBkLedgersPath())\n-                        .channelFactory(channelFactory)\n-                        .requestTimer(requestTimer)\n-                        .statsLogger(statsLogger);\n-                if (null == zkcForReaderBKC) {\n-                    this.readerBKCBuilder.zkServers(bkdlConfig.getBkZkServersForReader());\n-                } else {\n-                    this.readerBKCBuilder.zkc(zkcForReaderBKC);\n-                }\n-                this.ownReaderBKC = true;\n-            }\n-        } else {\n-            this.readerBKCBuilder = readerBKCBuilder;\n-            this.ownReaderBKC = false;\n-        }\n-        this.readerBKC = this.readerBKCBuilder.build();\n-        this.readerEntryStore = new BKLogSegmentEntryStore(\n-                conf,\n-                readerBKC,\n-                scheduler,\n-                statsLogger,\n-                failureInjector);\n-\n         // Feature Provider\n         this.featureProvider = featureProvider;\n-\n+        // Failure Injector\n+        this.failureInjector = failureInjector;\n         // Stats\n         this.alertStatsLogger = new AlertStatsLogger(this.perLogStatsLogger, \"dl_alert\");\n+        this.resourcesCloseable = resourcesCloseable;\n     }\n \n-    @VisibleForTesting\n-    LogStreamMetadataStore getWriterMetadataStore() {\n-        return writerMetadataStore;\n+    @Override\n+    public String getStreamName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public NamespaceDriver getNamespaceDriver() {\n+        return driver;\n     }\n \n     URI getUri() {\n@@ -426,34 +232,29 @@ OrderedScheduler getScheduler() {\n         return scheduler;\n     }\n \n-    @VisibleForTesting\n-    BookKeeperClient getWriterBKC() {\n-        return this.writerBKC;\n+    AsyncFailureInjector getFailureInjector() {\n+        return failureInjector;\n     }\n \n-    @VisibleForTesting\n-    BookKeeperClient getReaderBKC() {\n-        return this.readerBKC;\n-    }\n+    //\n+    // Test Methods\n+    //\n \n-    LogSegmentEntryStore getReaderEntryStore() {\n-        return this.readerEntryStore;\n+    @VisibleForTesting\n+    LogStreamMetadataStore getWriterMetadataStore() {\n+        return driver.getLogStreamMetadataStore(WRITER);\n     }\n \n     @VisibleForTesting\n-    FuturePool getReaderFuturePool() {\n-        return this.readerFuturePool;\n+    LogSegmentEntryStore getReaderEntryStore() {\n+        return driver.getLogSegmentEntryStore(READER);\n     }\n \n     @VisibleForTesting\n     FeatureProvider getFeatureProvider() {\n         return this.featureProvider;\n     }\n \n-    AsyncFailureInjector getFailureInjector() {\n-        return this.failureInjector;\n-    }\n-\n     private synchronized BKLogReadHandler getReadHandlerAndRegisterListener(\n             boolean create, LogSegmentListener listener) {\n         if (null == readHandlerForListener && create) {\n@@ -502,12 +303,6 @@ public void checkClosedOrInError(String operation) throws AlreadyClosedException\n                 throw new AlreadyClosedException(\"Executing \" + operation + \" on already closed DistributedLogManager\");\n             }\n         }\n-        if (null != writerBKC) {\n-            writerBKC.checkClosedOrInError();\n-        }\n-        if (null != readerBKC) {\n-            readerBKC.checkClosedOrInError();\n-        }\n     }\n \n     // Create Read Handler\n@@ -538,9 +333,9 @@ synchronized BKLogReadHandler createReadHandler(Optional<String> subscriberId,\n                 subscriberId,\n                 conf,\n                 dynConf,\n-                readerMetadataStore,\n+                driver.getLogStreamMetadataStore(READER),\n                 logSegmentMetadataCache,\n-                readerEntryStore,\n+                driver.getLogSegmentEntryStore(READER),\n                 scheduler,\n                 alertStatsLogger,\n                 statsLogger,\n@@ -552,23 +347,7 @@ synchronized BKLogReadHandler createReadHandler(Optional<String> subscriberId,\n \n     // Create Ledger Allocator\n \n-    LedgerAllocator createLedgerAllocator(LogMetadataForWriter logMetadata) throws IOException {\n-        LedgerAllocator ledgerAllocatorDelegator;\n-        if (!dynConf.getEnableLedgerAllocatorPool()) {\n-            QuorumConfigProvider quorumConfigProvider =\n-                    new DynamicQuorumConfigProvider(dynConf);\n-            LedgerAllocator allocator = new SimpleLedgerAllocator(\n-                    logMetadata.getAllocationPath(),\n-                    logMetadata.getAllocationData(),\n-                    quorumConfigProvider,\n-                    writerZKC,\n-                    writerBKC);\n-            ledgerAllocatorDelegator = new LedgerAllocatorDelegator(allocator, true);\n-        } else {\n-            ledgerAllocatorDelegator = ledgerAllocator;\n-        }\n-        return ledgerAllocatorDelegator;\n-    }\n+\n \n     // Create Write Handler\n \n@@ -578,14 +357,12 @@ public BKLogWriteHandler createWriteHandler(boolean lockHandler)\n     }\n \n     Future<BKLogWriteHandler> asyncCreateWriteHandler(final boolean lockHandler) {\n-        boolean ownAllocator = null == ledgerAllocator;\n-\n         // Fetching Log Metadata (create if not exists)\n-        return writerMetadataStore.getLog(\n+        return driver.getLogStreamMetadataStore(WRITER).getLog(\n                 uri,\n                 name,\n-                ownAllocator,\n-                conf.getCreateStreamIfNotExists() || ownAllocator\n+                true,\n+                conf.getCreateStreamIfNotExists()\n         ).flatMap(new AbstractFunction1<LogMetadataForWriter, Future<BKLogWriteHandler>>() {\n             @Override\n             public Future<BKLogWriteHandler> apply(LogMetadataForWriter logMetadata) {\n@@ -602,28 +379,29 @@ private void createWriteHandler(LogMetadataForWriter logMetadata,\n         // Build the locks\n         DistributedLock lock;\n         if (conf.isWriteLockEnabled()) {\n-            lock = writerMetadataStore.createWriteLock(logMetadata);\n+            lock = driver.getLogStreamMetadataStore(WRITER).createWriteLock(logMetadata);\n         } else {\n             lock = NopDistributedLock.INSTANCE;\n         }\n-        // Build the ledger allocator\n-        LedgerAllocator allocator;\n+\n+        Allocator<LogSegmentEntryWriter, Object> segmentAllocator;\n         try {\n-            allocator = createLedgerAllocator(logMetadata);\n-        } catch (IOException e) {\n-            FutureUtils.setException(createPromise, e);\n+            segmentAllocator = driver.getLogSegmentEntryStore(WRITER)\n+                    .newLogSegmentAllocator(logMetadata, dynConf);\n+        } catch (IOException ioe) {\n+            FutureUtils.setException(createPromise, ioe);\n             return;\n         }\n \n         // Make sure writer handler created before resources are initialized\n         final BKLogWriteHandler writeHandler = new BKLogWriteHandler(\n                 logMetadata,\n                 conf,\n-                writerMetadataStore,\n+                driver.getLogStreamMetadataStore(WRITER),\n                 logSegmentMetadataCache,\n-                writerEntryStore,\n+                driver.getLogSegmentEntryStore(WRITER),\n                 scheduler,\n-                allocator,\n+                segmentAllocator,\n                 statsLogger,\n                 perLogStatsLogger,\n                 alertStatsLogger,\n@@ -657,12 +435,11 @@ public BoxedUnit apply() {\n     }\n \n     PermitManager getLogSegmentRollingPermitManager() {\n-        return writerMetadataStore.getPermitManager();\n+        return driver.getLogStreamMetadataStore(WRITER).getPermitManager();\n     }\n \n     <T> Future<T> processReaderOperation(final Function<BKLogReadHandler, Future<T>> func) {\n-        initializeFuturePool(false);\n-        return readerFuturePool.apply(new ExceptionalFunction0<BKLogReadHandler>() {\n+        return scheduler.apply(new ExceptionalFunction0<BKLogReadHandler>() {\n             @Override\n             public BKLogReadHandler applyE() throws Throwable {\n                 return getReadHandlerAndRegisterListener(true, null);\n@@ -822,7 +599,7 @@ private Future<DLSN> getDLSNNotLessThanTxId(long fromTxnId,\n                 fromTxnId,\n                 segmentIdx,\n                 segments,\n-                readerEntryStore\n+                driver.getLogSegmentEntryStore(READER)\n         );\n     }\n \n@@ -1010,8 +787,9 @@ public Future<AsyncLogReader> apply(Void complete) {\n                 LOG.info(\"Reader {} @ {} reading last commit position from subscription store after acquired lock.\",\n                         subscriberId.get(), name);\n                 // we acquired lock\n-                final SubscriptionStateStore stateStore = getSubscriptionStateStore(subscriberId.get());\n-                return stateStore.getLastCommitPosition().map(new ExceptionalFunction<DLSN, AsyncLogReader>() {\n+                final SubscriptionsStore subscriptionsStore = driver.getSubscriptionsStore(getStreamName());\n+                return subscriptionsStore.getLastCommitPosition(subscriberId.get())\n+                        .map(new ExceptionalFunction<DLSN, AsyncLogReader>() {\n                     @Override\n                     public AsyncLogReader applyE(DLSN lastCommitPosition) throws UnexpectedException {\n                         LOG.info(\"Reader {} @ {} positioned to last commit position {}.\",\n@@ -1226,7 +1004,8 @@ private void recoverInternal(String streamIdentifier) throws IOException {\n      */\n     @Override\n     public void delete() throws IOException {\n-        FutureUtils.result(writerMetadataStore.deleteLog(uri, getStreamName()));\n+        FutureUtils.result(driver.getLogStreamMetadataStore(WRITER)\n+                .deleteLog(uri, getStreamName()));\n     }\n \n     /**\n@@ -1297,43 +1076,10 @@ public Future<Void> asyncClose() {\n             readHandlerToClose = readHandlerForListener;\n         }\n \n-        // NOTE: the resources {scheduler, writerBKC, readerBKC} are mostly from namespace instance.\n-        //       so they are not blocking call except tests.\n-        AsyncCloseable resourcesCloseable = new AsyncCloseable() {\n-            @Override\n-            public Future<Void> asyncClose() {\n-                int schedTimeout = conf.getSchedulerShutdownTimeoutMs();\n-\n-                // Clean up executor state.\n-                if (ownExecutor) {\n-                    SchedulerUtils.shutdownScheduler(scheduler, schedTimeout, TimeUnit.MILLISECONDS);\n-                    LOG.info(\"Stopped BKDL executor service for {}.\", name);\n-\n-                    if (scheduler != readAheadScheduler) {\n-                        SchedulerUtils.shutdownScheduler(readAheadScheduler, schedTimeout, TimeUnit.MILLISECONDS);\n-                        LOG.info(\"Stopped BKDL ReadAhead Executor Service for {}.\", name);\n-                    }\n-                }\n-                if (ownWriterBKC) {\n-                    writerBKC.close();\n-                }\n-                if (ownReaderBKC) {\n-                    readerBKC.close();\n-                }\n-                return Future.Void();\n-            }\n-        };\n-\n         Future<Void> closeResult = Utils.closeSequence(null, true,\n                 readHandlerToClose,\n                 pendingReaders,\n-                resourcesCloseable,\n-                new AsyncCloseable() {\n-                    @Override\n-                    public Future<Void> asyncClose() {\n-                        return BKDistributedLogManager.super.asyncClose();\n-                    }\n-                });\n+                resourcesCloseable.or(AsyncCloseable.NULL));\n         closeResult.proxyTo(closeFuture);\n         return closeFuture;\n     }\n@@ -1343,70 +1089,18 @@ public void close() throws IOException {\n         FutureUtils.result(asyncClose());\n     }\n \n-    private FuturePool buildFuturePool(ExecutorService executorService,\n-                                       StatsLogger statsLogger) {\n-        FuturePool futurePool = new ExecutorServiceFuturePool(executorService);\n-        return new MonitoredFuturePool(\n-                futurePool,\n-                statsLogger,\n-                conf.getEnableTaskExecutionStats(),\n-                conf.getTaskExecutionWarnTimeMicros());\n-    }\n-\n-    private void initializeFuturePool(boolean ordered) {\n-        // ownExecutor is a single threaded thread pool\n-        if (null == readerFuturePool) {\n-            readerFuturePool = buildFuturePool(\n-                    scheduler, statsLogger.scope(\"reader_future_pool\"));\n-        }\n-    }\n-\n     @Override\n     public String toString() {\n-        return String.format(\"DLM:%s:%s\", getZKPath(), getStreamName());\n+        return String.format(\"DLM:%s:%s\", getUri(), getStreamName());\n     }\n \n     public void raiseAlert(String msg, Object... args) {\n         alertStatsLogger.raise(msg, args);\n     }\n \n-    /**\n-     * Get the subscription state storage provided by the distributed log manager\n-     *\n-     * @param subscriberId - Application specific Id associated with the subscriber\n-     * @return Subscription state store\n-     */\n-    @Override\n-    @Deprecated\n-    public SubscriptionStateStore getSubscriptionStateStore(String subscriberId) {\n-        return getSubscriptionStateStoreInternal(conf.getUnpartitionedStreamName(), subscriberId);\n-    }\n-\n-    /**\n-     * Get the subscription state storage provided by the distributed log manager\n-     *\n-     * @param streamIdentifier - Identifier associated with the stream\n-     * @param subscriberId - Application specific Id associated with the subscriber\n-     * @return Subscription state store\n-     */\n-    private SubscriptionStateStore getSubscriptionStateStoreInternal(String streamIdentifier, String subscriberId) {\n-        return new ZKSubscriptionStateStore(writerZKC,\n-                LogMetadataForReader.getSubscriberPath(uri, name, streamIdentifier, subscriberId));\n-    }\n-\n     @Override\n     public SubscriptionsStore getSubscriptionsStore() {\n-        return getSubscriptionsStoreInternal(conf.getUnpartitionedStreamName());\n+        return driver.getSubscriptionsStore(getStreamName());\n     }\n \n-    /**\n-     * Get the subscription state storage provided by the distributed log manager\n-     *\n-     * @param streamIdentifier - Identifier associated with the stream\n-     * @return Subscriptions store\n-     */\n-    private SubscriptionsStore getSubscriptionsStoreInternal(String streamIdentifier) {\n-        return new ZKSubscriptionsStore(writerZKC,\n-                LogMetadataForReader.getSubscribersPath(uri, name, streamIdentifier));\n-    }\n }"},{"sha":"a8b1f77889efeb4fbad11c894f6de2f232df79f5","filename":"src/main/java/com/twitter/distributedlog/BKDistributedLogNamespace.java","status":"modified","additions":59,"deletions":787,"changes":846,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogNamespace.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogNamespace.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKDistributedLogNamespace.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -17,71 +17,39 @@\n  */\n package com.twitter.distributedlog;\n \n-import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Optional;\n-import com.google.common.base.Preconditions;\n import com.google.common.base.Ticker;\n-import com.google.common.collect.Sets;\n-import com.google.common.util.concurrent.ThreadFactoryBuilder;\n-import com.twitter.distributedlog.DistributedLogManagerFactory.ClientSharingOption;\n import com.twitter.distributedlog.acl.AccessControlManager;\n-import com.twitter.distributedlog.acl.DefaultAccessControlManager;\n-import com.twitter.distributedlog.acl.ZKAccessControlManager;\n-import com.twitter.distributedlog.bk.LedgerAllocator;\n-import com.twitter.distributedlog.bk.LedgerAllocatorUtils;\n import com.twitter.distributedlog.callback.NamespaceListener;\n import com.twitter.distributedlog.config.DynamicDistributedLogConfiguration;\n import com.twitter.distributedlog.exceptions.AlreadyClosedException;\n import com.twitter.distributedlog.exceptions.InvalidStreamNameException;\n import com.twitter.distributedlog.exceptions.LogNotFoundException;\n-import com.twitter.distributedlog.feature.CoreFeatureKeys;\n-import com.twitter.distributedlog.impl.ZKLogMetadataStore;\n-import com.twitter.distributedlog.impl.federated.FederatedZKLogMetadataStore;\n-import com.twitter.distributedlog.impl.metadata.ZKLogStreamMetadataStore;\n+import com.twitter.distributedlog.injector.AsyncFailureInjector;\n+import com.twitter.distributedlog.io.AsyncCloseable;\n import com.twitter.distributedlog.logsegment.LogSegmentMetadataCache;\n-import com.twitter.distributedlog.metadata.BKDLConfig;\n-import com.twitter.distributedlog.metadata.LogMetadataStore;\n-import com.twitter.distributedlog.metadata.LogStreamMetadataStore;\n import com.twitter.distributedlog.namespace.DistributedLogNamespace;\n+import com.twitter.distributedlog.namespace.NamespaceDriver;\n import com.twitter.distributedlog.util.ConfUtils;\n-import com.twitter.distributedlog.util.DLUtils;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.MonitoredScheduledThreadPoolExecutor;\n import com.twitter.distributedlog.util.OrderedScheduler;\n import com.twitter.distributedlog.util.PermitLimiter;\n import com.twitter.distributedlog.util.SchedulerUtils;\n-import com.twitter.distributedlog.util.SimplePermitLimiter;\n import com.twitter.distributedlog.util.Utils;\n import org.apache.bookkeeper.feature.FeatureProvider;\n-import org.apache.bookkeeper.feature.Feature;\n-import org.apache.bookkeeper.feature.SettableFeatureProvider;\n-import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.bookkeeper.zookeeper.BoundExponentialBackoffRetryPolicy;\n-import org.apache.bookkeeper.zookeeper.RetryPolicy;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.ZooKeeper;\n-import org.apache.zookeeper.common.PathUtils;\n-import org.apache.zookeeper.data.Stat;\n-import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n-import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n-import org.jboss.netty.util.HashedWheelTimer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n-import java.net.InetAddress;\n import java.net.URI;\n-import java.util.Collection;\n-import java.util.HashMap;\n import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.Executors;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n-import static com.twitter.distributedlog.impl.BKDLUtils.*;\n+import static com.twitter.distributedlog.namespace.NamespaceDriver.Role.WRITER;\n+import static com.twitter.distributedlog.util.DLUtils.validateName;\n \n /**\n  * BKDistributedLogNamespace is the default implementation of {@link DistributedLogNamespace}. It uses\n@@ -119,344 +87,57 @@\n public class BKDistributedLogNamespace implements DistributedLogNamespace {\n     static final Logger LOG = LoggerFactory.getLogger(BKDistributedLogNamespace.class);\n \n-    public static Builder newBuilder() {\n-        return new Builder();\n-    }\n-\n-    public static class Builder {\n-        private DistributedLogConfiguration _conf = null;\n-        private URI _uri = null;\n-        private StatsLogger _statsLogger = NullStatsLogger.INSTANCE;\n-        private StatsLogger _perLogStatsLogger = NullStatsLogger.INSTANCE;\n-        private FeatureProvider _featureProvider = new SettableFeatureProvider(\"\", 0);\n-        private String _clientId = DistributedLogConstants.UNKNOWN_CLIENT_ID;\n-        private int _regionId = DistributedLogConstants.LOCAL_REGION_ID;\n-\n-        private Builder() {}\n-\n-        public Builder conf(DistributedLogConfiguration conf) {\n-            this._conf = conf;\n-            return this;\n-        }\n-\n-        public Builder uri(URI uri) {\n-            this._uri = uri;\n-            return this;\n-        }\n-\n-        public Builder statsLogger(StatsLogger statsLogger) {\n-            this._statsLogger = statsLogger;\n-            return this;\n-        }\n-\n-        public Builder perLogStatsLogger(StatsLogger perLogStatsLogger) {\n-            this._perLogStatsLogger = perLogStatsLogger;\n-            return this;\n-        }\n-\n-        public Builder featureProvider(FeatureProvider featureProvider) {\n-            this._featureProvider = featureProvider;\n-            return this;\n-        }\n-\n-        public Builder clientId(String clientId) {\n-            this._clientId = clientId;\n-            return this;\n-        }\n-\n-        public Builder regionId(int regionId) {\n-            this._regionId = regionId;\n-            return this;\n-        }\n-\n-        @SuppressWarnings(\"deprecation\")\n-        public BKDistributedLogNamespace build()\n-                throws IOException, NullPointerException, IllegalArgumentException {\n-            Preconditions.checkNotNull(_conf, \"No DistributedLog Configuration\");\n-            Preconditions.checkNotNull(_uri, \"No DistributedLog URI\");\n-            Preconditions.checkNotNull(_featureProvider, \"No Feature Provider\");\n-            Preconditions.checkNotNull(_statsLogger, \"No Stats Logger\");\n-            Preconditions.checkNotNull(_featureProvider, \"No Feature Provider\");\n-            Preconditions.checkNotNull(_clientId, \"No Client ID\");\n-            // validate conf and uri\n-            validateConfAndURI(_conf, _uri);\n-\n-            // Build the namespace zookeeper client\n-            ZooKeeperClientBuilder nsZkcBuilder = createDLZKClientBuilder(\n-                    String.format(\"dlzk:%s:factory_writer_shared\", _uri),\n-                    _conf,\n-                    DLUtils.getZKServersFromDLUri(_uri),\n-                    _statsLogger.scope(\"dlzk_factory_writer_shared\"));\n-            ZooKeeperClient nsZkc = nsZkcBuilder.build();\n-\n-            // Resolve namespace binding\n-            BKDLConfig bkdlConfig = BKDLConfig.resolveDLConfig(nsZkc, _uri);\n-\n-            // Backward Compatible to enable per log stats by configuration settings\n-            StatsLogger perLogStatsLogger = _perLogStatsLogger;\n-            if (perLogStatsLogger == NullStatsLogger.INSTANCE &&\n-                    _conf.getEnablePerStreamStat()) {\n-                perLogStatsLogger = _statsLogger.scope(\"stream\");\n-            }\n-\n-            return new BKDistributedLogNamespace(\n-                    _conf,\n-                    _uri,\n-                    _featureProvider,\n-                    _statsLogger,\n-                    perLogStatsLogger,\n-                    _clientId,\n-                    _regionId,\n-                    nsZkcBuilder,\n-                    nsZkc,\n-                    bkdlConfig);\n-        }\n-    }\n-\n-    static interface ZooKeeperClientHandler<T> {\n-        T handle(ZooKeeperClient zkc) throws IOException;\n-    }\n-\n-    /**\n-     * Run given <i>handler</i> by providing an available new zookeeper client\n-     *\n-     * @param handler\n-     *          Handler to process with provided zookeeper client.\n-     * @param conf\n-     *          Distributedlog Configuration.\n-     * @param namespace\n-     *          Distributedlog Namespace.\n-     */\n-    private static <T> T withZooKeeperClient(ZooKeeperClientHandler<T> handler,\n-                                             DistributedLogConfiguration conf,\n-                                             URI namespace) throws IOException {\n-        ZooKeeperClient zkc = ZooKeeperClientBuilder.newBuilder()\n-                .name(String.format(\"dlzk:%s:factory_static\", namespace))\n-                .sessionTimeoutMs(conf.getZKSessionTimeoutMilliseconds())\n-                .uri(namespace)\n-                .retryThreadCount(conf.getZKClientNumberRetryThreads())\n-                .requestRateLimit(conf.getZKRequestRateLimit())\n-                .zkAclId(conf.getZkAclId())\n-                .build();\n-        try {\n-            return handler.handle(zkc);\n-        } finally {\n-            zkc.close();\n-        }\n-    }\n-\n-    private static String getHostIpLockClientId() {\n-        try {\n-            return InetAddress.getLocalHost().toString();\n-        } catch(Exception ex) {\n-            return DistributedLogConstants.UNKNOWN_CLIENT_ID;\n-        }\n-    }\n-\n     private final String clientId;\n     private final int regionId;\n     private final DistributedLogConfiguration conf;\n     private final URI namespace;\n-    private final BKDLConfig bkdlConfig;\n+    // namespace driver\n+    private final NamespaceDriver driver;\n+    // resources\n     private final OrderedScheduler scheduler;\n-    private final OrderedScheduler readAheadExecutor;\n-    private final ClientSocketChannelFactory channelFactory;\n-    private final HashedWheelTimer requestTimer;\n-    // zookeeper clients\n-    // NOTE: The actual zookeeper client is initialized lazily when it is referenced by\n-    //       {@link com.twitter.distributedlog.ZooKeeperClient#get()}. So it is safe to\n-    //       keep builders and their client wrappers here, as they will be used when\n-    //       instantiating readers or writers.\n-    private final ZooKeeperClientBuilder sharedWriterZKCBuilderForDL;\n-    private final ZooKeeperClient sharedWriterZKCForDL;\n-    private final ZooKeeperClientBuilder sharedReaderZKCBuilderForDL;\n-    private final ZooKeeperClient sharedReaderZKCForDL;\n-    private ZooKeeperClientBuilder sharedWriterZKCBuilderForBK = null;\n-    private ZooKeeperClient sharedWriterZKCForBK = null;\n-    private ZooKeeperClientBuilder sharedReaderZKCBuilderForBK = null;\n-    private ZooKeeperClient sharedReaderZKCForBK = null;\n-    // NOTE: The actual bookkeeper client is initialized lazily when it is referenced by\n-    //       {@link com.twitter.distributedlog.BookKeeperClient#get()}. So it is safe to\n-    //       keep builders and their client wrappers here, as they will be used when\n-    //       instantiating readers or writers.\n-    private final BookKeeperClientBuilder sharedWriterBKCBuilder;\n-    private final BookKeeperClient writerBKC;\n-    private final BookKeeperClientBuilder sharedReaderBKCBuilder;\n-    private final BookKeeperClient readerBKC;\n-    // ledger allocator\n-    private final LedgerAllocator allocator;\n-    // access control manager\n-    private AccessControlManager accessControlManager;\n-    // log metadata store\n-    private final LogMetadataStore metadataStore;\n+    private final PermitLimiter writeLimiter;\n+    private final AsyncFailureInjector failureInjector;\n     // log segment metadata store\n     private final LogSegmentMetadataCache logSegmentMetadataCache;\n-    private final LogStreamMetadataStore writerStreamMetadataStore;\n-    private final LogStreamMetadataStore readerStreamMetadataStore;\n-\n     // feature provider\n     private final FeatureProvider featureProvider;\n-\n     // Stats Loggers\n     private final StatsLogger statsLogger;\n     private final StatsLogger perLogStatsLogger;\n \n-    protected AtomicBoolean closed = new AtomicBoolean(false);\n-\n-    private final PermitLimiter writeLimiter;\n+    protected final AtomicBoolean closed = new AtomicBoolean(false);\n \n-    private BKDistributedLogNamespace(\n+    public BKDistributedLogNamespace(\n             DistributedLogConfiguration conf,\n             URI uri,\n+            NamespaceDriver driver,\n+            OrderedScheduler scheduler,\n             FeatureProvider featureProvider,\n+            PermitLimiter writeLimiter,\n+            AsyncFailureInjector failureInjector,\n             StatsLogger statsLogger,\n             StatsLogger perLogStatsLogger,\n             String clientId,\n-            int regionId,\n-            ZooKeeperClientBuilder nsZkcBuilder,\n-            ZooKeeperClient nsZkc,\n-            BKDLConfig bkdlConfig)\n-            throws IOException, IllegalArgumentException {\n+            int regionId) {\n         this.conf = conf;\n         this.namespace = uri;\n+        this.driver = driver;\n+        this.scheduler = scheduler;\n         this.featureProvider = featureProvider;\n+        this.writeLimiter = writeLimiter;\n+        this.failureInjector = failureInjector;\n         this.statsLogger = statsLogger;\n         this.perLogStatsLogger = perLogStatsLogger;\n+        this.clientId = clientId;\n         this.regionId = regionId;\n-        this.bkdlConfig = bkdlConfig;\n-        if (clientId.equals(DistributedLogConstants.UNKNOWN_CLIENT_ID)) {\n-            this.clientId = getHostIpLockClientId();\n-        } else {\n-            this.clientId = clientId;\n-        }\n-\n-        // Build resources\n-        StatsLogger schedulerStatsLogger = statsLogger.scope(\"factory\").scope(\"thread_pool\");\n-        this.scheduler = OrderedScheduler.newBuilder()\n-                .name(\"DLM-\" + uri.getPath())\n-                .corePoolSize(conf.getNumWorkerThreads())\n-                .statsLogger(schedulerStatsLogger)\n-                .perExecutorStatsLogger(schedulerStatsLogger)\n-                .traceTaskExecution(conf.getEnableTaskExecutionStats())\n-                .traceTaskExecutionWarnTimeUs(conf.getTaskExecutionWarnTimeMicros())\n-                .build();\n-        if (conf.getNumReadAheadWorkerThreads() > 0) {\n-            this.readAheadExecutor = OrderedScheduler.newBuilder()\n-                    .name(\"DLM-\" + uri.getPath() + \"-readahead-executor\")\n-                    .corePoolSize(conf.getNumReadAheadWorkerThreads())\n-                    .statsLogger(statsLogger.scope(\"factory\").scope(\"readahead_thread_pool\"))\n-                    .traceTaskExecution(conf.getTraceReadAheadDeliveryLatency())\n-                    .traceTaskExecutionWarnTimeUs(conf.getTaskExecutionWarnTimeMicros())\n-                    .build();\n-            LOG.info(\"Created dedicated readahead executor : threads = {}\", conf.getNumReadAheadWorkerThreads());\n-        } else {\n-            this.readAheadExecutor = this.scheduler;\n-            LOG.info(\"Used shared executor for readahead.\");\n-        }\n-\n-        this.channelFactory = new NioClientSocketChannelFactory(\n-            Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat(\"DL-netty-boss-%d\").build()),\n-            Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat(\"DL-netty-worker-%d\").build()),\n-            conf.getBKClientNumberIOThreads());\n-        this.requestTimer = new HashedWheelTimer(\n-            new ThreadFactoryBuilder().setNameFormat(\"DLFactoryTimer-%d\").build(),\n-            conf.getTimeoutTimerTickDurationMs(), TimeUnit.MILLISECONDS,\n-            conf.getTimeoutTimerNumTicks());\n \n-        // Build zookeeper client for writers\n-        this.sharedWriterZKCBuilderForDL = nsZkcBuilder;\n-        this.sharedWriterZKCForDL = nsZkc;\n-\n-        // Build zookeeper client for readers\n-        if (bkdlConfig.getDlZkServersForWriter().equals(bkdlConfig.getDlZkServersForReader())) {\n-            this.sharedReaderZKCBuilderForDL = this.sharedWriterZKCBuilderForDL;\n-        } else {\n-            this.sharedReaderZKCBuilderForDL = createDLZKClientBuilder(\n-                    String.format(\"dlzk:%s:factory_reader_shared\", namespace),\n-                    conf,\n-                    bkdlConfig.getDlZkServersForReader(),\n-                    statsLogger.scope(\"dlzk_factory_reader_shared\"));\n-        }\n-        this.sharedReaderZKCForDL = this.sharedReaderZKCBuilderForDL.build();\n-\n-        // Build bookkeeper client for writers\n-        this.sharedWriterBKCBuilder = createBKCBuilder(\n-                String.format(\"bk:%s:factory_writer_shared\", namespace),\n-                conf,\n-                bkdlConfig.getBkZkServersForWriter(),\n-                bkdlConfig.getBkLedgersPath(),\n-                Optional.of(featureProvider.scope(\"bkc\")));\n-        this.writerBKC = this.sharedWriterBKCBuilder.build();\n-\n-        // Build bookkeeper client for readers\n-        if (bkdlConfig.getBkZkServersForWriter().equals(bkdlConfig.getBkZkServersForReader())) {\n-            this.sharedReaderBKCBuilder = this.sharedWriterBKCBuilder;\n-        } else {\n-            this.sharedReaderBKCBuilder = createBKCBuilder(\n-                String.format(\"bk:%s:factory_reader_shared\", namespace),\n-                conf,\n-                bkdlConfig.getBkZkServersForReader(),\n-                bkdlConfig.getBkLedgersPath(),\n-                Optional.<FeatureProvider>absent());\n-        }\n-        this.readerBKC = this.sharedReaderBKCBuilder.build();\n-\n-        if (conf.getGlobalOutstandingWriteLimit() < 0) {\n-            this.writeLimiter = PermitLimiter.NULL_PERMIT_LIMITER;\n-        } else {\n-            Feature disableWriteLimitFeature = featureProvider.getFeature(\n-                CoreFeatureKeys.DISABLE_WRITE_LIMIT.name().toLowerCase());\n-            this.writeLimiter = new SimplePermitLimiter(\n-                conf.getOutstandingWriteLimitDarkmode(),\n-                conf.getGlobalOutstandingWriteLimit(),\n-                statsLogger.scope(\"writeLimiter\"),\n-                true /* singleton */,\n-                disableWriteLimitFeature);\n-        }\n-\n-        // propagate bkdlConfig to configuration\n-        BKDLConfig.propagateConfiguration(bkdlConfig, conf);\n-\n-        // Build the allocator\n-        if (conf.getEnableLedgerAllocatorPool()) {\n-            String allocatorPoolPath = validateAndGetFullLedgerAllocatorPoolPath(conf, uri);\n-            allocator = LedgerAllocatorUtils.createLedgerAllocatorPool(allocatorPoolPath, conf.getLedgerAllocatorPoolCoreSize(),\n-                    conf, sharedWriterZKCForDL, writerBKC, scheduler);\n-            if (null != allocator) {\n-                allocator.start();\n-            }\n-            LOG.info(\"Created ledger allocator pool under {} with size {}.\", allocatorPoolPath, conf.getLedgerAllocatorPoolCoreSize());\n-        } else {\n-            allocator = null;\n-        }\n-\n-        // log metadata store\n-        if (bkdlConfig.isFederatedNamespace() || conf.isFederatedNamespaceEnabled()) {\n-            this.metadataStore = new FederatedZKLogMetadataStore(conf, namespace, sharedReaderZKCForDL, scheduler);\n-        } else {\n-            this.metadataStore = new ZKLogMetadataStore(conf, namespace, sharedReaderZKCForDL, scheduler);\n-        }\n-\n-        // create log stream metadata store\n-        this.writerStreamMetadataStore =\n-                new ZKLogStreamMetadataStore(\n-                        clientId,\n-                        conf,\n-                        sharedWriterZKCForDL,\n-                        scheduler,\n-                        statsLogger);\n-        this.readerStreamMetadataStore =\n-                new ZKLogStreamMetadataStore(\n-                        clientId,\n-                        conf,\n-                        sharedReaderZKCForDL,\n-                        scheduler,\n-                        statsLogger);\n         // create a log segment metadata cache\n         this.logSegmentMetadataCache = new LogSegmentMetadataCache(conf, Ticker.systemTicker());\n+    }\n \n-        LOG.info(\"Constructed BK DistributedLogNamespace : clientId = {}, regionId = {}, federated = {}.\",\n-                new Object[] { clientId, regionId, bkdlConfig.isFederatedNamespace() });\n+    @Override\n+    public NamespaceDriver getNamespaceDriver() {\n+        return driver;\n     }\n \n     //\n@@ -468,26 +149,24 @@ public void createLog(String logName)\n             throws InvalidStreamNameException, IOException {\n         checkState();\n         validateName(logName);\n-        URI uri = FutureUtils.result(metadataStore.createLog(logName));\n-        FutureUtils.result(writerStreamMetadataStore.getLog(uri, logName, true, true));\n+        URI uri = FutureUtils.result(driver.getLogMetadataStore().createLog(logName));\n+        FutureUtils.result(driver.getLogStreamMetadataStore(WRITER).getLog(uri, logName, true, true));\n     }\n \n     @Override\n     public void deleteLog(String logName)\n             throws InvalidStreamNameException, LogNotFoundException, IOException {\n         checkState();\n         validateName(logName);\n-        Optional<URI> uri = FutureUtils.result(metadataStore.getLogLocation(logName));\n+        Optional<URI> uri = FutureUtils.result(driver.getLogMetadataStore().getLogLocation(logName));\n         if (!uri.isPresent()) {\n             throw new LogNotFoundException(\"Log \" + logName + \" isn't found.\");\n         }\n-        DistributedLogManager dlm = createDistributedLogManager(\n+        DistributedLogManager dlm = openLogInternal(\n                 uri.get(),\n                 logName,\n-                ClientSharingOption.SharedClients,\n                 Optional.<DistributedLogConfiguration>absent(),\n-                Optional.<DynamicDistributedLogConfiguration>absent(),\n-                Optional.<StatsLogger>absent());\n+                Optional.<DynamicDistributedLogConfiguration>absent());\n         dlm.delete();\n     }\n \n@@ -508,27 +187,26 @@ public DistributedLogManager openLog(String logName,\n             throws InvalidStreamNameException, IOException {\n         checkState();\n         validateName(logName);\n-        Optional<URI> uri = FutureUtils.result(metadataStore.getLogLocation(logName));\n+        Optional<URI> uri = FutureUtils.result(driver.getLogMetadataStore().getLogLocation(logName));\n         if (!uri.isPresent()) {\n             throw new LogNotFoundException(\"Log \" + logName + \" isn't found.\");\n         }\n-        return createDistributedLogManager(\n+        return openLogInternal(\n                 uri.get(),\n                 logName,\n-                ClientSharingOption.SharedClients,\n                 logConf,\n-                dynamicLogConf,\n-                perStreamStatsLogger);\n+                dynamicLogConf);\n     }\n \n     @Override\n     public boolean logExists(String logName)\n         throws IOException, IllegalArgumentException {\n         checkState();\n-        Optional<URI> uri = FutureUtils.result(metadataStore.getLogLocation(logName));\n+        Optional<URI> uri = FutureUtils.result(driver.getLogMetadataStore().getLogLocation(logName));\n         if (uri.isPresent()) {\n             try {\n-                FutureUtils.result(writerStreamMetadataStore.logExists(uri.get(), logName));\n+                FutureUtils.result(driver.getLogStreamMetadataStore(WRITER)\n+                        .logExists(uri.get(), logName));\n                 return true;\n             } catch (LogNotFoundException lnfe) {\n                 return false;\n@@ -541,240 +219,18 @@ public boolean logExists(String logName)\n     @Override\n     public Iterator<String> getLogs() throws IOException {\n         checkState();\n-        return FutureUtils.result(metadataStore.getLogs());\n+        return FutureUtils.result(driver.getLogMetadataStore().getLogs());\n     }\n \n     @Override\n     public void registerNamespaceListener(NamespaceListener listener) {\n-        metadataStore.registerNamespaceListener(listener);\n+        driver.getLogMetadataStore().registerNamespaceListener(listener);\n     }\n \n     @Override\n     public synchronized AccessControlManager createAccessControlManager() throws IOException {\n         checkState();\n-        if (null == accessControlManager) {\n-            String aclRootPath = bkdlConfig.getACLRootPath();\n-            // Build the access control manager\n-            if (aclRootPath == null) {\n-                accessControlManager = DefaultAccessControlManager.INSTANCE;\n-                LOG.info(\"Created default access control manager for {}\", namespace);\n-            } else {\n-                if (!isReservedStreamName(aclRootPath)) {\n-                    throw new IOException(\"Invalid Access Control List Root Path : \" + aclRootPath);\n-                }\n-                String zkRootPath = namespace.getPath() + \"/\" + aclRootPath;\n-                LOG.info(\"Creating zk based access control manager @ {} for {}\",\n-                        zkRootPath, namespace);\n-                accessControlManager = new ZKAccessControlManager(conf, sharedReaderZKCForDL,\n-                        zkRootPath, scheduler);\n-                LOG.info(\"Created zk based access control manager @ {} for {}\",\n-                        zkRootPath, namespace);\n-            }\n-        }\n-        return accessControlManager;\n-    }\n-\n-    //\n-    // Legacy methods\n-    //\n-\n-    static String validateAndGetFullLedgerAllocatorPoolPath(DistributedLogConfiguration conf, URI uri) throws IOException {\n-        String poolPath = conf.getLedgerAllocatorPoolPath();\n-        LOG.info(\"PoolPath is {}\", poolPath);\n-        if (null == poolPath || !poolPath.startsWith(\".\") || poolPath.endsWith(\"/\")) {\n-            LOG.error(\"Invalid ledger allocator pool path specified when enabling ledger allocator pool : {}\", poolPath);\n-            throw new IOException(\"Invalid ledger allocator pool path specified : \" + poolPath);\n-        }\n-        String poolName = conf.getLedgerAllocatorPoolName();\n-        if (null == poolName) {\n-            LOG.error(\"No ledger allocator pool name specified when enabling ledger allocator pool.\");\n-            throw new IOException(\"No ledger allocator name specified when enabling ledger allocator pool.\");\n-        }\n-        String rootPath = uri.getPath() + \"/\" + poolPath + \"/\" + poolName;\n-        try {\n-            PathUtils.validatePath(rootPath);\n-        } catch (IllegalArgumentException iae) {\n-            LOG.error(\"Invalid ledger allocator pool path specified when enabling ledger allocator pool : {}\", poolPath);\n-            throw new IOException(\"Invalid ledger allocator pool path specified : \" + poolPath);\n-        }\n-        return rootPath;\n-    }\n-\n-    public static ZooKeeperClientBuilder createDLZKClientBuilder(String zkcName,\n-                                                                 DistributedLogConfiguration conf,\n-                                                                 String zkServers,\n-                                                                 StatsLogger statsLogger) {\n-        RetryPolicy retryPolicy = null;\n-        if (conf.getZKNumRetries() > 0) {\n-            retryPolicy = new BoundExponentialBackoffRetryPolicy(\n-                conf.getZKRetryBackoffStartMillis(),\n-                conf.getZKRetryBackoffMaxMillis(), conf.getZKNumRetries());\n-        }\n-        ZooKeeperClientBuilder builder = ZooKeeperClientBuilder.newBuilder()\n-            .name(zkcName)\n-            .sessionTimeoutMs(conf.getZKSessionTimeoutMilliseconds())\n-            .retryThreadCount(conf.getZKClientNumberRetryThreads())\n-            .requestRateLimit(conf.getZKRequestRateLimit())\n-            .zkServers(zkServers)\n-            .retryPolicy(retryPolicy)\n-            .statsLogger(statsLogger)\n-            .zkAclId(conf.getZkAclId());\n-        LOG.info(\"Created shared zooKeeper client builder {}: zkServers = {}, numRetries = {}, sessionTimeout = {}, retryBackoff = {},\"\n-                + \" maxRetryBackoff = {}, zkAclId = {}.\", new Object[] { zkcName, zkServers, conf.getZKNumRetries(),\n-                conf.getZKSessionTimeoutMilliseconds(), conf.getZKRetryBackoffStartMillis(),\n-                conf.getZKRetryBackoffMaxMillis(), conf.getZkAclId() });\n-        return builder;\n-    }\n-\n-    private static ZooKeeperClientBuilder createBKZKClientBuilder(String zkcName,\n-                                                                  DistributedLogConfiguration conf,\n-                                                                  String zkServers,\n-                                                                  StatsLogger statsLogger) {\n-        RetryPolicy retryPolicy = new BoundExponentialBackoffRetryPolicy(\n-                    conf.getBKClientZKRetryBackoffStartMillis(),\n-                    conf.getBKClientZKRetryBackoffMaxMillis(),\n-                    conf.getBKClientZKNumRetries());\n-        ZooKeeperClientBuilder builder = ZooKeeperClientBuilder.newBuilder()\n-                .name(zkcName)\n-                .sessionTimeoutMs(conf.getBKClientZKSessionTimeoutMilliSeconds())\n-                .retryThreadCount(conf.getZKClientNumberRetryThreads())\n-                .requestRateLimit(conf.getBKClientZKRequestRateLimit())\n-                .zkServers(zkServers)\n-                .retryPolicy(retryPolicy)\n-                .statsLogger(statsLogger)\n-                .zkAclId(conf.getZkAclId());\n-        LOG.info(\"Created shared zooKeeper client builder {}: zkServers = {}, numRetries = {}, sessionTimeout = {}, retryBackoff = {},\"\n-                + \" maxRetryBackoff = {}, zkAclId = {}.\", new Object[] { zkcName, zkServers, conf.getBKClientZKNumRetries(),\n-                conf.getBKClientZKSessionTimeoutMilliSeconds(), conf.getBKClientZKRetryBackoffStartMillis(),\n-                conf.getBKClientZKRetryBackoffMaxMillis(), conf.getZkAclId() });\n-        return builder;\n-    }\n-\n-    private BookKeeperClientBuilder createBKCBuilder(String bkcName,\n-                                                     DistributedLogConfiguration conf,\n-                                                     String zkServers,\n-                                                     String ledgersPath,\n-                                                     Optional<FeatureProvider> featureProviderOptional) {\n-        BookKeeperClientBuilder builder = BookKeeperClientBuilder.newBuilder()\n-                .name(bkcName)\n-                .dlConfig(conf)\n-                .zkServers(zkServers)\n-                .ledgersPath(ledgersPath)\n-                .channelFactory(channelFactory)\n-                .requestTimer(requestTimer)\n-                .featureProvider(featureProviderOptional)\n-                .statsLogger(statsLogger);\n-        LOG.info(\"Created shared client builder {} : zkServers = {}, ledgersPath = {}, numIOThreads = {}\",\n-                new Object[] { bkcName, zkServers, ledgersPath, conf.getBKClientNumberIOThreads() });\n-        return builder;\n-    }\n-\n-    @VisibleForTesting\n-    public ZooKeeperClient getSharedWriterZKCForDL() {\n-        return sharedWriterZKCForDL;\n-    }\n-\n-    @VisibleForTesting\n-    public BookKeeperClient getReaderBKC() {\n-        return readerBKC;\n-    }\n-\n-    @VisibleForTesting\n-    public LogStreamMetadataStore getWriterStreamMetadataStore() {\n-        return writerStreamMetadataStore;\n-    }\n-\n-    @VisibleForTesting\n-    public LedgerAllocator getLedgerAllocator() {\n-        return allocator;\n-    }\n-\n-    /**\n-     * Run given <i>handler</i> by providing an available zookeeper client.\n-     *\n-     * @param handler\n-     *          Handler to process with provided zookeeper client.\n-     * @return result processed by handler.\n-     * @throws IOException\n-     */\n-    private <T> T withZooKeeperClient(ZooKeeperClientHandler<T> handler) throws IOException {\n-        checkState();\n-        return handler.handle(sharedWriterZKCForDL);\n-    }\n-\n-    /**\n-     * Create a DistributedLogManager for <i>nameOfLogStream</i>, with default shared clients.\n-     *\n-     * @param nameOfLogStream\n-     *          name of log stream\n-     * @return distributedlog manager\n-     * @throws com.twitter.distributedlog.exceptions.InvalidStreamNameException if stream name is invalid\n-     * @throws IOException\n-     */\n-    public DistributedLogManager createDistributedLogManagerWithSharedClients(String nameOfLogStream)\n-        throws InvalidStreamNameException, IOException {\n-        return createDistributedLogManager(nameOfLogStream, ClientSharingOption.SharedClients);\n-    }\n-\n-    /**\n-     * Create a DistributedLogManager for <i>nameOfLogStream</i>, with specified client sharing options.\n-     *\n-     * @param nameOfLogStream\n-     *          name of log stream.\n-     * @param clientSharingOption\n-     *          specifies if the ZK/BK clients are shared\n-     * @return distributedlog manager instance.\n-     * @throws com.twitter.distributedlog.exceptions.InvalidStreamNameException if stream name is invalid\n-     * @throws IOException\n-     */\n-    public DistributedLogManager createDistributedLogManager(\n-            String nameOfLogStream,\n-            ClientSharingOption clientSharingOption)\n-        throws InvalidStreamNameException, IOException {\n-        Optional<DistributedLogConfiguration> logConfiguration = Optional.absent();\n-        Optional<DynamicDistributedLogConfiguration> dynamicLogConfiguration = Optional.absent();\n-        return createDistributedLogManager(\n-                nameOfLogStream,\n-                clientSharingOption,\n-                logConfiguration,\n-                dynamicLogConfiguration);\n-    }\n-\n-    /**\n-     * Create a DistributedLogManager for <i>nameOfLogStream</i>, with specified client sharing options.\n-     * Override whitelisted stream-level configuration settings with settings found in\n-     * <i>logConfiguration</i>.\n-     *\n-     *\n-     * @param nameOfLogStream\n-     *          name of log stream.\n-     * @param clientSharingOption\n-     *          specifies if the ZK/BK clients are shared\n-     * @param logConfiguration\n-     *          stream configuration overrides.\n-     * @param dynamicLogConfiguration\n-     *          dynamic stream configuration overrides.\n-     * @return distributedlog manager instance.\n-     * @throws com.twitter.distributedlog.exceptions.InvalidStreamNameException if stream name is invalid\n-     * @throws IOException\n-     */\n-    public DistributedLogManager createDistributedLogManager(\n-            String nameOfLogStream,\n-            ClientSharingOption clientSharingOption,\n-            Optional<DistributedLogConfiguration> logConfiguration,\n-            Optional<DynamicDistributedLogConfiguration> dynamicLogConfiguration)\n-        throws InvalidStreamNameException, IOException {\n-        if (bkdlConfig.isFederatedNamespace()) {\n-            throw new UnsupportedOperationException(\"Use DistributedLogNamespace methods for federated namespace\");\n-        }\n-        return createDistributedLogManager(\n-                namespace,\n-                nameOfLogStream,\n-                clientSharingOption,\n-                logConfiguration,\n-                dynamicLogConfiguration,\n-                Optional.<StatsLogger>absent()\n-        );\n+        return driver.getAccessControlManager();\n     }\n \n     /**\n@@ -784,8 +240,6 @@ public DistributedLogManager createDistributedLogManager(\n      *          location to store the log\n      * @param nameOfLogStream\n      *          name of the log\n-     * @param clientSharingOption\n-     *          client sharing option\n      * @param logConfiguration\n      *          optional stream configuration\n      * @param dynamicLogConfiguration\n@@ -794,13 +248,11 @@ public DistributedLogManager createDistributedLogManager(\n      * @throws InvalidStreamNameException if the stream name is invalid\n      * @throws IOException\n      */\n-    protected DistributedLogManager createDistributedLogManager(\n+    protected DistributedLogManager openLogInternal(\n             URI uri,\n             String nameOfLogStream,\n-            ClientSharingOption clientSharingOption,\n             Optional<DistributedLogConfiguration> logConfiguration,\n-            Optional<DynamicDistributedLogConfiguration> dynamicLogConfiguration,\n-            Optional<StatsLogger> perStreamStatsLogger)\n+            Optional<DynamicDistributedLogConfiguration> dynamicLogConfiguration)\n         throws InvalidStreamNameException, IOException {\n         // Make sure the name is well formed\n         checkState();\n@@ -817,172 +269,34 @@ protected DistributedLogManager createDistributedLogManager(\n             dynConf = ConfUtils.getConstDynConf(mergedConfiguration);\n         }\n \n-        ZooKeeperClientBuilder writerZKCBuilderForDL = null;\n-        ZooKeeperClientBuilder readerZKCBuilderForDL = null;\n-        ZooKeeperClient writerZKCForBK = null;\n-        ZooKeeperClient readerZKCForBK = null;\n-        BookKeeperClientBuilder writerBKCBuilder = null;\n-        BookKeeperClientBuilder readerBKCBuilder = null;\n-\n-        switch(clientSharingOption) {\n-            case SharedClients:\n-                writerZKCBuilderForDL = sharedWriterZKCBuilderForDL;\n-                readerZKCBuilderForDL = sharedReaderZKCBuilderForDL;\n-                writerBKCBuilder = sharedWriterBKCBuilder;\n-                readerBKCBuilder = sharedReaderBKCBuilder;\n-                break;\n-            case SharedZKClientPerStreamBKClient:\n-                writerZKCBuilderForDL = sharedWriterZKCBuilderForDL;\n-                readerZKCBuilderForDL = sharedReaderZKCBuilderForDL;\n-                synchronized (this) {\n-                    if (null == this.sharedWriterZKCForBK) {\n-                        this.sharedWriterZKCBuilderForBK = createBKZKClientBuilder(\n-                            String.format(\"bkzk:%s:factory_writer_shared\", uri),\n-                            mergedConfiguration,\n-                            bkdlConfig.getBkZkServersForWriter(),\n-                            statsLogger.scope(\"bkzk_factory_writer_shared\"));\n-                        this.sharedWriterZKCForBK = this.sharedWriterZKCBuilderForBK.build();\n-                    }\n-                    if (null == this.sharedReaderZKCForBK) {\n-                        if (bkdlConfig.getBkZkServersForWriter().equals(bkdlConfig.getBkZkServersForReader())) {\n-                            this.sharedReaderZKCBuilderForBK = this.sharedWriterZKCBuilderForBK;\n-                        } else {\n-                            this.sharedReaderZKCBuilderForBK = createBKZKClientBuilder(\n-                                String.format(\"bkzk:%s:factory_reader_shared\", uri),\n-                                mergedConfiguration,\n-                                bkdlConfig.getBkZkServersForReader(),\n-                                statsLogger.scope(\"bkzk_factory_reader_shared\"));\n-                        }\n-                        this.sharedReaderZKCForBK = this.sharedReaderZKCBuilderForBK.build();\n-                    }\n-                    writerZKCForBK = this.sharedWriterZKCForBK;\n-                    readerZKCForBK = this.sharedReaderZKCForBK;\n-                }\n-                break;\n-        }\n-\n-        LedgerAllocator dlmLedgerAlloctor = null;\n-        if (ClientSharingOption.SharedClients == clientSharingOption) {\n-            dlmLedgerAlloctor = this.allocator;\n-        }\n-        // if there's a specified perStreamStatsLogger, user it, otherwise use the default one.\n-        StatsLogger perLogStatsLogger = perStreamStatsLogger.or(this.perLogStatsLogger);\n-\n         return new BKDistributedLogManager(\n                 nameOfLogStream,                    /* Log Name */\n                 mergedConfiguration,                /* Configuration */\n                 dynConf,                            /* Dynamic Configuration */\n-                uri,                                /* Namespace */\n-                writerZKCBuilderForDL,              /* ZKC Builder for DL Writer */\n-                readerZKCBuilderForDL,              /* ZKC Builder for DL Reader */\n-                writerZKCForBK,                     /* ZKC for BookKeeper for DL Writers */\n-                readerZKCForBK,                     /* ZKC for BookKeeper for DL Readers */\n-                writerBKCBuilder,                   /* BookKeeper Builder for DL Writers */\n-                readerBKCBuilder,                   /* BookKeeper Builder for DL Readers */\n-                writerStreamMetadataStore,         /* Log Segment Metadata Store for DL Writers */\n-                readerStreamMetadataStore,         /* Log Segment Metadata Store for DL Readers */\n+                uri,                                /* Namespace URI */\n+                driver,                             /* Namespace Driver */\n                 logSegmentMetadataCache,            /* Log Segment Metadata Cache */\n                 scheduler,                          /* DL scheduler */\n-                readAheadExecutor,                  /* Read Aheader Executor */\n-                channelFactory,                     /* Netty Channel Factory */\n-                requestTimer,                       /* Request Timer */\n                 clientId,                           /* Client Id */\n                 regionId,                           /* Region Id */\n-                dlmLedgerAlloctor,                  /* Ledger Allocator */\n                 writeLimiter,                       /* Write Limiter */\n                 featureProvider.scope(\"dl\"),        /* Feature Provider */\n+                failureInjector,                    /* Failure Injector */\n                 statsLogger,                        /* Stats Logger */\n-                perLogStatsLogger                   /* Per Log Stats Logger */\n+                perLogStatsLogger,                  /* Per Log Stats Logger */\n+                Optional.<AsyncCloseable>absent()   /* shared resources, we don't need to close any resources in dlm */\n         );\n     }\n \n-    public MetadataAccessor createMetadataAccessor(String nameOfMetadataNode)\n-            throws InvalidStreamNameException, IOException {\n-        if (bkdlConfig.isFederatedNamespace()) {\n-            throw new UnsupportedOperationException(\"Use DistributedLogNamespace methods for federated namespace\");\n-        }\n-        checkState();\n-        validateName(nameOfMetadataNode);\n-        return new ZKMetadataAccessor(nameOfMetadataNode, conf, namespace,\n-                sharedWriterZKCBuilderForDL, sharedReaderZKCBuilderForDL, statsLogger);\n-    }\n-\n-    public Collection<String> enumerateAllLogsInNamespace()\n-        throws IOException, IllegalArgumentException {\n-        if (bkdlConfig.isFederatedNamespace()) {\n-            throw new UnsupportedOperationException(\"Use DistributedLogNamespace methods for federated namespace\");\n-        }\n-        return Sets.newHashSet(getLogs());\n-    }\n-\n-    public Map<String, byte[]> enumerateLogsWithMetadataInNamespace()\n-        throws IOException, IllegalArgumentException {\n-        if (bkdlConfig.isFederatedNamespace()) {\n-            throw new UnsupportedOperationException(\"Use DistributedLogNamespace methods for federated namespace\");\n-        }\n-        return withZooKeeperClient(new ZooKeeperClientHandler<Map<String, byte[]>>() {\n-            @Override\n-            public Map<String, byte[]> handle(ZooKeeperClient zkc) throws IOException {\n-                return enumerateLogsWithMetadataInternal(zkc, conf, namespace);\n-            }\n-        });\n-    }\n-\n-    private static void validateInput(DistributedLogConfiguration conf, URI uri, String nameOfStream)\n-        throws IllegalArgumentException, InvalidStreamNameException {\n-        validateConfAndURI(conf, uri);\n-        validateName(nameOfStream);\n-    }\n-\n-    public static Map<String, byte[]> enumerateLogsWithMetadataInNamespace(final DistributedLogConfiguration conf, final URI uri)\n-        throws IOException, IllegalArgumentException {\n-        return withZooKeeperClient(new ZooKeeperClientHandler<Map<String, byte[]>>() {\n-            @Override\n-            public Map<String, byte[]> handle(ZooKeeperClient zkc) throws IOException {\n-                return enumerateLogsWithMetadataInternal(zkc, conf, uri);\n-            }\n-        }, conf, uri);\n-    }\n-\n-    private static Map<String, byte[]> enumerateLogsWithMetadataInternal(ZooKeeperClient zkc,\n-                                                                         DistributedLogConfiguration conf, URI uri)\n-        throws IOException, IllegalArgumentException {\n-        validateConfAndURI(conf, uri);\n-        String namespaceRootPath = uri.getPath();\n-        HashMap<String, byte[]> result = new HashMap<String, byte[]>();\n-        try {\n-            ZooKeeper zk = Utils.sync(zkc, namespaceRootPath);\n-            Stat currentStat = zk.exists(namespaceRootPath, false);\n-            if (currentStat == null) {\n-                return result;\n-            }\n-            List<String> children = zk.getChildren(namespaceRootPath, false);\n-            for(String child: children) {\n-                if (isReservedStreamName(child)) {\n-                    continue;\n-                }\n-                String zkPath = String.format(\"%s/%s\", namespaceRootPath, child);\n-                currentStat = zk.exists(zkPath, false);\n-                if (currentStat == null) {\n-                    result.put(child, new byte[0]);\n-                } else {\n-                    result.put(child, zk.getData(zkPath, false, currentStat));\n-                }\n-            }\n-        } catch (InterruptedException ie) {\n-            LOG.error(\"Interrupted while deleting \" + namespaceRootPath, ie);\n-            throw new IOException(\"Interrupted while reading \" + namespaceRootPath, ie);\n-        } catch (KeeperException ke) {\n-            LOG.error(\"Error reading\" + namespaceRootPath + \"entry in zookeeper\", ke);\n-            throw new IOException(\"Error reading\" + namespaceRootPath + \"entry in zookeeper\", ke);\n-        }\n-        return result;\n-    }\n-\n+    /**\n+     * Check the namespace state.\n+     *\n+     * @throws IOException\n+     */\n     private void checkState() throws IOException {\n         if (closed.get()) {\n-            LOG.error(\"BKDistributedLogNamespace {} is already closed\", namespace);\n-            throw new AlreadyClosedException(\"Namespace \" + namespace + \" is already closed\");\n+            LOG.error(\"BK namespace {} is already closed\", namespace);\n+            throw new AlreadyClosedException(\"BK namespace \" + namespace + \" is already closed\");\n         }\n     }\n \n@@ -991,58 +305,16 @@ private void checkState() throws IOException {\n      */\n     @Override\n     public void close() {\n-        ZooKeeperClient writerZKC;\n-        ZooKeeperClient readerZKC;\n-        AccessControlManager acm;\n-        if (closed.compareAndSet(false, true)) {\n-            writerZKC = sharedWriterZKCForBK;\n-            readerZKC = sharedReaderZKCForBK;\n-            acm = accessControlManager;\n-        } else {\n+        if (!closed.compareAndSet(false, true)) {\n             return;\n         }\n-        if (null != acm) {\n-            acm.close();\n-            LOG.info(\"Access Control Manager Stopped.\");\n-        }\n-\n-        // Close the allocator\n-        if (null != allocator) {\n-            Utils.closeQuietly(allocator);\n-            LOG.info(\"Ledger Allocator stopped.\");\n-        }\n-\n+        // shutdown the driver\n+        Utils.close(driver);\n+        // close the write limiter\n         this.writeLimiter.close();\n-\n-        // Shutdown log segment metadata stores\n-        Utils.close(writerStreamMetadataStore);\n-        Utils.close(readerStreamMetadataStore);\n-\n         // Shutdown the schedulers\n         SchedulerUtils.shutdownScheduler(scheduler, conf.getSchedulerShutdownTimeoutMs(),\n-            TimeUnit.MILLISECONDS);\n-        LOG.info(\"Executor Service Stopped.\");\n-        if (scheduler != readAheadExecutor) {\n-            SchedulerUtils.shutdownScheduler(readAheadExecutor, conf.getSchedulerShutdownTimeoutMs(),\n                 TimeUnit.MILLISECONDS);\n-            LOG.info(\"ReadAhead Executor Service Stopped.\");\n-        }\n-\n-        writerBKC.close();\n-        readerBKC.close();\n-        sharedWriterZKCForDL.close();\n-        sharedReaderZKCForDL.close();\n-\n-        // Close shared zookeeper clients for bk\n-        if (null != writerZKC) {\n-            writerZKC.close();\n-        }\n-        if (null != readerZKC) {\n-            readerZKC.close();\n-        }\n-        channelFactory.releaseExternalResources();\n-        LOG.info(\"Release external resources used by channel factory.\");\n-        requestTimer.stop();\n-        LOG.info(\"Stopped request timer\");\n+        LOG.info(\"Executor Service Stopped.\");\n     }\n }"},{"sha":"2486297a11ff06a4f7e7ae7a060fcf08288208a1","filename":"src/main/java/com/twitter/distributedlog/BKLogWriteHandler.java","status":"modified","additions":31,"deletions":27,"changes":58,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogWriteHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogWriteHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBKLogWriteHandler.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -20,7 +20,6 @@\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Stopwatch;\n import com.google.common.collect.Lists;\n-import com.twitter.distributedlog.bk.LedgerAllocator;\n import com.twitter.distributedlog.config.DynamicDistributedLogConfiguration;\n import com.twitter.distributedlog.exceptions.DLIllegalStateException;\n import com.twitter.distributedlog.exceptions.EndOfStreamException;\n@@ -29,8 +28,8 @@\n import com.twitter.distributedlog.exceptions.TransactionIdOutOfOrderException;\n import com.twitter.distributedlog.exceptions.UnexpectedException;\n import com.twitter.distributedlog.function.GetLastTxIdFunction;\n-import com.twitter.distributedlog.impl.logsegment.BKLogSegmentEntryWriter;\n import com.twitter.distributedlog.logsegment.LogSegmentEntryStore;\n+import com.twitter.distributedlog.logsegment.LogSegmentEntryWriter;\n import com.twitter.distributedlog.metadata.LogMetadataForWriter;\n import com.twitter.distributedlog.lock.DistributedLock;\n import com.twitter.distributedlog.logsegment.LogSegmentFilter;\n@@ -41,6 +40,7 @@\n import com.twitter.distributedlog.metadata.LogStreamMetadataStore;\n import com.twitter.distributedlog.metadata.MetadataUpdater;\n import com.twitter.distributedlog.metadata.LogSegmentMetadataStoreUpdater;\n+import com.twitter.distributedlog.util.Allocator;\n import com.twitter.distributedlog.util.DLUtils;\n import com.twitter.distributedlog.util.FailpointUtils;\n import com.twitter.distributedlog.util.FutureUtils;\n@@ -53,7 +53,6 @@\n import com.twitter.util.Future;\n import com.twitter.util.FutureEventListener;\n import com.twitter.util.Promise;\n-import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.stats.AlertStatsLogger;\n import org.apache.bookkeeper.stats.OpStatsLogger;\n@@ -88,9 +87,22 @@\n class BKLogWriteHandler extends BKLogHandler {\n     static final Logger LOG = LoggerFactory.getLogger(BKLogReadHandler.class);\n \n+    private static Transaction.OpListener<LogSegmentEntryWriter> NULL_OP_LISTENER =\n+            new Transaction.OpListener<LogSegmentEntryWriter>() {\n+        @Override\n+        public void onCommit(LogSegmentEntryWriter r) {\n+            // no-op\n+        }\n+\n+        @Override\n+        public void onAbort(Throwable t) {\n+            // no-op\n+        }\n+    };\n+\n     protected final LogMetadataForWriter logMetadataForWriter;\n+    protected final Allocator<LogSegmentEntryWriter, Object> logSegmentAllocator;\n     protected final DistributedLock lock;\n-    protected final LedgerAllocator ledgerAllocator;\n     protected final MaxTxId maxTxId;\n     protected final MaxLogSegmentSequenceNo maxLogSegmentSequenceNo;\n     protected final boolean validateLogSegmentSequenceNumber;\n@@ -154,7 +166,7 @@ public Future<Long> apply(List<LogSegmentMetadata> segmentList) {\n                       LogSegmentMetadataCache metadataCache,\n                       LogSegmentEntryStore entryStore,\n                       OrderedScheduler scheduler,\n-                      LedgerAllocator allocator,\n+                      Allocator<LogSegmentEntryWriter, Object> segmentAllocator,\n                       StatsLogger statsLogger,\n                       StatsLogger perLogStatsLogger,\n                       AlertStatsLogger alertStatsLogger,\n@@ -174,11 +186,11 @@ public Future<Long> apply(List<LogSegmentMetadata> segmentList) {\n                 alertStatsLogger,\n                 clientId);\n         this.logMetadataForWriter = logMetadata;\n+        this.logSegmentAllocator = segmentAllocator;\n         this.perLogStatsLogger = perLogStatsLogger;\n         this.writeLimiter = writeLimiter;\n         this.featureProvider = featureProvider;\n         this.dynConf = dynConf;\n-        this.ledgerAllocator = allocator;\n         this.lock = lock;\n         this.metadataUpdater = LogSegmentMetadataStoreUpdater.createMetadataUpdater(conf, metadataStore);\n \n@@ -523,7 +535,7 @@ protected void doStartLogSegment(final long txId,\n         }\n \n         try {\n-            ledgerAllocator.allocate();\n+            logSegmentAllocator.allocate();\n         } catch (IOException e) {\n             // failed to issue an allocation request\n             failStartLogSegment(promise, bestEffort, e);\n@@ -541,25 +553,16 @@ protected void doStartLogSegment(final long txId,\n             return;\n         }\n \n-        ledgerAllocator.tryObtain(txn, new Transaction.OpListener<LedgerHandle>() {\n-            @Override\n-            public void onCommit(LedgerHandle lh) {\n-                // no-op\n-            }\n-\n-            @Override\n-            public void onAbort(Throwable t) {\n-                // no-op\n-            }\n-        }).addEventListener(new FutureEventListener<LedgerHandle>() {\n+        logSegmentAllocator.tryObtain(txn, NULL_OP_LISTENER)\n+                .addEventListener(new FutureEventListener<LogSegmentEntryWriter>() {\n \n             @Override\n-            public void onSuccess(LedgerHandle lh) {\n+            public void onSuccess(LogSegmentEntryWriter entryWriter) {\n                 // try-obtain succeed\n                 createInprogressLogSegment(\n                         txn,\n                         txId,\n-                        lh,\n+                        entryWriter,\n                         bestEffort,\n                         promise);\n             }\n@@ -586,7 +589,7 @@ private void failStartLogSegment(Promise<BKLogSegmentWriter> promise,\n     // just leak from the allocation pool - hence cause \"No Ledger Allocator\"\n     private void createInprogressLogSegment(Transaction<Object> txn,\n                                             final long txId,\n-                                            final LedgerHandle lh,\n+                                            final LogSegmentEntryWriter entryWriter,\n                                             boolean bestEffort,\n                                             final Promise<BKLogSegmentWriter> promise) {\n         final long logSegmentSeqNo;\n@@ -601,13 +604,15 @@ private void createInprogressLogSegment(Transaction<Object> txn,\n             return;\n         }\n \n-        final String inprogressZnodePath = inprogressZNode(lh.getId(), txId, logSegmentSeqNo);\n+        final String inprogressZnodePath = inprogressZNode(\n+                entryWriter.getLogSegmentId(), txId, logSegmentSeqNo);\n         final LogSegmentMetadata l =\n             new LogSegmentMetadata.LogSegmentMetadataBuilder(inprogressZnodePath,\n-                conf.getDLLedgerMetadataLayoutVersion(), lh.getId(), txId)\n+                conf.getDLLedgerMetadataLayoutVersion(), entryWriter.getLogSegmentId(), txId)\n                     .setLogSegmentSequenceNo(logSegmentSeqNo)\n                     .setRegionId(regionId)\n-                    .setEnvelopeEntries(LogSegmentMetadata.supportsEnvelopedEntries(conf.getDLLedgerMetadataLayoutVersion()))\n+                    .setEnvelopeEntries(\n+                            LogSegmentMetadata.supportsEnvelopedEntries(conf.getDLLedgerMetadataLayoutVersion()))\n                     .build();\n \n         // Create an inprogress segment\n@@ -631,7 +636,7 @@ public void onSuccess(Void value) {\n                             l.getSegmentName(),\n                             conf,\n                             conf.getDLLedgerMetadataLayoutVersion(),\n-                            new BKLogSegmentEntryWriter(lh),\n+                            entryWriter,\n                             lock,\n                             txId,\n                             logSegmentSeqNo,\n@@ -1268,8 +1273,7 @@ public void onAbort(Throwable t) {\n     public Future<Void> asyncClose() {\n         return Utils.closeSequence(scheduler,\n                 lock,\n-                ledgerAllocator\n-        );\n+                logSegmentAllocator);\n     }\n \n     @Override"},{"sha":"8d3c4182fad66a5f1b2ebff279e7ca06069a1388","filename":"src/main/java/com/twitter/distributedlog/BookKeeperClient.java","status":"modified","additions":14,"deletions":8,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBookKeeperClient.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBookKeeperClient.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FBookKeeperClient.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -250,28 +250,34 @@ public void deleteComplete(int rc, Object ctx) {\n         return promise;\n     }\n \n-    public synchronized void close() {\n-        if (closed) {\n-            return;\n+    public void close() {\n+        BookKeeper bkcToClose;\n+        ZooKeeperClient zkcToClose;\n+        synchronized (this) {\n+            if (closed) {\n+                return;\n+            }\n+            closed = true;\n+            bkcToClose = bkc;\n+            zkcToClose = zkc;\n         }\n \n         LOG.info(\"BookKeeper Client closed {}\", name);\n-        if (null != bkc) {\n+        if (null != bkcToClose) {\n             try {\n-                bkc.close();\n+                bkcToClose.close();\n             } catch (InterruptedException e) {\n                 LOG.warn(\"Interrupted on closing bookkeeper client {} : \", name, e);\n                 Thread.currentThread().interrupt();\n             } catch (BKException e) {\n                 LOG.warn(\"Error on closing bookkeeper client {} : \", name, e);\n             }\n         }\n-        if (null != zkc) {\n+        if (null != zkcToClose) {\n             if (ownZK) {\n-                zkc.close();\n+                zkcToClose.close();\n             }\n         }\n-        closed = true;\n     }\n \n     public synchronized void checkClosedOrInError() throws AlreadyClosedException {"},{"sha":"6da4b8d80e293527032512952953df8e8dd5fd98","filename":"src/main/java/com/twitter/distributedlog/DistributedLogConfiguration.java","status":"modified","additions":7,"deletions":2,"changes":9,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConfiguration.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConfiguration.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogConfiguration.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -1301,6 +1301,7 @@ public DistributedLogConfiguration setNumWorkerThreads(int numWorkerThreads) {\n      * @return number of dedicated readahead worker threads.\n      * @see #getNumWorkerThreads()\n      */\n+    @Deprecated\n     public int getNumReadAheadWorkerThreads() {\n         return getInt(BKDL_NUM_READAHEAD_WORKER_THREADS, 0);\n     }\n@@ -1313,6 +1314,7 @@ public int getNumReadAheadWorkerThreads() {\n      * @return configuration\n      * @see #getNumReadAheadWorkerThreads()\n      */\n+    @Deprecated\n     public DistributedLogConfiguration setNumReadAheadWorkerThreads(int numWorkerThreads) {\n         setProperty(BKDL_NUM_READAHEAD_WORKER_THREADS, numWorkerThreads);\n         return this;\n@@ -3515,8 +3517,11 @@ public void validate() {\n         Preconditions.checkArgument(getBKClientReadTimeout() * 1000 >= getReadLACLongPollTimeout(),\n             \"Invalid timeout configuration: bkcReadTimeoutSeconds (\"+getBKClientReadTimeout()+\n                 \") should be longer than readLACLongPollTimeout (\"+getReadLACLongPollTimeout()+\")\");\n-        Preconditions.checkArgument(getReaderIdleWarnThresholdMillis() > 2 * getReadLACLongPollTimeout(),\n-            \"Invalid configuration: ReaderIdleWarnThreshold should be 2x larget than readLACLongPollTimeout\");\n+        long readerIdleWarnThresholdMs = getReaderIdleWarnThresholdMillis();\n+        if (readerIdleWarnThresholdMs > 0) { // NOTE: some test cases set the idle warn threshold to 0\n+            Preconditions.checkArgument(readerIdleWarnThresholdMs > 2 * getReadLACLongPollTimeout(),\n+                    \"Invalid configuration: ReaderIdleWarnThreshold should be 2x larget than readLACLongPollTimeout\");\n+        }\n     }\n \n "},{"sha":"34cfb65811ea6b7fc9fc6fe753209d284bcad4fc","filename":"src/main/java/com/twitter/distributedlog/DistributedLogManager.java","status":"modified","additions":18,"deletions":10,"changes":28,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogManager.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -18,9 +18,13 @@\n package com.twitter.distributedlog;\n \n import com.twitter.distributedlog.callback.LogSegmentListener;\n+import com.twitter.distributedlog.io.AsyncCloseable;\n+import com.twitter.distributedlog.namespace.NamespaceDriver;\n import com.twitter.distributedlog.subscription.SubscriptionStateStore;\n import com.twitter.distributedlog.subscription.SubscriptionsStore;\n import com.twitter.util.Future;\n+\n+import java.io.Closeable;\n import java.io.IOException;\n import java.util.List;\n \n@@ -31,7 +35,20 @@\n  * each conceptual place of storage corresponds to exactly one instance of\n  * this class, which is created when the EditLog is first opened.\n  */\n-public interface DistributedLogManager extends MetadataAccessor {\n+public interface DistributedLogManager extends AsyncCloseable, Closeable {\n+\n+    /**\n+     * Get the name of the stream managed by this log manager\n+     * @return streamName\n+     */\n+    public String getStreamName();\n+\n+    /**\n+     * Get the namespace driver used by this manager.\n+     *\n+     * @return the namespace driver\n+     */\n+    public NamespaceDriver getNamespaceDriver();\n \n     /**\n      * Get log segments.\n@@ -281,15 +298,6 @@ public LogRecordWithDLSN getLastLogRecord()\n      */\n     public void purgeLogsOlderThan(long minTxIdToKeep) throws IOException;\n \n-    /**\n-     * Get the subscription state storage provided by the distributed log manager\n-     *\n-     * @param subscriberId - Application specific Id associated with the subscriber\n-     * @return Subscription state store\n-     */\n-    @Deprecated\n-    public SubscriptionStateStore getSubscriptionStateStore(String subscriberId);\n-\n     /**\n      * Get the subscriptions store provided by the distributedlog manager.\n      *"},{"sha":"4caeeba104c88a265e699d7259e350da06977628","filename":"src/main/java/com/twitter/distributedlog/DistributedLogManagerFactory.java","status":"removed","additions":0,"deletions":202,"changes":202,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/a83b233a79300c0bf1b3dcac0a24fef628ad48f8/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogManagerFactory.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/a83b233a79300c0bf1b3dcac0a24fef628ad48f8/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogManagerFactory.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDistributedLogManagerFactory.java?ref=a83b233a79300c0bf1b3dcac0a24fef628ad48f8","patch":"@@ -1,202 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.twitter.distributedlog;\n-\n-import com.google.common.base.Optional;\n-import com.twitter.distributedlog.acl.AccessControlManager;\n-import com.twitter.distributedlog.callback.NamespaceListener;\n-import com.twitter.distributedlog.config.DynamicDistributedLogConfiguration;\n-import com.twitter.distributedlog.exceptions.InvalidStreamNameException;\n-import com.twitter.distributedlog.namespace.DistributedLogNamespace;\n-import org.apache.bookkeeper.stats.NullStatsLogger;\n-import org.apache.bookkeeper.stats.StatsLogger;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.io.IOException;\n-import java.net.URI;\n-import java.util.Collection;\n-import java.util.Map;\n-\n-/**\n- * This is the legacy way to access bookkeeper based distributedlog namespace.\n- * Use {@link DistributedLogNamespace} to manage logs instead if you could.\n- */\n-@Deprecated\n-public class DistributedLogManagerFactory {\n-    static final Logger LOG = LoggerFactory.getLogger(DistributedLogManagerFactory.class);\n-\n-    public static enum ClientSharingOption {\n-        PerStreamClients,\n-        SharedZKClientPerStreamBKClient,\n-        SharedClients\n-    }\n-\n-    private final BKDistributedLogNamespace namespace;\n-\n-    public DistributedLogManagerFactory(DistributedLogConfiguration conf, URI uri)\n-            throws IOException, IllegalArgumentException {\n-        this(conf, uri, NullStatsLogger.INSTANCE);\n-    }\n-\n-    public DistributedLogManagerFactory(DistributedLogConfiguration conf, URI uri,\n-                                        StatsLogger statsLogger)\n-            throws IOException, IllegalArgumentException {\n-        this(conf,\n-             uri,\n-             statsLogger,\n-             DistributedLogConstants.UNKNOWN_CLIENT_ID,\n-             DistributedLogConstants.LOCAL_REGION_ID);\n-    }\n-\n-    public DistributedLogManagerFactory(DistributedLogConfiguration conf,\n-                                        URI uri,\n-                                        StatsLogger statsLogger,\n-                                        String clientId,\n-                                        int regionId)\n-            throws IOException, IllegalArgumentException {\n-        this.namespace = BKDistributedLogNamespace.newBuilder()\n-                .conf(conf)\n-                .uri(uri)\n-                .statsLogger(statsLogger)\n-                .clientId(clientId)\n-                .regionId(regionId)\n-                .build();\n-    }\n-\n-    public DistributedLogNamespace getNamespace() {\n-        return namespace;\n-    }\n-\n-    public void registerNamespaceListener(NamespaceListener listener) {\n-        namespace.registerNamespaceListener(listener);\n-    }\n-\n-    /**\n-     * Create a DistributedLogManager for <i>nameOfLogStream</i>, with default shared clients.\n-     *\n-     * @param nameOfLogStream\n-     *          name of log stream\n-     * @return distributedlog manager\n-     * @throws com.twitter.distributedlog.exceptions.InvalidStreamNameException if stream name is invalid\n-     * @throws IOException\n-     */\n-    public DistributedLogManager createDistributedLogManagerWithSharedClients(String nameOfLogStream)\n-        throws InvalidStreamNameException, IOException {\n-        return createDistributedLogManager(nameOfLogStream, ClientSharingOption.SharedClients);\n-    }\n-\n-    /**\n-     * Create a DistributedLogManager for <i>nameOfLogStream</i>, with specified client sharing options.\n-     *\n-     * @param nameOfLogStream\n-     *          name of log stream.\n-     * @param clientSharingOption\n-     *          specifies if the ZK/BK clients are shared\n-     * @return distributedlog manager instance.\n-     * @throws com.twitter.distributedlog.exceptions.InvalidStreamNameException if stream name is invalid\n-     * @throws IOException\n-     */\n-    public DistributedLogManager createDistributedLogManager(\n-            String nameOfLogStream,\n-            ClientSharingOption clientSharingOption)\n-        throws InvalidStreamNameException, IOException {\n-        Optional<DistributedLogConfiguration> streamConfiguration = Optional.absent();\n-        Optional<DynamicDistributedLogConfiguration> dynamicStreamConfiguration = Optional.absent();\n-        return createDistributedLogManager(nameOfLogStream,\n-            clientSharingOption,\n-            streamConfiguration,\n-            dynamicStreamConfiguration);\n-    }\n-\n-    /**\n-     * Create a DistributedLogManager for <i>nameOfLogStream</i>, with specified client sharing options.\n-     * This method allows the caller to override global configuration options by supplying stream\n-     * configuration overrides. Stream config overrides come in two flavors, static and dynamic. Static\n-     * config never changes, and DynamicDistributedLogConfiguration is a) reloaded periodically and\n-     * b) safe to access from any context.\n-     *\n-     * @param nameOfLogStream\n-     *          name of log stream.\n-     * @param clientSharingOption\n-     *          specifies if the ZK/BK clients are shared\n-     * @param streamConfiguration\n-     *          stream configuration overrides.\n-     * @param dynamicStreamConfiguration\n-     *          dynamic stream configuration overrides.\n-     * @return distributedlog manager instance.\n-     * @throws com.twitter.distributedlog.exceptions.InvalidStreamNameException if stream name is invalid\n-     * @throws IOException\n-     */\n-    public DistributedLogManager createDistributedLogManager(\n-            String nameOfLogStream,\n-            ClientSharingOption clientSharingOption,\n-            Optional<DistributedLogConfiguration> streamConfiguration,\n-            Optional<DynamicDistributedLogConfiguration> dynamicStreamConfiguration)\n-        throws InvalidStreamNameException, IOException {\n-        return namespace.createDistributedLogManager(\n-            nameOfLogStream,\n-            clientSharingOption,\n-            streamConfiguration,\n-            dynamicStreamConfiguration);\n-    }\n-\n-    public MetadataAccessor createMetadataAccessor(String nameOfMetadataNode)\n-            throws InvalidStreamNameException, IOException {\n-        return namespace.createMetadataAccessor(nameOfMetadataNode);\n-    }\n-\n-    public synchronized AccessControlManager createAccessControlManager() throws IOException {\n-        return namespace.createAccessControlManager();\n-    }\n-\n-    public boolean checkIfLogExists(String nameOfLogStream)\n-        throws IOException, IllegalArgumentException {\n-        return namespace.logExists(nameOfLogStream);\n-    }\n-\n-    public Collection<String> enumerateAllLogsInNamespace()\n-        throws IOException, IllegalArgumentException {\n-        return namespace.enumerateAllLogsInNamespace();\n-    }\n-\n-    public Map<String, byte[]> enumerateLogsWithMetadataInNamespace()\n-        throws IOException, IllegalArgumentException {\n-        return namespace.enumerateLogsWithMetadataInNamespace();\n-    }\n-\n-    /**\n-     * This method is to initialize the metadata for a unpartitioned stream with name <i>streamName</i>.\n-     *\n-     * TODO: after 0.2 is upgraded to 0.3, remove this.\n-     *\n-     * @param streamName\n-     *          stream name.\n-     * @throws IOException\n-     */\n-    public void createUnpartitionedStream(final String streamName) throws IOException {\n-        namespace.createLog(streamName);\n-    }\n-\n-    /**\n-     * Close the distributed log manager factory, freeing any resources it may hold.\n-     */\n-    public void close() {\n-        namespace.close();\n-    }\n-}"},{"sha":"f4a1e41d59340d487c32f28739acccefdb33e975","filename":"src/main/java/com/twitter/distributedlog/LocalDLMEmulator.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FLocalDLMEmulator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FLocalDLMEmulator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FLocalDLMEmulator.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -18,7 +18,7 @@\n package com.twitter.distributedlog;\n \n import com.google.common.base.Optional;\n-import com.twitter.distributedlog.metadata.BKDLConfig;\n+import com.twitter.distributedlog.impl.metadata.BKDLConfig;\n import com.twitter.distributedlog.metadata.DLMetadata;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.proto.BookieServer;"},{"sha":"19f4497c0fd48cf7ea9d8fb204b374b5ed57c052","filename":"src/main/java/com/twitter/distributedlog/ReadAheadEntryReader.java","status":"modified","additions":17,"deletions":1,"changes":18,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FReadAheadEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FReadAheadEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FReadAheadEntryReader.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -65,6 +65,7 @@\n public class ReadAheadEntryReader implements\n         AsyncCloseable,\n         LogSegmentListener,\n+        LogSegmentEntryReader.StateChangeListener,\n         FutureEventListener<List<Entry.Reader>> {\n \n     private static final Logger logger = LoggerFactory.getLogger(ReadAheadEntryReader.class);\n@@ -169,6 +170,9 @@ public BoxedUnit apply(LogSegmentEntryReader reader) {\n         @Override\n         synchronized public void onSuccess(LogSegmentEntryReader reader) {\n             this.reader = reader;\n+            if (reader.getSegment().isInProgress()) {\n+                reader.registerListener(ReadAheadEntryReader.this);\n+            }\n         }\n \n         @Override\n@@ -271,7 +275,7 @@ public BoxedUnit apply() {\n     // State of the reader\n     //\n \n-    private boolean isInitialized;\n+    private boolean isInitialized = false;\n     private boolean readAheadPaused = false;\n     private Promise<Void> closePromise = null;\n     // segment readers\n@@ -549,10 +553,22 @@ void checkCatchingUpStatus(LogSegmentEntryReader reader) {\n         }\n     }\n \n+    void markCaughtup() {\n+        if (isCatchingUp) {\n+            isCatchingUp = false;\n+            logger.info(\"ReadAhead for {} is caught up\", readHandler.getFullyQualifiedName());\n+        }\n+    }\n+\n     public boolean isReadAheadCaughtUp() {\n         return !isCatchingUp;\n     }\n \n+    @Override\n+    public void onCaughtupOnInprogress() {\n+        markCaughtup();\n+    }\n+\n     //\n     // ReadAhead State Machine\n     //"},{"sha":"15f180586885aaabea8ad9cffc49ad1e4ae3f481","filename":"src/main/java/com/twitter/distributedlog/ZooKeeperClientBuilder.java","status":"modified","additions":2,"deletions":2,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FZooKeeperClientBuilder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FZooKeeperClientBuilder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FZooKeeperClientBuilder.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -20,7 +20,7 @@\n import com.google.common.base.Preconditions;\n import com.twitter.distributedlog.ZooKeeperClient.Credentials;\n import com.twitter.distributedlog.ZooKeeperClient.DigestCredentials;\n-import com.twitter.distributedlog.util.DLUtils;\n+import com.twitter.distributedlog.impl.BKNamespaceDriver;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n import org.apache.bookkeeper.zookeeper.RetryPolicy;\n@@ -139,7 +139,7 @@ public synchronized ZooKeeperClientBuilder zkServers(String zkServers) {\n      * @return builder.\n      */\n     public synchronized ZooKeeperClientBuilder uri(URI uri) {\n-        this.zkServers = DLUtils.getZKServersFromDLUri(uri);\n+        this.zkServers = BKNamespaceDriver.getZKServersFromDLUri(uri);\n         return this;\n     }\n "},{"sha":"0512907fb9daf57c0323e7dbc6cf3b3c056d3efe","filename":"src/main/java/com/twitter/distributedlog/admin/DistributedLogAdmin.java","status":"modified","additions":39,"deletions":46,"changes":85,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fadmin%2FDistributedLogAdmin.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fadmin%2FDistributedLogAdmin.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fadmin%2FDistributedLogAdmin.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -18,28 +18,27 @@\n package com.twitter.distributedlog.admin;\n \n import com.google.common.base.Preconditions;\n-import com.twitter.distributedlog.BookKeeperClient;\n-import com.twitter.distributedlog.DistributedLogConfiguration;\n+import com.google.common.collect.Lists;\n import com.twitter.distributedlog.DistributedLogManager;\n import com.twitter.distributedlog.LogRecordWithDLSN;\n import com.twitter.distributedlog.LogSegmentMetadata;\n import com.twitter.distributedlog.ReadUtils;\n import com.twitter.distributedlog.ZooKeeperClient;\n import com.twitter.distributedlog.ZooKeeperClientBuilder;\n-import com.twitter.distributedlog.acl.ZKAccessControl;\n+import com.twitter.distributedlog.impl.BKNamespaceDriver;\n+import com.twitter.distributedlog.impl.acl.ZKAccessControl;\n import com.twitter.distributedlog.exceptions.DLIllegalStateException;\n import com.twitter.distributedlog.impl.federated.FederatedZKLogMetadataStore;\n-import com.twitter.distributedlog.impl.logsegment.BKLogSegmentEntryStore;\n-import com.twitter.distributedlog.injector.AsyncFailureInjector;\n import com.twitter.distributedlog.logsegment.LogSegmentEntryStore;\n-import com.twitter.distributedlog.metadata.BKDLConfig;\n+import com.twitter.distributedlog.impl.metadata.BKDLConfig;\n import com.twitter.distributedlog.metadata.DLMetadata;\n import com.twitter.distributedlog.metadata.DryrunLogSegmentMetadataStoreUpdater;\n import com.twitter.distributedlog.metadata.MetadataUpdater;\n import com.twitter.distributedlog.metadata.LogSegmentMetadataStoreUpdater;\n+import com.twitter.distributedlog.namespace.DistributedLogNamespace;\n+import com.twitter.distributedlog.namespace.NamespaceDriver;\n import com.twitter.distributedlog.thrift.AccessControlEntry;\n import com.twitter.distributedlog.tools.DistributedLogTool;\n-import com.twitter.distributedlog.util.DLUtils;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.OrderedScheduler;\n import com.twitter.distributedlog.util.SchedulerUtils;\n@@ -61,6 +60,7 @@\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Comparator;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.SortedSet;\n@@ -76,16 +76,15 @@\n /**\n  * Admin Tool for DistributedLog.\n  */\n-@SuppressWarnings(\"deprecation\")\n public class DistributedLogAdmin extends DistributedLogTool {\n \n     static final Logger LOG = LoggerFactory.getLogger(DistributedLogAdmin.class);\n \n     /**\n      * Fix inprogress segment with lower ledger sequence number.\n      *\n-     * @param factory\n-     *          dlm factory.\n+     * @param namespace\n+     *          dl namespace\n      * @param metadataUpdater\n      *          metadata updater.\n      * @param streamName\n@@ -96,12 +95,12 @@ public class DistributedLogAdmin extends DistributedLogTool {\n      *          is confirmation needed before executing actual action.\n      * @throws IOException\n      */\n-    public static void fixInprogressSegmentWithLowerSequenceNumber(final com.twitter.distributedlog.DistributedLogManagerFactory factory,\n+    public static void fixInprogressSegmentWithLowerSequenceNumber(final DistributedLogNamespace namespace,\n                                                                    final MetadataUpdater metadataUpdater,\n                                                                    final String streamName,\n                                                                    final boolean verbose,\n                                                                    final boolean interactive) throws IOException {\n-        DistributedLogManager dlm = factory.createDistributedLogManagerWithSharedClients(streamName);\n+        DistributedLogManager dlm = namespace.openLog(streamName);\n         try {\n             List<LogSegmentMetadata> segments = dlm.getLogSegments();\n             if (verbose) {\n@@ -194,37 +193,37 @@ public String toString() {\n     }\n \n     public static void checkAndRepairDLNamespace(final URI uri,\n-                                                 final com.twitter.distributedlog.DistributedLogManagerFactory factory,\n+                                                 final DistributedLogNamespace namespace,\n                                                  final MetadataUpdater metadataUpdater,\n                                                  final OrderedScheduler scheduler,\n-                                                 final BookKeeperClient bkc,\n-                                                 final String digestpw,\n                                                  final boolean verbose,\n                                                  final boolean interactive) throws IOException {\n-        checkAndRepairDLNamespace(uri, factory, metadataUpdater, scheduler, bkc, digestpw, verbose, interactive, 1);\n+        checkAndRepairDLNamespace(uri, namespace, metadataUpdater, scheduler, verbose, interactive, 1);\n     }\n \n     public static void checkAndRepairDLNamespace(final URI uri,\n-                                                 final com.twitter.distributedlog.DistributedLogManagerFactory factory,\n+                                                 final DistributedLogNamespace namespace,\n                                                  final MetadataUpdater metadataUpdater,\n                                                  final OrderedScheduler scheduler,\n-                                                 final BookKeeperClient bkc,\n-                                                 final String digestpw,\n                                                  final boolean verbose,\n                                                  final boolean interactive,\n                                                  final int concurrency) throws IOException {\n         Preconditions.checkArgument(concurrency > 0, \"Invalid concurrency \" + concurrency + \" found.\");\n         // 0. getting streams under a given uri.\n-        Collection<String> streams = factory.enumerateAllLogsInNamespace();\n+        Iterator<String> streamsIter = namespace.getLogs();\n+        List<String> streams = Lists.newArrayList();\n+        while (streamsIter.hasNext()) {\n+            streams.add(streamsIter.next());\n+        }\n         if (verbose) {\n-            System.out.println(\"- 0. checking \" + streams.size() + \" streams under \" + uri);\n+            System.out.println(\"- 0. checking streams under \" + uri);\n         }\n         if (streams.size() == 0) {\n             System.out.println(\"+ 0. nothing to check. quit.\");\n             return;\n         }\n         Map<String, StreamCandidate> streamCandidates =\n-                checkStreams(factory, streams, scheduler, bkc, digestpw, concurrency);\n+                checkStreams(namespace, streams, scheduler, concurrency);\n         if (verbose) {\n             System.out.println(\"+ 0. \" + streamCandidates.size() + \" corrupted streams found.\");\n         }\n@@ -248,11 +247,9 @@ public static void checkAndRepairDLNamespace(final URI uri,\n     }\n \n     private static Map<String, StreamCandidate> checkStreams(\n-            final com.twitter.distributedlog.DistributedLogManagerFactory factory,\n+            final DistributedLogNamespace namespace,\n             final Collection<String> streams,\n             final OrderedScheduler scheduler,\n-            final BookKeeperClient bkc,\n-            final String digestpw,\n             final int concurrency) throws IOException {\n         final LinkedBlockingQueue<String> streamQueue =\n                 new LinkedBlockingQueue<String>();\n@@ -275,7 +272,7 @@ public void run() {\n                     StreamCandidate candidate;\n                     try {\n                         LOG.info(\"Checking stream {}.\", stream);\n-                        candidate = checkStream(factory, stream, scheduler, bkc, digestpw);\n+                        candidate = checkStream(namespace, stream, scheduler);\n                         LOG.info(\"Checked stream {} - {}.\", stream, candidate);\n                     } catch (IOException e) {\n                         LOG.error(\"Error on checking stream {} : \", stream, e);\n@@ -316,12 +313,10 @@ public void run() {\n     }\n \n     private static StreamCandidate checkStream(\n-            final com.twitter.distributedlog.DistributedLogManagerFactory factory,\n+            final DistributedLogNamespace namespace,\n             final String streamName,\n-            final OrderedScheduler scheduler,\n-            final BookKeeperClient bkc,\n-            String digestpw) throws IOException {\n-        DistributedLogManager dlm = factory.createDistributedLogManagerWithSharedClients(streamName);\n+            final OrderedScheduler scheduler) throws IOException {\n+        DistributedLogManager dlm = namespace.openLog(streamName);\n         try {\n             List<LogSegmentMetadata> segments = dlm.getLogSegments();\n             if (segments.isEmpty()) {\n@@ -330,7 +325,7 @@ private static StreamCandidate checkStream(\n             List<Future<LogSegmentCandidate>> futures =\n                     new ArrayList<Future<LogSegmentCandidate>>(segments.size());\n             for (LogSegmentMetadata segment : segments) {\n-                futures.add(checkLogSegment(streamName, segment, scheduler, bkc, digestpw));\n+                futures.add(checkLogSegment(namespace, streamName, segment, scheduler));\n             }\n             List<LogSegmentCandidate> segmentCandidates;\n             try {\n@@ -354,21 +349,16 @@ private static StreamCandidate checkStream(\n     }\n \n     private static Future<LogSegmentCandidate> checkLogSegment(\n+            final DistributedLogNamespace namespace,\n             final String streamName,\n             final LogSegmentMetadata metadata,\n-            final OrderedScheduler scheduler,\n-            final BookKeeperClient bkc,\n-            final String digestpw) {\n+            final OrderedScheduler scheduler) {\n         if (metadata.isInProgress()) {\n             return Future.value(null);\n         }\n \n-        final LogSegmentEntryStore entryStore = new BKLogSegmentEntryStore(\n-                new DistributedLogConfiguration().setBKDigestPW(digestpw),\n-                bkc,\n-                scheduler,\n-                NullStatsLogger.INSTANCE,\n-                AsyncFailureInjector.NULL);\n+        final LogSegmentEntryStore entryStore = namespace.getNamespaceDriver()\n+                .getLogSegmentEntryStore(NamespaceDriver.Role.READER);\n         return ReadUtils.asyncReadLastRecord(\n                 streamName,\n                 metadata,\n@@ -432,6 +422,8 @@ private static boolean repairStream(MetadataUpdater metadataUpdater,\n \n     /**\n      * Unbind the bookkeeper environment for a given distributedlog uri.\n+     *\n+     * TODO: move unbind operation to namespace driver\n      */\n     class UnbindCommand extends OptsCommand {\n \n@@ -491,6 +483,8 @@ protected int runCmd(CommandLine cmdline) throws Exception {\n \n     /**\n      * Bind Command to bind bookkeeper environment for a given distributed uri.\n+     *\n+     * TODO: move bind to namespace driver\n      */\n     class BindCommand extends OptsCommand {\n \n@@ -559,7 +553,7 @@ protected int runCmd(CommandLine cmdline) throws Exception {\n             if (cmdline.hasOption(\"dlzw\")) {\n                 dlZkServersForWriter = cmdline.getOptionValue(\"dlzw\");\n             } else {\n-                dlZkServersForWriter = DLUtils.getZKServersFromDLUri(uri);\n+                dlZkServersForWriter = BKNamespaceDriver.getZKServersFromDLUri(uri);\n             }\n             if (cmdline.hasOption(\"dlzr\")) {\n                 dlZkServersForReader = cmdline.getOptionValue(\"dlzr\");\n@@ -689,7 +683,7 @@ protected int runCmd() throws Exception {\n                 return -1;\n             }\n             for (String stream : streams) {\n-                fixInprogressSegmentWithLowerSequenceNumber(getFactory(), metadataUpdater, stream, verbose, !getForce());\n+                fixInprogressSegmentWithLowerSequenceNumber(getNamespace(), metadataUpdater, stream, verbose, !getForce());\n             }\n             return 0;\n         }\n@@ -739,10 +733,9 @@ protected int runCmd() throws Exception {\n                     .corePoolSize(Runtime.getRuntime().availableProcessors())\n                     .build();\n             ExecutorService executorService = Executors.newCachedThreadPool();\n-            BookKeeperClient bkc = getBookKeeperClient();\n             try {\n-                checkAndRepairDLNamespace(getUri(), getFactory(), metadataUpdater, scheduler,\n-                                          bkc, getConf().getBKDigestPW(), verbose, !getForce(), concurrency);\n+                checkAndRepairDLNamespace(getUri(), getNamespace(), metadataUpdater, scheduler,\n+                                          verbose, !getForce(), concurrency);\n             } finally {\n                 SchedulerUtils.shutdownScheduler(executorService, 5, TimeUnit.MINUTES);\n             }"},{"sha":"a081606702e400258eb0594b64fa0de1e0a0e73a","filename":"src/main/java/com/twitter/distributedlog/auditor/DLAuditor.java","status":"modified","additions":56,"deletions":47,"changes":103,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fauditor%2FDLAuditor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fauditor%2FDLAuditor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fauditor%2FDLAuditor.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -21,18 +21,20 @@\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.util.concurrent.SettableFuture;\n-import com.twitter.distributedlog.BKDistributedLogNamespace;\n import com.twitter.distributedlog.BookKeeperClient;\n import com.twitter.distributedlog.BookKeeperClientBuilder;\n import com.twitter.distributedlog.DistributedLogConfiguration;\n import com.twitter.distributedlog.DistributedLogManager;\n import com.twitter.distributedlog.LogSegmentMetadata;\n+import com.twitter.distributedlog.impl.BKNamespaceDriver;\n import com.twitter.distributedlog.namespace.DistributedLogNamespace;\n import com.twitter.distributedlog.ZooKeeperClient;\n import com.twitter.distributedlog.ZooKeeperClientBuilder;\n import com.twitter.distributedlog.exceptions.DLInterruptedException;\n import com.twitter.distributedlog.exceptions.ZKException;\n-import com.twitter.distributedlog.metadata.BKDLConfig;\n+import com.twitter.distributedlog.impl.metadata.BKDLConfig;\n+import com.twitter.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import com.twitter.distributedlog.namespace.NamespaceDriver;\n import com.twitter.distributedlog.util.DLUtils;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n@@ -52,8 +54,8 @@\n import java.io.IOException;\n import java.net.URI;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n@@ -72,7 +74,6 @@\n /**\n  * DL Auditor will audit DL namespace, e.g. find leaked ledger, report disk usage by streams.\n  */\n-@SuppressWarnings(\"deprecation\")\n public class DLAuditor {\n \n     private static final Logger logger = LoggerFactory.getLogger(DLAuditor.class);\n@@ -83,23 +84,23 @@ public DLAuditor(DistributedLogConfiguration conf) {\n         this.conf = conf;\n     }\n \n-    private ZooKeeperClient getZooKeeperClient(com.twitter.distributedlog.DistributedLogManagerFactory factory) {\n-        DistributedLogNamespace namespace = factory.getNamespace();\n-        assert(namespace instanceof BKDistributedLogNamespace);\n-        return ((BKDistributedLogNamespace) namespace).getSharedWriterZKCForDL();\n+    private ZooKeeperClient getZooKeeperClient(DistributedLogNamespace namespace) {\n+        NamespaceDriver driver = namespace.getNamespaceDriver();\n+        assert(driver instanceof BKNamespaceDriver);\n+        return ((BKNamespaceDriver) driver).getWriterZKC();\n     }\n \n-    private BookKeeperClient getBookKeeperClient(com.twitter.distributedlog.DistributedLogManagerFactory factory) {\n-        DistributedLogNamespace namespace = factory.getNamespace();\n-        assert(namespace instanceof BKDistributedLogNamespace);\n-        return ((BKDistributedLogNamespace) namespace).getReaderBKC();\n+    private BookKeeperClient getBookKeeperClient(DistributedLogNamespace namespace) {\n+        NamespaceDriver driver = namespace.getNamespaceDriver();\n+        assert(driver instanceof BKNamespaceDriver);\n+        return ((BKNamespaceDriver) driver).getReaderBKC();\n     }\n \n     private String validateAndGetZKServers(List<URI> uris) {\n         URI firstURI = uris.get(0);\n-        String zkServers = DLUtils.getZKServersFromDLUri(firstURI);\n+        String zkServers = BKNamespaceDriver.getZKServersFromDLUri(firstURI);\n         for (URI uri : uris) {\n-            if (!zkServers.equalsIgnoreCase(DLUtils.getZKServersFromDLUri(uri))) {\n+            if (!zkServers.equalsIgnoreCase(BKNamespaceDriver.getZKServersFromDLUri(uri))) {\n                 throw new IllegalArgumentException(\"Uris don't belong to same zookeeper cluster\");\n             }\n         }\n@@ -224,19 +225,23 @@ public void processResult(int rc, String path, Object ctx) {\n     private Set<Long> collectLedgersFromDL(List<URI> uris, List<List<String>> allocationPaths)\n             throws IOException {\n         final Set<Long> ledgers = new TreeSet<Long>();\n-        List<com.twitter.distributedlog.DistributedLogManagerFactory> factories =\n-                new ArrayList<com.twitter.distributedlog.DistributedLogManagerFactory>(uris.size());\n+        List<DistributedLogNamespace> namespaces =\n+                new ArrayList<DistributedLogNamespace>(uris.size());\n         try {\n             for (URI uri : uris) {\n-                factories.add(new com.twitter.distributedlog.DistributedLogManagerFactory(conf, uri));\n+                namespaces.add(\n+                        DistributedLogNamespaceBuilder.newBuilder()\n+                                .conf(conf)\n+                                .uri(uri)\n+                                .build());\n             }\n             final CountDownLatch doneLatch = new CountDownLatch(uris.size());\n             final AtomicInteger numFailures = new AtomicInteger(0);\n             ExecutorService executor = Executors.newFixedThreadPool(uris.size());\n             try {\n                 int i = 0;\n-                for (com.twitter.distributedlog.DistributedLogManagerFactory factory : factories) {\n-                    final com.twitter.distributedlog.DistributedLogManagerFactory dlFactory = factory;\n+                for (final DistributedLogNamespace namespace : namespaces) {\n+                    final DistributedLogNamespace dlNamespace = namespace;\n                     final URI uri = uris.get(i);\n                     final List<String> aps = allocationPaths.get(i);\n                     i++;\n@@ -245,12 +250,12 @@ private Set<Long> collectLedgersFromDL(List<URI> uris, List<List<String>> alloca\n                         public void run() {\n                             try {\n                                 logger.info(\"Collecting ledgers from {} : {}\", uri, aps);\n-                                collectLedgersFromAllocator(uri, dlFactory, aps, ledgers);\n+                                collectLedgersFromAllocator(uri, namespace, aps, ledgers);\n                                 synchronized (ledgers) {\n                                     logger.info(\"Collected {} ledgers from allocators for {} : {} \",\n                                             new Object[]{ledgers.size(), uri, ledgers});\n                                 }\n-                                collectLedgersFromDL(uri, dlFactory, ledgers);\n+                                collectLedgersFromDL(uri, namespace, ledgers);\n                             } catch (IOException e) {\n                                 numFailures.incrementAndGet();\n                                 logger.info(\"Error to collect ledgers from DL : \", e);\n@@ -273,23 +278,23 @@ public void run() {\n                 executor.shutdown();\n             }\n         } finally {\n-            for (com.twitter.distributedlog.DistributedLogManagerFactory factory : factories) {\n-                factory.close();\n+            for (DistributedLogNamespace namespace : namespaces) {\n+                namespace.close();\n             }\n         }\n         return ledgers;\n     }\n \n     private void collectLedgersFromAllocator(final URI uri,\n-                                             final com.twitter.distributedlog.DistributedLogManagerFactory factory,\n+                                             final DistributedLogNamespace namespace,\n                                              final List<String> allocationPaths,\n                                              final Set<Long> ledgers) throws IOException {\n         final LinkedBlockingQueue<String> poolQueue =\n                 new LinkedBlockingQueue<String>();\n         for (String allocationPath : allocationPaths) {\n             String rootPath = uri.getPath() + \"/\" + allocationPath;\n             try {\n-                List<String> pools = getZooKeeperClient(factory).get().getChildren(rootPath, false);\n+                List<String> pools = getZooKeeperClient(namespace).get().getChildren(rootPath, false);\n                 for (String pool : pools) {\n                     poolQueue.add(rootPath + \"/\" + pool);\n                 }\n@@ -318,11 +323,11 @@ public void execute(String poolPath) throws IOException {\n \n             private void collectLedgersFromPool(String poolPath)\n                     throws InterruptedException, ZooKeeperClient.ZooKeeperConnectionException, KeeperException {\n-                List<String> allocators = getZooKeeperClient(factory).get()\n+                List<String> allocators = getZooKeeperClient(namespace).get()\n                                         .getChildren(poolPath, false);\n                 for (String allocator : allocators) {\n                     String allocatorPath = poolPath + \"/\" + allocator;\n-                    byte[] data = getZooKeeperClient(factory).get().getData(allocatorPath, false, new Stat());\n+                    byte[] data = getZooKeeperClient(namespace).get().getData(allocatorPath, false, new Stat());\n                     if (null != data && data.length > 0) {\n                         try {\n                             long ledgerId = DLUtils.bytes2LogSegmentId(data);\n@@ -341,30 +346,31 @@ private void collectLedgersFromPool(String poolPath)\n     }\n \n     private void collectLedgersFromDL(final URI uri,\n-                                      final com.twitter.distributedlog.DistributedLogManagerFactory factory,\n+                                      final DistributedLogNamespace namespace,\n                                       final Set<Long> ledgers) throws IOException {\n         logger.info(\"Enumerating {} to collect streams.\", uri);\n-        Collection<String> streams = factory.enumerateAllLogsInNamespace();\n+        Iterator<String> streams = namespace.getLogs();\n         final LinkedBlockingQueue<String> streamQueue = new LinkedBlockingQueue<String>();\n-        streamQueue.addAll(streams);\n+        while (streams.hasNext()) {\n+            streamQueue.add(streams.next());\n+        }\n \n         logger.info(\"Collected {} streams from uri {} : {}\",\n-                    new Object[] { streams.size(), uri, streams });\n+                    new Object[] { streamQueue.size(), uri, streams });\n \n         executeAction(streamQueue, 10, new Action<String>() {\n             @Override\n             public void execute(String stream) throws IOException {\n-                collectLedgersFromStream(factory, stream, ledgers);\n+                collectLedgersFromStream(namespace, stream, ledgers);\n             }\n         });\n     }\n \n-    private List<Long> collectLedgersFromStream(com.twitter.distributedlog.DistributedLogManagerFactory factory,\n+    private List<Long> collectLedgersFromStream(DistributedLogNamespace namespace,\n                                                 String stream,\n                                                 Set<Long> ledgers)\n             throws IOException {\n-        DistributedLogManager dlm = factory.createDistributedLogManager(stream,\n-                com.twitter.distributedlog.DistributedLogManagerFactory.ClientSharingOption.SharedClients);\n+        DistributedLogManager dlm = namespace.openLog(stream);\n         try {\n             List<LogSegmentMetadata> segments = dlm.getLogSegments();\n             List<Long> sLedgers = new ArrayList<Long>();\n@@ -388,21 +394,25 @@ private List<Long> collectLedgersFromStream(com.twitter.distributedlog.Distribut\n      */\n     public Map<String, Long> calculateStreamSpaceUsage(final URI uri) throws IOException {\n         logger.info(\"Collecting stream space usage for {}.\", uri);\n-        com.twitter.distributedlog.DistributedLogManagerFactory factory =\n-                new com.twitter.distributedlog.DistributedLogManagerFactory(conf, uri);\n+        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+                .conf(conf)\n+                .uri(uri)\n+                .build();\n         try {\n-            return calculateStreamSpaceUsage(uri, factory);\n+            return calculateStreamSpaceUsage(uri, namespace);\n         } finally {\n-            factory.close();\n+            namespace.close();\n         }\n     }\n \n     private Map<String, Long> calculateStreamSpaceUsage(\n-            final URI uri, final com.twitter.distributedlog.DistributedLogManagerFactory factory)\n+            final URI uri, final DistributedLogNamespace namespace)\n         throws IOException {\n-        Collection<String> streams = factory.enumerateAllLogsInNamespace();\n+        Iterator<String> streams = namespace.getLogs();\n         final LinkedBlockingQueue<String> streamQueue = new LinkedBlockingQueue<String>();\n-        streamQueue.addAll(streams);\n+        while (streams.hasNext()) {\n+            streamQueue.add(streams.next());\n+        }\n \n         final Map<String, Long> streamSpaceUsageMap =\n                 new ConcurrentSkipListMap<String, Long>();\n@@ -412,7 +422,7 @@ private Map<String, Long> calculateStreamSpaceUsage(\n             @Override\n             public void execute(String stream) throws IOException {\n                 streamSpaceUsageMap.put(stream,\n-                        calculateStreamSpaceUsage(factory, stream));\n+                        calculateStreamSpaceUsage(namespace, stream));\n                 if (numStreamsCollected.incrementAndGet() % 1000 == 0) {\n                     logger.info(\"Calculated {} streams from uri {}.\", numStreamsCollected.get(), uri);\n                 }\n@@ -422,16 +432,15 @@ public void execute(String stream) throws IOException {\n         return streamSpaceUsageMap;\n     }\n \n-    private long calculateStreamSpaceUsage(final com.twitter.distributedlog.DistributedLogManagerFactory factory,\n+    private long calculateStreamSpaceUsage(final DistributedLogNamespace namespace,\n                                            final String stream) throws IOException {\n-        DistributedLogManager dlm = factory.createDistributedLogManager(stream,\n-                com.twitter.distributedlog.DistributedLogManagerFactory.ClientSharingOption.SharedClients);\n+        DistributedLogManager dlm = namespace.openLog(stream);\n         long totalBytes = 0;\n         try {\n             List<LogSegmentMetadata> segments = dlm.getLogSegments();\n             for (LogSegmentMetadata segment : segments) {\n                 try {\n-                    LedgerHandle lh = getBookKeeperClient(factory).get().openLedgerNoRecovery(segment.getLogSegmentId(),\n+                    LedgerHandle lh = getBookKeeperClient(namespace).get().openLedgerNoRecovery(segment.getLogSegmentId(),\n                             BookKeeper.DigestType.CRC32, conf.getBKDigestPW().getBytes(UTF_8));\n                     totalBytes += lh.getLength();\n                     lh.close();"},{"sha":"dd78a4e7e4edfe57f80dab11085cf39028e033d3","filename":"src/main/java/com/twitter/distributedlog/impl/BKDLUtils.java","status":"removed","additions":0,"deletions":100,"changes":100,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/a83b233a79300c0bf1b3dcac0a24fef628ad48f8/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FBKDLUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/a83b233a79300c0bf1b3dcac0a24fef628ad48f8/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FBKDLUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FBKDLUtils.java?ref=a83b233a79300c0bf1b3dcac0a24fef628ad48f8","patch":"@@ -1,100 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.twitter.distributedlog.impl;\n-\n-import com.twitter.distributedlog.DistributedLogConfiguration;\n-import com.twitter.distributedlog.exceptions.InvalidStreamNameException;\n-\n-import java.net.URI;\n-\n-/**\n- * Utils for bookkeeper based distributedlog implementation\n- */\n-public class BKDLUtils {\n-\n-    /**\n-     * Is it a reserved stream name in bkdl namespace?\n-     *\n-     * @param name\n-     *          stream name\n-     * @return true if it is reserved name, otherwise false.\n-     */\n-    public static boolean isReservedStreamName(String name) {\n-        return name.startsWith(\".\");\n-    }\n-\n-    /**\n-     * Validate the configuration and uri.\n-     *\n-     * @param conf\n-     *          distributedlog configuration\n-     * @param uri\n-     *          distributedlog uri\n-     * @throws IllegalArgumentException\n-     */\n-    public static void validateConfAndURI(DistributedLogConfiguration conf, URI uri)\n-        throws IllegalArgumentException {\n-        if (null == conf) {\n-            throw new IllegalArgumentException(\"Incorrect Configuration\");\n-        } else {\n-            conf.validate();\n-        }\n-        if ((null == uri) || (null == uri.getAuthority()) || (null == uri.getPath())) {\n-            throw new IllegalArgumentException(\"Incorrect ZK URI\");\n-        }\n-    }\n-\n-    /**\n-     * Validate the stream name.\n-     *\n-     * @param nameOfStream\n-     *          name of stream\n-     * @throws InvalidStreamNameException\n-     */\n-    public static void validateName(String nameOfStream)\n-            throws InvalidStreamNameException {\n-        String reason = null;\n-        char chars[] = nameOfStream.toCharArray();\n-        char c;\n-        // validate the stream to see if meet zookeeper path's requirement\n-        for (int i = 0; i < chars.length; i++) {\n-            c = chars[i];\n-\n-            if (c == 0) {\n-                reason = \"null character not allowed @\" + i;\n-                break;\n-            } else if (c == '/') {\n-                reason = \"'/' not allowed @\" + i;\n-                break;\n-            } else if (c > '\\u0000' && c < '\\u001f'\n-                    || c > '\\u007f' && c < '\\u009F'\n-                    || c > '\\ud800' && c < '\\uf8ff'\n-                    || c > '\\ufff0' && c < '\\uffff') {\n-                reason = \"invalid charater @\" + i;\n-                break;\n-            }\n-        }\n-        if (null != reason) {\n-            throw new InvalidStreamNameException(nameOfStream, reason);\n-        }\n-        if (isReservedStreamName(nameOfStream)) {\n-            throw new InvalidStreamNameException(nameOfStream,\n-                    \"Stream Name is reserved\");\n-        }\n-    }\n-}"},{"sha":"5921233a86cd0ca503a69b5d3a6542c68a892734","filename":"src/main/java/com/twitter/distributedlog/impl/BKNamespaceDriver.java","status":"added","additions":631,"deletions":0,"changes":631,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FBKNamespaceDriver.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FBKNamespaceDriver.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FBKNamespaceDriver.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -0,0 +1,631 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.twitter.distributedlog.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Optional;\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import com.twitter.distributedlog.BookKeeperClient;\n+import com.twitter.distributedlog.BookKeeperClientBuilder;\n+import com.twitter.distributedlog.DistributedLogConfiguration;\n+import com.twitter.distributedlog.DistributedLogConstants;\n+import com.twitter.distributedlog.MetadataAccessor;\n+import com.twitter.distributedlog.ZooKeeperClient;\n+import com.twitter.distributedlog.ZooKeeperClientBuilder;\n+import com.twitter.distributedlog.acl.AccessControlManager;\n+import com.twitter.distributedlog.acl.DefaultAccessControlManager;\n+import com.twitter.distributedlog.impl.acl.ZKAccessControlManager;\n+import com.twitter.distributedlog.bk.LedgerAllocator;\n+import com.twitter.distributedlog.bk.LedgerAllocatorUtils;\n+import com.twitter.distributedlog.config.DynamicDistributedLogConfiguration;\n+import com.twitter.distributedlog.exceptions.AlreadyClosedException;\n+import com.twitter.distributedlog.exceptions.InvalidStreamNameException;\n+import com.twitter.distributedlog.impl.federated.FederatedZKLogMetadataStore;\n+import com.twitter.distributedlog.impl.logsegment.BKLogSegmentEntryStore;\n+import com.twitter.distributedlog.impl.metadata.ZKLogStreamMetadataStore;\n+import com.twitter.distributedlog.impl.subscription.ZKSubscriptionsStore;\n+import com.twitter.distributedlog.injector.AsyncFailureInjector;\n+import com.twitter.distributedlog.logsegment.LogSegmentEntryStore;\n+import com.twitter.distributedlog.impl.metadata.BKDLConfig;\n+import com.twitter.distributedlog.metadata.LogMetadataForReader;\n+import com.twitter.distributedlog.metadata.LogMetadataStore;\n+import com.twitter.distributedlog.metadata.LogStreamMetadataStore;\n+import com.twitter.distributedlog.namespace.NamespaceDriver;\n+import com.twitter.distributedlog.namespace.NamespaceDriverManager;\n+import com.twitter.distributedlog.subscription.SubscriptionsStore;\n+import com.twitter.distributedlog.util.OrderedScheduler;\n+import com.twitter.distributedlog.util.Utils;\n+import org.apache.bookkeeper.feature.FeatureProvider;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+import org.apache.bookkeeper.zookeeper.BoundExponentialBackoffRetryPolicy;\n+import org.apache.bookkeeper.zookeeper.RetryPolicy;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.common.PathUtils;\n+import org.apache.zookeeper.data.Stat;\n+import org.jboss.netty.channel.socket.ClientSocketChannelFactory;\n+import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;\n+import org.jboss.netty.util.HashedWheelTimer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static com.twitter.distributedlog.util.DLUtils.isReservedStreamName;\n+import static com.twitter.distributedlog.util.DLUtils.validateName;\n+\n+/**\n+ * Manager for ZooKeeper/BookKeeper based namespace\n+ */\n+public class BKNamespaceDriver implements NamespaceDriver {\n+\n+    private static Logger LOG = LoggerFactory.getLogger(BKNamespaceDriver.class);\n+\n+    // register itself\n+    static {\n+        NamespaceDriverManager.registerDriver(DistributedLogConstants.BACKEND_BK, BKNamespaceDriver.class);\n+    }\n+\n+    /**\n+     * Extract zk servers fro dl <i>namespace</i>.\n+     *\n+     * @param uri dl namespace\n+     * @return zk servers\n+     */\n+    public static String getZKServersFromDLUri(URI uri) {\n+        return uri.getAuthority().replace(\";\", \",\");\n+    }\n+\n+    // resources (passed from initialization)\n+    private DistributedLogConfiguration conf;\n+    private DynamicDistributedLogConfiguration dynConf;\n+    private URI namespace;\n+    private OrderedScheduler scheduler;\n+    private FeatureProvider featureProvider;\n+    private AsyncFailureInjector failureInjector;\n+    private StatsLogger statsLogger;\n+    private StatsLogger perLogStatsLogger;\n+    private String clientId;\n+    private int regionId;\n+\n+    //\n+    // resources (created internally and initialized at #initialize())\n+    //\n+\n+    // namespace binding\n+    private BKDLConfig bkdlConfig;\n+\n+    // zookeeper clients\n+    // NOTE: The actual zookeeper client is initialized lazily when it is referenced by\n+    //       {@link com.twitter.distributedlog.ZooKeeperClient#get()}. So it is safe to\n+    //       keep builders and their client wrappers here, as they will be used when\n+    //       instantiating readers or writers.\n+    private ZooKeeperClientBuilder sharedWriterZKCBuilder;\n+    private ZooKeeperClient writerZKC;\n+    private ZooKeeperClientBuilder sharedReaderZKCBuilder;\n+    private ZooKeeperClient readerZKC;\n+    // NOTE: The actual bookkeeper client is initialized lazily when it is referenced by\n+    //       {@link com.twitter.distributedlog.BookKeeperClient#get()}. So it is safe to\n+    //       keep builders and their client wrappers here, as they will be used when\n+    //       instantiating readers or writers.\n+    private ClientSocketChannelFactory channelFactory;\n+    private HashedWheelTimer requestTimer;\n+    private BookKeeperClientBuilder sharedWriterBKCBuilder;\n+    private BookKeeperClient writerBKC;\n+    private BookKeeperClientBuilder sharedReaderBKCBuilder;\n+    private BookKeeperClient readerBKC;\n+\n+    // log stream metadata store\n+    private LogMetadataStore metadataStore;\n+    private LogStreamMetadataStore writerStreamMetadataStore;\n+    private LogStreamMetadataStore readerStreamMetadataStore;\n+\n+    //\n+    // resources (lazily initialized)\n+    //\n+\n+    // ledger allocator\n+    private LedgerAllocator allocator;\n+\n+    // log segment entry stores\n+    private LogSegmentEntryStore writerEntryStore;\n+    private LogSegmentEntryStore readerEntryStore;\n+\n+    // access control manager\n+    private AccessControlManager accessControlManager;\n+\n+    //\n+    // states\n+    //\n+    protected boolean initialized = false;\n+    protected AtomicBoolean closed = new AtomicBoolean(false);\n+\n+    /**\n+     * Public constructor for reflection.\n+     */\n+    public BKNamespaceDriver() {\n+    }\n+\n+    @Override\n+    public synchronized NamespaceDriver initialize(DistributedLogConfiguration conf,\n+                                                   DynamicDistributedLogConfiguration dynConf,\n+                                                   URI namespace,\n+                                                   OrderedScheduler scheduler,\n+                                                   FeatureProvider featureProvider,\n+                                                   AsyncFailureInjector failureInjector,\n+                                                   StatsLogger statsLogger,\n+                                                   StatsLogger perLogStatsLogger,\n+                                                   String clientId,\n+                                                   int regionId) throws IOException {\n+        if (initialized) {\n+            return this;\n+        }\n+        // validate the namespace\n+        if ((null == namespace) || (null == namespace.getAuthority()) || (null == namespace.getPath())) {\n+            throw new IOException(\"Incorrect distributedlog namespace : \" + namespace);\n+        }\n+\n+        // initialize the resources\n+        this.conf = conf;\n+        this.dynConf = dynConf;\n+        this.namespace = namespace;\n+        this.scheduler = scheduler;\n+        this.featureProvider = featureProvider;\n+        this.failureInjector = failureInjector;\n+        this.statsLogger = statsLogger;\n+        this.perLogStatsLogger = perLogStatsLogger;\n+        this.clientId = clientId;\n+        this.regionId = regionId;\n+\n+        // initialize the zookeeper clients\n+        initializeZooKeeperClients();\n+\n+        // initialize the bookkeeper clients\n+        initializeBookKeeperClients();\n+\n+        // propagate bkdlConfig to configuration\n+        BKDLConfig.propagateConfiguration(bkdlConfig, conf);\n+\n+        // initialize the log metadata & stream metadata store\n+        initializeLogStreamMetadataStores();\n+\n+        // initialize other resources\n+        initializeOtherResources();\n+\n+        initialized = true;\n+\n+        LOG.info(\"Initialized BK namespace driver: clientId = {}, regionId = {}, federated = {}.\",\n+                new Object[]{clientId, regionId, bkdlConfig.isFederatedNamespace()});\n+        return this;\n+    }\n+\n+    private void initializeZooKeeperClients() throws IOException {\n+        // Build the namespace zookeeper client\n+        this.sharedWriterZKCBuilder = createZKClientBuilder(\n+                String.format(\"dlzk:%s:factory_writer_shared\", namespace),\n+                conf,\n+                getZKServersFromDLUri(namespace),\n+                statsLogger.scope(\"dlzk_factory_writer_shared\"));\n+        this.writerZKC = sharedWriterZKCBuilder.build();\n+\n+        // Resolve namespace binding\n+        this.bkdlConfig = BKDLConfig.resolveDLConfig(writerZKC, namespace);\n+\n+        // Build zookeeper client for readers\n+        if (bkdlConfig.getDlZkServersForWriter().equals(bkdlConfig.getDlZkServersForReader())) {\n+            this.sharedReaderZKCBuilder = this.sharedWriterZKCBuilder;\n+        } else {\n+            this.sharedReaderZKCBuilder = createZKClientBuilder(\n+                    String.format(\"dlzk:%s:factory_reader_shared\", namespace),\n+                    conf,\n+                    bkdlConfig.getDlZkServersForReader(),\n+                    statsLogger.scope(\"dlzk_factory_reader_shared\"));\n+        }\n+        this.readerZKC = this.sharedReaderZKCBuilder.build();\n+    }\n+\n+    private synchronized BKDLConfig getBkdlConfig() {\n+        return bkdlConfig;\n+    }\n+\n+    private void initializeBookKeeperClients() throws IOException {\n+        this.channelFactory = new NioClientSocketChannelFactory(\n+                Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat(\"DL-netty-boss-%d\").build()),\n+                Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat(\"DL-netty-worker-%d\").build()),\n+                conf.getBKClientNumberIOThreads());\n+        this.requestTimer = new HashedWheelTimer(\n+                new ThreadFactoryBuilder().setNameFormat(\"DLFactoryTimer-%d\").build(),\n+                conf.getTimeoutTimerTickDurationMs(), TimeUnit.MILLISECONDS,\n+                conf.getTimeoutTimerNumTicks());\n+        // Build bookkeeper client for writers\n+        this.sharedWriterBKCBuilder = createBKCBuilder(\n+                String.format(\"bk:%s:factory_writer_shared\", namespace),\n+                conf,\n+                bkdlConfig.getBkZkServersForWriter(),\n+                bkdlConfig.getBkLedgersPath(),\n+                channelFactory,\n+                requestTimer,\n+                Optional.of(featureProvider.scope(\"bkc\")),\n+                statsLogger);\n+        this.writerBKC = this.sharedWriterBKCBuilder.build();\n+\n+        // Build bookkeeper client for readers\n+        if (bkdlConfig.getBkZkServersForWriter().equals(bkdlConfig.getBkZkServersForReader())) {\n+            this.sharedReaderBKCBuilder = this.sharedWriterBKCBuilder;\n+        } else {\n+            this.sharedReaderBKCBuilder = createBKCBuilder(\n+                    String.format(\"bk:%s:factory_reader_shared\", namespace),\n+                    conf,\n+                    bkdlConfig.getBkZkServersForReader(),\n+                    bkdlConfig.getBkLedgersPath(),\n+                    channelFactory,\n+                    requestTimer,\n+                    Optional.<FeatureProvider>absent(),\n+                    statsLogger);\n+        }\n+        this.readerBKC = this.sharedReaderBKCBuilder.build();\n+    }\n+\n+    private void initializeLogStreamMetadataStores() throws IOException {\n+        // log metadata store\n+        if (bkdlConfig.isFederatedNamespace() || conf.isFederatedNamespaceEnabled()) {\n+            this.metadataStore = new FederatedZKLogMetadataStore(conf, namespace, readerZKC, scheduler);\n+        } else {\n+            this.metadataStore = new ZKLogMetadataStore(conf, namespace, readerZKC, scheduler);\n+        }\n+\n+        // create log stream metadata store\n+        this.writerStreamMetadataStore =\n+                new ZKLogStreamMetadataStore(\n+                        clientId,\n+                        conf,\n+                        writerZKC,\n+                        scheduler,\n+                        statsLogger);\n+        this.readerStreamMetadataStore =\n+                new ZKLogStreamMetadataStore(\n+                        clientId,\n+                        conf,\n+                        readerZKC,\n+                        scheduler,\n+                        statsLogger);\n+    }\n+\n+    @VisibleForTesting\n+    public static String validateAndGetFullLedgerAllocatorPoolPath(DistributedLogConfiguration conf, URI uri) throws IOException {\n+        String poolPath = conf.getLedgerAllocatorPoolPath();\n+        LOG.info(\"PoolPath is {}\", poolPath);\n+        if (null == poolPath || !poolPath.startsWith(\".\") || poolPath.endsWith(\"/\")) {\n+            LOG.error(\"Invalid ledger allocator pool path specified when enabling ledger allocator pool : {}\", poolPath);\n+            throw new IOException(\"Invalid ledger allocator pool path specified : \" + poolPath);\n+        }\n+        String poolName = conf.getLedgerAllocatorPoolName();\n+        if (null == poolName) {\n+            LOG.error(\"No ledger allocator pool name specified when enabling ledger allocator pool.\");\n+            throw new IOException(\"No ledger allocator name specified when enabling ledger allocator pool.\");\n+        }\n+        String rootPath = uri.getPath() + \"/\" + poolPath + \"/\" + poolName;\n+        try {\n+            PathUtils.validatePath(rootPath);\n+        } catch (IllegalArgumentException iae) {\n+            LOG.error(\"Invalid ledger allocator pool path specified when enabling ledger allocator pool : {}\", poolPath);\n+            throw new IOException(\"Invalid ledger allocator pool path specified : \" + poolPath);\n+        }\n+        return rootPath;\n+    }\n+\n+    private void initializeOtherResources() throws IOException {\n+        // Ledger allocator\n+        if (conf.getEnableLedgerAllocatorPool()) {\n+            String allocatorPoolPath = validateAndGetFullLedgerAllocatorPoolPath(conf, namespace);\n+            allocator = LedgerAllocatorUtils.createLedgerAllocatorPool(\n+                    allocatorPoolPath,\n+                    conf.getLedgerAllocatorPoolCoreSize(),\n+                    conf,\n+                    writerZKC,\n+                    writerBKC,\n+                    scheduler);\n+            if (null != allocator) {\n+                allocator.start();\n+            }\n+            LOG.info(\"Created ledger allocator pool under {} with size {}.\", allocatorPoolPath, conf.getLedgerAllocatorPoolCoreSize());\n+        } else {\n+            allocator = null;\n+        }\n+\n+    }\n+\n+    private void checkState() throws IOException {\n+        if (closed.get()) {\n+            LOG.error(\"BK namespace driver {} is already closed\", namespace);\n+            throw new AlreadyClosedException(\"BK namespace driver \" + namespace + \" is already closed\");\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (!closed.compareAndSet(false, true)) {\n+            return;\n+        }\n+        doClose();\n+    }\n+\n+    private void doClose() {\n+        if (null != accessControlManager) {\n+            accessControlManager.close();\n+            LOG.info(\"Access Control Manager Stopped.\");\n+        }\n+\n+        // Close the allocator\n+        if (null != allocator) {\n+            Utils.closeQuietly(allocator);\n+            LOG.info(\"Ledger Allocator stopped.\");\n+        }\n+\n+        // Shutdown log segment metadata stores\n+        Utils.close(writerStreamMetadataStore);\n+        Utils.close(readerStreamMetadataStore);\n+\n+        writerBKC.close();\n+        readerBKC.close();\n+        writerZKC.close();\n+        readerZKC.close();\n+        // release bookkeeper resources\n+        channelFactory.releaseExternalResources();\n+        LOG.info(\"Release external resources used by channel factory.\");\n+        requestTimer.stop();\n+        LOG.info(\"Stopped request timer\");\n+    }\n+\n+    @Override\n+    public URI getUri() {\n+        return namespace;\n+    }\n+\n+    @Override\n+    public String getScheme() {\n+        return DistributedLogConstants.BACKEND_BK;\n+    }\n+\n+    @Override\n+    public LogMetadataStore getLogMetadataStore() {\n+        return metadataStore;\n+    }\n+\n+    @Override\n+    public LogStreamMetadataStore getLogStreamMetadataStore(Role role) {\n+        if (Role.WRITER == role) {\n+            return writerStreamMetadataStore;\n+        } else {\n+            return readerStreamMetadataStore;\n+        }\n+    }\n+\n+    @Override\n+    public LogSegmentEntryStore getLogSegmentEntryStore(Role role) {\n+        if (Role.WRITER == role) {\n+            return getWriterEntryStore();\n+        } else {\n+            return getReaderEntryStore();\n+        }\n+    }\n+\n+    private LogSegmentEntryStore getWriterEntryStore() {\n+        if (null == writerEntryStore) {\n+            writerEntryStore = new BKLogSegmentEntryStore(\n+                    conf,\n+                    dynConf,\n+                    writerZKC,\n+                    writerBKC,\n+                    scheduler,\n+                    allocator,\n+                    statsLogger,\n+                    failureInjector);\n+        }\n+        return writerEntryStore;\n+    }\n+\n+    private LogSegmentEntryStore getReaderEntryStore() {\n+        if (null == readerEntryStore) {\n+            readerEntryStore = new BKLogSegmentEntryStore(\n+                    conf,\n+                    dynConf,\n+                    writerZKC,\n+                    readerBKC,\n+                    scheduler,\n+                    allocator,\n+                    statsLogger,\n+                    failureInjector);\n+        }\n+        return readerEntryStore;\n+    }\n+\n+    @Override\n+    public AccessControlManager getAccessControlManager() throws IOException {\n+        if (null == accessControlManager) {\n+            String aclRootPath = getBkdlConfig().getACLRootPath();\n+            // Build the access control manager\n+            if (aclRootPath == null) {\n+                accessControlManager = DefaultAccessControlManager.INSTANCE;\n+                LOG.info(\"Created default access control manager for {}\", namespace);\n+            } else {\n+                if (!isReservedStreamName(aclRootPath)) {\n+                    throw new IOException(\"Invalid Access Control List Root Path : \" + aclRootPath);\n+                }\n+                String zkRootPath = namespace.getPath() + \"/\" + aclRootPath;\n+                LOG.info(\"Creating zk based access control manager @ {} for {}\",\n+                        zkRootPath, namespace);\n+                accessControlManager = new ZKAccessControlManager(conf, readerZKC,\n+                        zkRootPath, scheduler);\n+                LOG.info(\"Created zk based access control manager @ {} for {}\",\n+                        zkRootPath, namespace);\n+            }\n+        }\n+        return accessControlManager;\n+    }\n+\n+    @Override\n+    public SubscriptionsStore getSubscriptionsStore(String streamName) {\n+        return new ZKSubscriptionsStore(\n+                writerZKC,\n+                LogMetadataForReader.getSubscribersPath(namespace, streamName, conf.getUnpartitionedStreamName()));\n+    }\n+\n+    //\n+    // Legacy Intefaces\n+    //\n+\n+    @Override\n+    public MetadataAccessor getMetadataAccessor(String streamName)\n+            throws InvalidStreamNameException, IOException {\n+        if (getBkdlConfig().isFederatedNamespace()) {\n+            throw new UnsupportedOperationException();\n+        }\n+        checkState();\n+        validateName(streamName);\n+        return new ZKMetadataAccessor(\n+                streamName,\n+                conf,\n+                namespace,\n+                sharedWriterZKCBuilder,\n+                sharedReaderZKCBuilder,\n+                statsLogger);\n+    }\n+\n+    public Map<String, byte[]> enumerateLogsWithMetadataInNamespace()\n+        throws IOException, IllegalArgumentException {\n+        String namespaceRootPath = namespace.getPath();\n+        HashMap<String, byte[]> result = new HashMap<String, byte[]>();\n+        ZooKeeperClient zkc = writerZKC;\n+        try {\n+            ZooKeeper zk = Utils.sync(zkc, namespaceRootPath);\n+            Stat currentStat = zk.exists(namespaceRootPath, false);\n+            if (currentStat == null) {\n+                return result;\n+            }\n+            List<String> children = zk.getChildren(namespaceRootPath, false);\n+            for(String child: children) {\n+                if (isReservedStreamName(child)) {\n+                    continue;\n+                }\n+                String zkPath = String.format(\"%s/%s\", namespaceRootPath, child);\n+                currentStat = zk.exists(zkPath, false);\n+                if (currentStat == null) {\n+                    result.put(child, new byte[0]);\n+                } else {\n+                    result.put(child, zk.getData(zkPath, false, currentStat));\n+                }\n+            }\n+        } catch (InterruptedException ie) {\n+            LOG.error(\"Interrupted while deleting \" + namespaceRootPath, ie);\n+            throw new IOException(\"Interrupted while reading \" + namespaceRootPath, ie);\n+        } catch (KeeperException ke) {\n+            LOG.error(\"Error reading\" + namespaceRootPath + \"entry in zookeeper\", ke);\n+            throw new IOException(\"Error reading\" + namespaceRootPath + \"entry in zookeeper\", ke);\n+        }\n+        return result;\n+    }\n+\n+    //\n+    // Zk & Bk Utils\n+    //\n+\n+    public static ZooKeeperClientBuilder createZKClientBuilder(String zkcName,\n+                                                               DistributedLogConfiguration conf,\n+                                                               String zkServers,\n+                                                               StatsLogger statsLogger) {\n+        RetryPolicy retryPolicy = null;\n+        if (conf.getZKNumRetries() > 0) {\n+            retryPolicy = new BoundExponentialBackoffRetryPolicy(\n+                conf.getZKRetryBackoffStartMillis(),\n+                conf.getZKRetryBackoffMaxMillis(), conf.getZKNumRetries());\n+        }\n+        ZooKeeperClientBuilder builder = ZooKeeperClientBuilder.newBuilder()\n+            .name(zkcName)\n+            .sessionTimeoutMs(conf.getZKSessionTimeoutMilliseconds())\n+            .retryThreadCount(conf.getZKClientNumberRetryThreads())\n+            .requestRateLimit(conf.getZKRequestRateLimit())\n+            .zkServers(zkServers)\n+            .retryPolicy(retryPolicy)\n+            .statsLogger(statsLogger)\n+            .zkAclId(conf.getZkAclId());\n+        LOG.info(\"Created shared zooKeeper client builder {}: zkServers = {}, numRetries = {}, sessionTimeout = {}, retryBackoff = {},\"\n+                + \" maxRetryBackoff = {}, zkAclId = {}.\", new Object[] { zkcName, zkServers, conf.getZKNumRetries(),\n+                conf.getZKSessionTimeoutMilliseconds(), conf.getZKRetryBackoffStartMillis(),\n+                conf.getZKRetryBackoffMaxMillis(), conf.getZkAclId() });\n+        return builder;\n+    }\n+\n+    private BookKeeperClientBuilder createBKCBuilder(String bkcName,\n+                                                     DistributedLogConfiguration conf,\n+                                                     String zkServers,\n+                                                     String ledgersPath,\n+                                                     ClientSocketChannelFactory channelFactory,\n+                                                     HashedWheelTimer requestTimer,\n+                                                     Optional<FeatureProvider> featureProviderOptional,\n+                                                     StatsLogger statsLogger) {\n+        BookKeeperClientBuilder builder = BookKeeperClientBuilder.newBuilder()\n+                .name(bkcName)\n+                .dlConfig(conf)\n+                .zkServers(zkServers)\n+                .ledgersPath(ledgersPath)\n+                .channelFactory(channelFactory)\n+                .requestTimer(requestTimer)\n+                .featureProvider(featureProviderOptional)\n+                .statsLogger(statsLogger);\n+        LOG.info(\"Created shared client builder {} : zkServers = {}, ledgersPath = {}, numIOThreads = {}\",\n+                new Object[] { bkcName, zkServers, ledgersPath, conf.getBKClientNumberIOThreads() });\n+        return builder;\n+    }\n+\n+    //\n+    // Test Methods\n+    //\n+\n+    @VisibleForTesting\n+    public ZooKeeperClient getWriterZKC() {\n+        return writerZKC;\n+    }\n+\n+    @VisibleForTesting\n+    public BookKeeperClient getReaderBKC() {\n+        return readerBKC;\n+    }\n+\n+    @VisibleForTesting\n+    public AsyncFailureInjector getFailureInjector() {\n+        return this.failureInjector;\n+    }\n+\n+    @VisibleForTesting\n+    public LogStreamMetadataStore getWriterStreamMetadataStore() {\n+        return writerStreamMetadataStore;\n+    }\n+\n+    @VisibleForTesting\n+    public LedgerAllocator getLedgerAllocator() {\n+        return allocator;\n+    }\n+}"},{"sha":"50b1405cbc20fb29b53a1221807debea113f7467","filename":"src/main/java/com/twitter/distributedlog/impl/ZKLogMetadataStore.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FZKLogMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FZKLogMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FZKLogMetadataStore.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -36,7 +36,7 @@\n import java.util.Iterator;\n import java.util.List;\n \n-import static com.twitter.distributedlog.impl.BKDLUtils.*;\n+import static com.twitter.distributedlog.util.DLUtils.*;\n \n /**\n  * ZooKeeper based log metadata store"},{"sha":"eeda8046e223fec10ef37de22dfacd58db79ae45","filename":"src/main/java/com/twitter/distributedlog/impl/ZKMetadataAccessor.java","status":"renamed","additions":9,"deletions":4,"changes":13,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FZKMetadataAccessor.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FZKMetadataAccessor.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FZKMetadataAccessor.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -15,16 +15,19 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.twitter.distributedlog;\n+package com.twitter.distributedlog.impl;\n \n import java.io.IOException;\n import java.net.URI;\n \n import com.google.common.annotations.VisibleForTesting;\n+import com.twitter.distributedlog.DistributedLogConfiguration;\n+import com.twitter.distributedlog.MetadataAccessor;\n+import com.twitter.distributedlog.ZooKeeperClient;\n+import com.twitter.distributedlog.ZooKeeperClientBuilder;\n import com.twitter.distributedlog.exceptions.AlreadyClosedException;\n import com.twitter.distributedlog.exceptions.DLInterruptedException;\n-import com.twitter.distributedlog.metadata.BKDLConfig;\n-import com.twitter.distributedlog.util.DLUtils;\n+import com.twitter.distributedlog.impl.metadata.BKDLConfig;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.Utils;\n import com.twitter.util.Future;\n@@ -37,6 +40,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static com.twitter.distributedlog.impl.BKNamespaceDriver.getZKServersFromDLUri;\n+\n public class ZKMetadataAccessor implements MetadataAccessor {\n     static final Logger LOG = LoggerFactory.getLogger(ZKMetadataAccessor.class);\n     protected final String name;\n@@ -87,7 +92,7 @@ public class ZKMetadataAccessor implements MetadataAccessor {\n         this.writerZKC = this.writerZKCBuilder.build();\n \n         if (null == readerZKCBuilder) {\n-            String zkServersForWriter = DLUtils.getZKServersFromDLUri(uri);\n+            String zkServersForWriter = getZKServersFromDLUri(uri);\n             String zkServersForReader;\n             try {\n                 BKDLConfig bkdlConfig = BKDLConfig.resolveDLConfig(this.writerZKC, uri);","previous_filename":"src/main/java/com/twitter/distributedlog/ZKMetadataAccessor.java"},{"sha":"06bc8fb0c5aaf075380dcae259e768274a0488c1","filename":"src/main/java/com/twitter/distributedlog/impl/ZKNamespaceWatcher.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FZKNamespaceWatcher.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FZKNamespaceWatcher.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FZKNamespaceWatcher.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -37,7 +37,7 @@\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n \n-import static com.twitter.distributedlog.impl.BKDLUtils.*;\n+import static com.twitter.distributedlog.util.DLUtils.*;\n \n /**\n  * Watcher on watching a given namespace"},{"sha":"8126723aa827b02253c74ff14690b575e4821556","filename":"src/main/java/com/twitter/distributedlog/impl/acl/ZKAccessControl.java","status":"renamed","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Facl%2FZKAccessControl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Facl%2FZKAccessControl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Facl%2FZKAccessControl.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -15,8 +15,9 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.twitter.distributedlog.acl;\n+package com.twitter.distributedlog.impl.acl;\n \n+import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Objects;\n import com.twitter.distributedlog.ZooKeeperClient;\n import com.twitter.distributedlog.thrift.AccessControlEntry;\n@@ -89,10 +90,12 @@ public String toString() {\n         return sb.toString();\n     }\n \n+    @VisibleForTesting\n     public String getZKPath() {\n         return zkPath;\n     }\n \n+    @VisibleForTesting\n     public AccessControlEntry getAccessControlEntry() {\n         return accessControlEntry;\n     }","previous_filename":"src/main/java/com/twitter/distributedlog/acl/ZKAccessControl.java"},{"sha":"0c90a50eb86326b498a81f14c23d603c0c1a28d4","filename":"src/main/java/com/twitter/distributedlog/impl/acl/ZKAccessControlManager.java","status":"renamed","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Facl%2FZKAccessControlManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Facl%2FZKAccessControlManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Facl%2FZKAccessControlManager.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -15,11 +15,12 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.twitter.distributedlog.acl;\n+package com.twitter.distributedlog.impl.acl;\n \n import com.google.common.collect.Sets;\n import com.twitter.distributedlog.DistributedLogConfiguration;\n import com.twitter.distributedlog.ZooKeeperClient;\n+import com.twitter.distributedlog.acl.AccessControlManager;\n import com.twitter.distributedlog.exceptions.DLInterruptedException;\n import com.twitter.distributedlog.thrift.AccessControlEntry;\n import com.twitter.util.Await;","previous_filename":"src/main/java/com/twitter/distributedlog/acl/ZKAccessControlManager.java"},{"sha":"d7ff4fb564249d81cb07a6e8ab1d2341128c95d4","filename":"src/main/java/com/twitter/distributedlog/impl/logsegment/BKLogSegmentAllocator.java","status":"added","additions":85,"deletions":0,"changes":85,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentAllocator.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentAllocator.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentAllocator.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -0,0 +1,85 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.twitter.distributedlog.impl.logsegment;\n+\n+import com.twitter.distributedlog.bk.LedgerAllocator;\n+import com.twitter.distributedlog.logsegment.LogSegmentEntryWriter;\n+import com.twitter.distributedlog.util.Allocator;\n+import com.twitter.distributedlog.util.Transaction;\n+import com.twitter.util.Future;\n+import org.apache.bookkeeper.client.LedgerHandle;\n+import scala.Function1;\n+import scala.runtime.AbstractFunction1;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Allocate log segments\n+ */\n+class BKLogSegmentAllocator implements Allocator<LogSegmentEntryWriter, Object> {\n+\n+    private static class NewLogSegmentEntryWriterFn extends AbstractFunction1<LedgerHandle, LogSegmentEntryWriter> {\n+\n+        static final Function1<LedgerHandle, LogSegmentEntryWriter> INSTANCE =\n+                new NewLogSegmentEntryWriterFn();\n+\n+        private NewLogSegmentEntryWriterFn() {}\n+\n+        @Override\n+        public LogSegmentEntryWriter apply(LedgerHandle lh) {\n+            return new BKLogSegmentEntryWriter(lh);\n+        }\n+    }\n+\n+    LedgerAllocator allocator;\n+\n+    BKLogSegmentAllocator(LedgerAllocator allocator) {\n+        this.allocator = allocator;\n+    }\n+\n+    @Override\n+    public void allocate() throws IOException {\n+        allocator.allocate();\n+    }\n+\n+    @Override\n+    public Future<LogSegmentEntryWriter> tryObtain(Transaction<Object> txn,\n+                                                   final Transaction.OpListener<LogSegmentEntryWriter> listener) {\n+        return allocator.tryObtain(txn, new Transaction.OpListener<LedgerHandle>() {\n+            @Override\n+            public void onCommit(LedgerHandle lh) {\n+                listener.onCommit(new BKLogSegmentEntryWriter(lh));\n+            }\n+\n+            @Override\n+            public void onAbort(Throwable t) {\n+                listener.onAbort(t);\n+            }\n+        }).map(NewLogSegmentEntryWriterFn.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<Void> asyncClose() {\n+        return allocator.asyncClose();\n+    }\n+\n+    @Override\n+    public Future<Void> delete() {\n+        return allocator.delete();\n+    }\n+}"},{"sha":"f85760d789f36513e0f7ea6dea607ef031070556","filename":"src/main/java/com/twitter/distributedlog/impl/logsegment/BKLogSegmentEntryReader.java","status":"modified","additions":25,"deletions":2,"changes":27,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryReader.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -48,6 +48,7 @@\n import java.util.Enumeration;\n import java.util.LinkedList;\n import java.util.List;\n+import java.util.concurrent.CopyOnWriteArraySet;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n@@ -209,6 +210,7 @@ boolean checkReturnCodeAndHandleFailure(int rc, boolean isLongPoll) {\n                 int numErrors = Math.max(1, numReadErrors.incrementAndGet());\n                 int nextReadBackoffTime = Math.min(numErrors * readAheadWaitTime, maxReadBackoffTime);\n                 scheduler.schedule(\n+                        getSegment().getLogSegmentId(),\n                         this,\n                         nextReadBackoffTime,\n                         TimeUnit.MILLISECONDS);\n@@ -284,6 +286,8 @@ boolean hasReadEnoughEntries() {\n     private final AtomicReference<Throwable> lastException = new AtomicReference<Throwable>(null);\n     private final AtomicLong scheduleCount = new AtomicLong(0);\n     private volatile boolean hasCaughtupOnInprogress = false;\n+    private final CopyOnWriteArraySet<StateChangeListener> stateChangeListeners =\n+            new CopyOnWriteArraySet<StateChangeListener>();\n     // read retries\n     private int readAheadWaitTime;\n     private final int maxReadBackoffTime;\n@@ -374,6 +378,24 @@ public boolean hasCaughtUpOnInprogress() {\n         return hasCaughtupOnInprogress;\n     }\n \n+    @Override\n+    public LogSegmentEntryReader registerListener(StateChangeListener listener) {\n+        stateChangeListeners.add(listener);\n+        return this;\n+    }\n+\n+    @Override\n+    public LogSegmentEntryReader unregisterListener(StateChangeListener listener) {\n+        stateChangeListeners.remove(listener);\n+        return this;\n+    }\n+\n+    private void notifyCaughtupOnInprogress() {\n+        for (StateChangeListener listener : stateChangeListeners) {\n+            listener.onCaughtupOnInprogress();\n+        }\n+    }\n+\n     //\n     // Process on Log Segment Metadata Updates\n     //\n@@ -440,7 +462,7 @@ private void failOrRetryOpenLedger(int rc, final LogSegmentMetadata segment) {\n             return;\n         }\n         // the reader is still catching up, retry opening the log segment later\n-        scheduler.schedule(new Runnable() {\n+        scheduler.schedule(segment.getLogSegmentId(), new Runnable() {\n             @Override\n             public void run() {\n                 onLogSegmentMetadataUpdated(segment);\n@@ -583,6 +605,7 @@ private void issueLongPollRead(CacheEntry cacheEntry) {\n \n         if (!hasCaughtupOnInprogress) {\n             hasCaughtupOnInprogress = true;\n+            notifyCaughtupOnInprogress();\n         }\n         getLh().asyncReadLastConfirmedAndEntry(\n                 cacheEntry.entryId,\n@@ -633,7 +656,7 @@ private void processReadRequests() {\n \n         long prevCount = scheduleCount.getAndIncrement();\n         if (0 == prevCount) {\n-            scheduler.submit(this);\n+            scheduler.submit(getSegment().getLogSegmentId(), this);\n         }\n     }\n "},{"sha":"91e6dec746ceff8017141235cfbeb6ef5abb4735","filename":"src/main/java/com/twitter/distributedlog/impl/logsegment/BKLogSegmentEntryStore.java","status":"modified","additions":57,"deletions":6,"changes":63,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FBKLogSegmentEntryStore.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -20,12 +20,21 @@\n import com.twitter.distributedlog.BookKeeperClient;\n import com.twitter.distributedlog.DistributedLogConfiguration;\n import com.twitter.distributedlog.LogSegmentMetadata;\n+import com.twitter.distributedlog.ZooKeeperClient;\n+import com.twitter.distributedlog.bk.DynamicQuorumConfigProvider;\n+import com.twitter.distributedlog.bk.LedgerAllocator;\n+import com.twitter.distributedlog.bk.LedgerAllocatorDelegator;\n+import com.twitter.distributedlog.bk.QuorumConfigProvider;\n+import com.twitter.distributedlog.bk.SimpleLedgerAllocator;\n+import com.twitter.distributedlog.config.DynamicDistributedLogConfiguration;\n import com.twitter.distributedlog.exceptions.BKTransmitException;\n import com.twitter.distributedlog.injector.AsyncFailureInjector;\n import com.twitter.distributedlog.logsegment.LogSegmentEntryReader;\n import com.twitter.distributedlog.logsegment.LogSegmentEntryStore;\n import com.twitter.distributedlog.logsegment.LogSegmentEntryWriter;\n import com.twitter.distributedlog.logsegment.LogSegmentRandomAccessEntryReader;\n+import com.twitter.distributedlog.metadata.LogMetadataForWriter;\n+import com.twitter.distributedlog.util.Allocator;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.OrderedScheduler;\n import com.twitter.util.Future;\n@@ -80,21 +89,31 @@ private static class DeleteLogSegmentRequest {\n     }\n \n     private final byte[] passwd;\n+    private final ZooKeeperClient zkc;\n     private final BookKeeperClient bkc;\n     private final OrderedScheduler scheduler;\n     private final DistributedLogConfiguration conf;\n+    private final DynamicDistributedLogConfiguration dynConf;\n     private final StatsLogger statsLogger;\n     private final AsyncFailureInjector failureInjector;\n+    // ledger allocator\n+    private final LedgerAllocator allocator;\n \n     public BKLogSegmentEntryStore(DistributedLogConfiguration conf,\n+                                  DynamicDistributedLogConfiguration dynConf,\n+                                  ZooKeeperClient zkc,\n                                   BookKeeperClient bkc,\n                                   OrderedScheduler scheduler,\n+                                  LedgerAllocator allocator,\n                                   StatsLogger statsLogger,\n                                   AsyncFailureInjector failureInjector) {\n         this.conf = conf;\n+        this.dynConf = dynConf;\n+        this.zkc = zkc;\n         this.bkc = bkc;\n         this.passwd = conf.getBKDigestPW().getBytes(UTF_8);\n         this.scheduler = scheduler;\n+        this.allocator = allocator;\n         this.statsLogger = statsLogger;\n         this.failureInjector = failureInjector;\n     }\n@@ -129,11 +148,43 @@ public void deleteComplete(int rc, Object ctx) {\n         FutureUtils.setValue(deleteRequest.deletePromise, deleteRequest.segment);\n     }\n \n+    //\n+    // Writers\n+    //\n+\n+    LedgerAllocator createLedgerAllocator(LogMetadataForWriter logMetadata,\n+                                          DynamicDistributedLogConfiguration dynConf)\n+            throws IOException {\n+        LedgerAllocator ledgerAllocatorDelegator;\n+        if (null == allocator || !dynConf.getEnableLedgerAllocatorPool()) {\n+            QuorumConfigProvider quorumConfigProvider =\n+                    new DynamicQuorumConfigProvider(dynConf);\n+            LedgerAllocator allocator = new SimpleLedgerAllocator(\n+                    logMetadata.getAllocationPath(),\n+                    logMetadata.getAllocationData(),\n+                    quorumConfigProvider,\n+                    zkc,\n+                    bkc);\n+            ledgerAllocatorDelegator = new LedgerAllocatorDelegator(allocator, true);\n+        } else {\n+            ledgerAllocatorDelegator = allocator;\n+        }\n+        return ledgerAllocatorDelegator;\n+    }\n+\n     @Override\n-    public Future<LogSegmentEntryWriter> openWriter(LogSegmentMetadata segment) {\n-        throw new UnsupportedOperationException(\"Not supported yet\");\n+    public Allocator<LogSegmentEntryWriter, Object> newLogSegmentAllocator(\n+            LogMetadataForWriter logMetadata,\n+            DynamicDistributedLogConfiguration dynConf) throws IOException {\n+        // Build the ledger allocator\n+        LedgerAllocator allocator = createLedgerAllocator(logMetadata, dynConf);\n+        return new BKLogSegmentAllocator(allocator);\n     }\n \n+    //\n+    // Readers\n+    //\n+\n     @Override\n     public Future<LogSegmentEntryReader> openReader(LogSegmentMetadata segment,\n                                                     long startEntryId) {\n@@ -220,15 +271,15 @@ public void openComplete(int rc, LedgerHandle lh, Object ctx) {\n                     segment.getLogSegmentId(),\n                     BookKeeper.DigestType.CRC32,\n                     passwd,\n-                    this,\n-                    openCallback);\n+                    openCallback,\n+                    null);\n         } else {\n             bk.asyncOpenLedger(\n                     segment.getLogSegmentId(),\n                     BookKeeper.DigestType.CRC32,\n                     passwd,\n-                    this,\n-                    openCallback);\n+                    openCallback,\n+                    null);\n         }\n         return openPromise;\n     }"},{"sha":"3e859fb75561ee4f12fac38d8473dd363bf3baba","filename":"src/main/java/com/twitter/distributedlog/impl/metadata/BKDLConfig.java","status":"renamed","additions":6,"deletions":5,"changes":11,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fmetadata%2FBKDLConfig.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fmetadata%2FBKDLConfig.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fmetadata%2FBKDLConfig.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -15,15 +15,16 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.twitter.distributedlog.metadata;\n+package com.twitter.distributedlog.impl.metadata;\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Objects;\n import com.twitter.distributedlog.DistributedLogConfiguration;\n import com.twitter.distributedlog.DistributedLogConstants;\n import com.twitter.distributedlog.ZooKeeperClient;\n+import com.twitter.distributedlog.impl.BKNamespaceDriver;\n+import com.twitter.distributedlog.metadata.DLConfig;\n import com.twitter.distributedlog.thrift.BKDLConfigFormat;\n-import com.twitter.distributedlog.util.DLUtils;\n import org.apache.thrift.TException;\n import org.apache.thrift.protocol.TJSONProtocol;\n import org.apache.thrift.transport.TMemoryBuffer;\n@@ -96,9 +97,9 @@ public static void clearCachedDLConfigs() {\n     /**\n      * Construct a empty config with given <i>uri</i>.\n      */\n-    BKDLConfig(URI uri) {\n-        this(DLUtils.getZKServersFromDLUri(uri),\n-             DLUtils.getZKServersFromDLUri(uri),\n+    public BKDLConfig(URI uri) {\n+        this(BKNamespaceDriver.getZKServersFromDLUri(uri),\n+             BKNamespaceDriver.getZKServersFromDLUri(uri),\n              null, null, null);\n     }\n ","previous_filename":"src/main/java/com/twitter/distributedlog/metadata/BKDLConfig.java"},{"sha":"6b7a231fe50ac2acb1cc9d568150fdfff2bfc825","filename":"src/main/java/com/twitter/distributedlog/impl/metadata/ZkMetadataResolver.java","status":"renamed","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fmetadata%2FZkMetadataResolver.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fmetadata%2FZkMetadataResolver.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fmetadata%2FZkMetadataResolver.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -15,9 +15,11 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.twitter.distributedlog.metadata;\n+package com.twitter.distributedlog.impl.metadata;\n \n import com.twitter.distributedlog.ZooKeeperClient;\n+import com.twitter.distributedlog.metadata.DLMetadata;\n+import com.twitter.distributedlog.metadata.MetadataResolver;\n import org.apache.commons.lang.StringUtils;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.common.PathUtils;","previous_filename":"src/main/java/com/twitter/distributedlog/metadata/ZkMetadataResolver.java"},{"sha":"b067ee97c21dbc4f64533be64c6711fe81f78143","filename":"src/main/java/com/twitter/distributedlog/impl/subscription/ZKSubscriptionStateStore.java","status":"renamed","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fsubscription%2FZKSubscriptionStateStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fsubscription%2FZKSubscriptionStateStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fsubscription%2FZKSubscriptionStateStore.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -15,11 +15,12 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.twitter.distributedlog.subscription;\n+package com.twitter.distributedlog.impl.subscription;\n \n import java.io.IOException;\n import java.util.concurrent.atomic.AtomicReference;\n \n+import com.twitter.distributedlog.subscription.SubscriptionStateStore;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import scala.runtime.BoxedUnit;","previous_filename":"src/main/java/com/twitter/distributedlog/subscription/ZKSubscriptionStateStore.java"},{"sha":"17ba943bdbd4007190e4401b060bcbdd78355c24","filename":"src/main/java/com/twitter/distributedlog/impl/subscription/ZKSubscriptionsStore.java","status":"renamed","additions":3,"deletions":4,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fsubscription%2FZKSubscriptionsStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fsubscription%2FZKSubscriptionsStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fsubscription%2FZKSubscriptionsStore.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -15,13 +15,14 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.twitter.distributedlog.subscription;\n+package com.twitter.distributedlog.impl.subscription;\n \n import com.twitter.distributedlog.DLSN;\n import com.twitter.distributedlog.ZooKeeperClient;\n import com.twitter.distributedlog.exceptions.DLInterruptedException;\n+import com.twitter.distributedlog.subscription.SubscriptionStateStore;\n+import com.twitter.distributedlog.subscription.SubscriptionsStore;\n import com.twitter.distributedlog.util.Utils;\n-import com.twitter.util.Function;\n import com.twitter.util.Future;\n import com.twitter.util.Promise;\n \n@@ -30,8 +31,6 @@\n import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.data.Stat;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import scala.runtime.AbstractFunction1;\n import scala.runtime.BoxedUnit;\n ","previous_filename":"src/main/java/com/twitter/distributedlog/subscription/ZKSubscriptionsStore.java"},{"sha":"81eb5ed09f9046853d4cd4ece8331b0015e13045","filename":"src/main/java/com/twitter/distributedlog/logsegment/LogSegmentEntryReader.java","status":"modified","additions":25,"deletions":0,"changes":25,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryReader.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -32,12 +32,37 @@\n @Beta\n public interface LogSegmentEntryReader extends AsyncCloseable {\n \n+    interface StateChangeListener {\n+\n+        /**\n+         * Notify when caught up on inprogress.\n+         */\n+        void onCaughtupOnInprogress();\n+\n+    }\n+\n     /**\n      * Start the reader. The method to signal the implementation\n      * to start preparing the data for consumption {@link #readNext(int)}\n      */\n     void start();\n \n+    /**\n+     * Register the state change listener\n+     *\n+     * @param listener register the state change listener\n+     * @return entry reader\n+     */\n+    LogSegmentEntryReader registerListener(StateChangeListener listener);\n+\n+    /**\n+     * Unregister the state change listener\n+     *\n+     * @param listener register the state change listener\n+     * @return entry reader\n+     */\n+    LogSegmentEntryReader unregisterListener(StateChangeListener listener);\n+\n     /**\n      * Return the log segment metadata for this reader.\n      *"},{"sha":"bcf81297efade92a923e670424d1f4769d7d4b84","filename":"src/main/java/com/twitter/distributedlog/logsegment/LogSegmentEntryStore.java","status":"modified","additions":12,"deletions":4,"changes":16,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Flogsegment%2FLogSegmentEntryStore.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -19,8 +19,14 @@\n \n import com.google.common.annotations.Beta;\n import com.twitter.distributedlog.LogSegmentMetadata;\n+import com.twitter.distributedlog.config.DynamicDistributedLogConfiguration;\n+import com.twitter.distributedlog.metadata.LogMetadataForWriter;\n+import com.twitter.distributedlog.util.Allocator;\n+import com.twitter.distributedlog.util.Transaction;\n import com.twitter.util.Future;\n \n+import java.io.IOException;\n+\n /**\n  * Log Segment Store to read log segments\n  */\n@@ -36,12 +42,14 @@ public interface LogSegmentEntryStore {\n     Future<LogSegmentMetadata> deleteLogSegment(LogSegmentMetadata segment);\n \n     /**\n-     * Open the writer for writing data to the log <i>segment</i>.\n+     * Create a new log segment allocator for allocating log segment entry writers.\n      *\n-     * @param segment the log <i>segment</i> to write data to\n-     * @return future represent the opened writer\n+     * @param metadata the metadata for the log stream\n+     * @return future represent the log segment allocator\n      */\n-    Future<LogSegmentEntryWriter> openWriter(LogSegmentMetadata segment);\n+    Allocator<LogSegmentEntryWriter, Object> newLogSegmentAllocator(\n+            LogMetadataForWriter metadata,\n+            DynamicDistributedLogConfiguration dynConf) throws IOException;\n \n     /**\n      * Open the reader for reading data to the log <i>segment</i>."},{"sha":"c0b5fb70ea2ebcaea8d75372df963b44ec98582d","filename":"src/main/java/com/twitter/distributedlog/metadata/DLMetadata.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fmetadata%2FDLMetadata.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fmetadata%2FDLMetadata.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fmetadata%2FDLMetadata.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -18,6 +18,7 @@\n package com.twitter.distributedlog.metadata;\n \n import com.twitter.distributedlog.DistributedLogConfiguration;\n+import com.twitter.distributedlog.impl.metadata.BKDLConfig;\n import com.twitter.distributedlog.util.Utils;\n import com.twitter.distributedlog.ZooKeeperClient;\n import com.twitter.distributedlog.ZooKeeperClientBuilder;"},{"sha":"5d1d888390b100085e985d884b7492f07d54765e","filename":"src/main/java/com/twitter/distributedlog/namespace/DistributedLogNamespace.java","status":"modified","additions":7,"deletions":0,"changes":7,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fnamespace%2FDistributedLogNamespace.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fnamespace%2FDistributedLogNamespace.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fnamespace%2FDistributedLogNamespace.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -70,6 +70,13 @@\n @Beta\n public interface DistributedLogNamespace {\n \n+    /**\n+     * Get the namespace driver used by this namespace.\n+     *\n+     * @return namespace driver\n+     */\n+    NamespaceDriver getNamespaceDriver();\n+\n     //\n     // Method to operate logs\n     //"},{"sha":"07b3848470f2a40d7ba119e439d459279455cee7","filename":"src/main/java/com/twitter/distributedlog/namespace/DistributedLogNamespaceBuilder.java","status":"modified","additions":105,"deletions":38,"changes":143,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fnamespace%2FDistributedLogNamespaceBuilder.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fnamespace%2FDistributedLogNamespaceBuilder.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fnamespace%2FDistributedLogNamespaceBuilder.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -17,22 +17,29 @@\n  */\n package com.twitter.distributedlog.namespace;\n \n-import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import com.twitter.distributedlog.BKDistributedLogNamespace;\n import com.twitter.distributedlog.DistributedLogConfiguration;\n import com.twitter.distributedlog.DistributedLogConstants;\n+import com.twitter.distributedlog.config.DynamicDistributedLogConfiguration;\n+import com.twitter.distributedlog.feature.CoreFeatureKeys;\n+import com.twitter.distributedlog.injector.AsyncFailureInjector;\n+import com.twitter.distributedlog.injector.AsyncRandomFailureInjector;\n+import com.twitter.distributedlog.util.ConfUtils;\n+import com.twitter.distributedlog.util.DLUtils;\n+import com.twitter.distributedlog.util.OrderedScheduler;\n+import com.twitter.distributedlog.util.PermitLimiter;\n+import com.twitter.distributedlog.util.SimplePermitLimiter;\n+import org.apache.bookkeeper.feature.Feature;\n import org.apache.bookkeeper.feature.FeatureProvider;\n import org.apache.bookkeeper.feature.SettableFeatureProvider;\n import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.stats.StatsLogger;\n-import org.apache.commons.lang.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n import java.net.URI;\n-import java.net.URISyntaxException;\n \n /**\n  * Builder to construct a <code>DistributedLogNamespace</code>.\n@@ -50,6 +57,7 @@ public static DistributedLogNamespaceBuilder newBuilder() {\n     }\n \n     private DistributedLogConfiguration _conf = null;\n+    private DynamicDistributedLogConfiguration _dynConf = null;\n     private URI _uri = null;\n     private StatsLogger _statsLogger = NullStatsLogger.INSTANCE;\n     private StatsLogger _perLogStatsLogger = NullStatsLogger.INSTANCE;\n@@ -72,6 +80,17 @@ public DistributedLogNamespaceBuilder conf(DistributedLogConfiguration conf) {\n         return this;\n     }\n \n+    /**\n+     * Dynamic DistributedLog Configuration used for the namespace\n+     *\n+     * @param dynConf dynamic distributedlog configuration\n+     * @return namespace builder\n+     */\n+    public DistributedLogNamespaceBuilder dynConf(DynamicDistributedLogConfiguration dynConf) {\n+        this._dynConf = dynConf;\n+        return this;\n+    }\n+\n     /**\n      * Namespace Location.\n      *\n@@ -146,6 +165,18 @@ public DistributedLogNamespaceBuilder regionId(int regionId) {\n         return this;\n     }\n \n+    @SuppressWarnings(\"deprecation\")\n+    private static StatsLogger normalizePerLogStatsLogger(StatsLogger statsLogger,\n+                                                          StatsLogger perLogStatsLogger,\n+                                                          DistributedLogConfiguration conf) {\n+        StatsLogger normalizedPerLogStatsLogger = perLogStatsLogger;\n+        if (perLogStatsLogger == NullStatsLogger.INSTANCE &&\n+                conf.getEnablePerStreamStat()) {\n+            normalizedPerLogStatsLogger = statsLogger.scope(\"stream\");\n+        }\n+        return normalizedPerLogStatsLogger;\n+    }\n+\n     /**\n      * Build the namespace.\n      *\n@@ -160,25 +191,17 @@ public DistributedLogNamespace build()\n         Preconditions.checkNotNull(_conf, \"No DistributedLog Configuration.\");\n         Preconditions.checkNotNull(_uri, \"No DistributedLog URI\");\n \n-        // Validate the uri and load the backend according to scheme\n-        String scheme = _uri.getScheme();\n-        Preconditions.checkNotNull(scheme, \"Invalid DistributedLog URI : \" + _uri);\n-        String[] schemeParts = StringUtils.split(scheme, '-');\n-        Preconditions.checkArgument(schemeParts.length > 0,\n-                \"Invalid distributedlog scheme found : \" + _uri);\n-        Preconditions.checkArgument(Objects.equal(DistributedLogConstants.SCHEME_PREFIX, schemeParts[0].toLowerCase()),\n-                \"Unknown distributedlog scheme found : \" + _uri);\n-\n-        // both distributedlog: & distributedlog-bk: use bookkeeper as the backend\n-        // TODO: we could do reflection to load backend in future.\n-        //       if we are going to support other backends : e.g. 'distributedlog-mem:'.\n-        if (schemeParts.length > 1) {\n-            String backendProvider = schemeParts[1];\n-            Preconditions.checkArgument(Objects.equal(DistributedLogConstants.BACKEND_BK, backendProvider.toLowerCase()),\n-                    \"Backend '\" + backendProvider + \"' is not supported yet.\");\n+        // validate the configuration\n+        _conf.validate();\n+        if (null == _dynConf) {\n+            _dynConf = ConfUtils.getConstDynConf(_conf);\n         }\n \n-        // Built the feature provider\n+        // retrieve the namespace driver\n+        NamespaceDriver driver = NamespaceDriverManager.getDriver(_uri);\n+        URI normalizedUri = DLUtils.normalizeURI(_uri);\n+\n+        // build the feature provider\n         FeatureProvider featureProvider;\n         if (null == _featureProvider) {\n             featureProvider = new SettableFeatureProvider(\"\", 0);\n@@ -187,25 +210,69 @@ public DistributedLogNamespace build()\n             featureProvider = _featureProvider;\n         }\n \n-        URI bkUri;\n-        try {\n-            bkUri = new URI(\n-                    schemeParts[0],     // remove backend info from bookkeeper backend\n-                    _uri.getAuthority(),\n-                    _uri.getPath(),\n-                    _uri.getQuery(),\n-                    _uri.getFragment());\n-        } catch (URISyntaxException e) {\n-            throw new IllegalArgumentException(\"Invalid distributedlog uri found : \" + _uri, e);\n-        }\n+        // build the failure injector\n+        AsyncFailureInjector failureInjector = AsyncRandomFailureInjector.newBuilder()\n+                .injectDelays(_conf.getEIInjectReadAheadDelay(),\n+                              _conf.getEIInjectReadAheadDelayPercent(),\n+                              _conf.getEIInjectMaxReadAheadDelayMs())\n+                .injectErrors(false, 10)\n+                .injectStops(_conf.getEIInjectReadAheadStall(), 10)\n+                .injectCorruption(_conf.getEIInjectReadAheadBrokenEntries())\n+                .build();\n \n-        return BKDistributedLogNamespace.newBuilder()\n-                .conf(_conf)\n-                .uri(bkUri)\n-                .statsLogger(_statsLogger)\n-                .featureProvider(featureProvider)\n-                .clientId(_clientId)\n-                .regionId(_regionId)\n+        // normalize the per log stats logger\n+        StatsLogger perLogStatsLogger = normalizePerLogStatsLogger(_statsLogger, _perLogStatsLogger, _conf);\n+\n+        // build the scheduler\n+        StatsLogger schedulerStatsLogger = _statsLogger.scope(\"factory\").scope(\"thread_pool\");\n+        OrderedScheduler scheduler = OrderedScheduler.newBuilder()\n+                .name(\"DLM-\" + normalizedUri.getPath())\n+                .corePoolSize(_conf.getNumWorkerThreads())\n+                .statsLogger(schedulerStatsLogger)\n+                .perExecutorStatsLogger(schedulerStatsLogger)\n+                .traceTaskExecution(_conf.getEnableTaskExecutionStats())\n+                .traceTaskExecutionWarnTimeUs(_conf.getTaskExecutionWarnTimeMicros())\n                 .build();\n+\n+        // initialize the namespace driver\n+        driver.initialize(\n+                _conf,\n+                _dynConf,\n+                normalizedUri,\n+                scheduler,\n+                featureProvider,\n+                failureInjector,\n+                _statsLogger,\n+                perLogStatsLogger,\n+                DLUtils.normalizeClientId(_clientId),\n+                _regionId);\n+\n+        // initialize the write limiter\n+        PermitLimiter writeLimiter;\n+        if (_conf.getGlobalOutstandingWriteLimit() < 0) {\n+            writeLimiter = PermitLimiter.NULL_PERMIT_LIMITER;\n+        } else {\n+            Feature disableWriteLimitFeature = featureProvider.getFeature(\n+                CoreFeatureKeys.DISABLE_WRITE_LIMIT.name().toLowerCase());\n+            writeLimiter = new SimplePermitLimiter(\n+                _conf.getOutstandingWriteLimitDarkmode(),\n+                _conf.getGlobalOutstandingWriteLimit(),\n+                _statsLogger.scope(\"writeLimiter\"),\n+                true /* singleton */,\n+                disableWriteLimitFeature);\n+        }\n+\n+        return new BKDistributedLogNamespace(\n+                _conf,\n+                normalizedUri,\n+                driver,\n+                scheduler,\n+                featureProvider,\n+                writeLimiter,\n+                failureInjector,\n+                _statsLogger,\n+                perLogStatsLogger,\n+                DLUtils.normalizeClientId(_clientId),\n+                _regionId);\n     }\n }"},{"sha":"738f1243d12c2a0a6bc058508cfbe8df4a74ae07","filename":"src/main/java/com/twitter/distributedlog/namespace/NamespaceDriver.java","status":"added","additions":138,"deletions":0,"changes":138,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fnamespace%2FNamespaceDriver.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fnamespace%2FNamespaceDriver.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fnamespace%2FNamespaceDriver.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -0,0 +1,138 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.twitter.distributedlog.namespace;\n+\n+import com.twitter.distributedlog.DistributedLogConfiguration;\n+import com.twitter.distributedlog.MetadataAccessor;\n+import com.twitter.distributedlog.acl.AccessControlManager;\n+import com.twitter.distributedlog.config.DynamicDistributedLogConfiguration;\n+import com.twitter.distributedlog.exceptions.InvalidStreamNameException;\n+import com.twitter.distributedlog.injector.AsyncFailureInjector;\n+import com.twitter.distributedlog.logsegment.LogSegmentEntryStore;\n+import com.twitter.distributedlog.logsegment.LogSegmentMetadataStore;\n+import com.twitter.distributedlog.metadata.LogMetadataStore;\n+import com.twitter.distributedlog.metadata.LogStreamMetadataStore;\n+import com.twitter.distributedlog.subscription.SubscriptionsStore;\n+import com.twitter.distributedlog.util.OrderedScheduler;\n+import org.apache.bookkeeper.feature.FeatureProvider;\n+import org.apache.bookkeeper.stats.StatsLogger;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.net.URI;\n+\n+/**\n+ * Manager to manage all the stores required by a namespace.\n+ */\n+public interface NamespaceDriver extends Closeable {\n+\n+    enum Role {\n+        WRITER,\n+        READER\n+    }\n+\n+    /**\n+     * Initialize the namespace manager.\n+     *\n+     * @param conf distributedlog configuration\n+     * @param dynConf dynamic distributedlog configuration\n+     * @param namespace root uri of the namespace\n+     * @param scheduler ordered scheduler\n+     * @param featureProvider feature provider\n+     * @param statsLogger stats logger\n+     * @param perLogStatsLogger per log stream stats logger\n+     * @param clientId client id\n+     * @return namespace manager\n+     * @throws IOException when failed to initialize the namespace manager\n+     */\n+    NamespaceDriver initialize(DistributedLogConfiguration conf,\n+                               DynamicDistributedLogConfiguration dynConf,\n+                               URI namespace,\n+                               OrderedScheduler scheduler,\n+                               FeatureProvider featureProvider,\n+                               AsyncFailureInjector failureInjector,\n+                               StatsLogger statsLogger,\n+                               StatsLogger perLogStatsLogger,\n+                               String clientId,\n+                               int regionId) throws IOException;\n+\n+    /**\n+     * Get the scheme of the namespace driver.\n+     *\n+     * @return the scheme of the namespace driver.\n+     */\n+    String getScheme();\n+\n+    /**\n+     * Get the root uri of the namespace driver.\n+     *\n+     * @return the root uri of the namespace driver.\n+     */\n+    URI getUri();\n+\n+    /**\n+     * Retrieve the log {@code metadata store} used by the namespace.\n+     *\n+     * @return the log metadata store\n+     */\n+    LogMetadataStore getLogMetadataStore();\n+\n+    /**\n+     * Retrieve the log stream {@code metadata store} used by the namespace.\n+     *\n+     * @param role the role to retrieve the log stream metadata store.\n+     * @return the log stream metadata store\n+     */\n+    LogStreamMetadataStore getLogStreamMetadataStore(Role role);\n+\n+    /**\n+     * Retrieve the log segment {@code entry store} used by the namespace.\n+     *\n+     * @param role the role to retrieve the log segment entry store.\n+     * @return the log segment entry store.\n+     * @throws IOException when failed to open log segment entry store.\n+     */\n+    LogSegmentEntryStore getLogSegmentEntryStore(Role role);\n+\n+    /**\n+     * Create an access control manager to manage/check acl for logs.\n+     *\n+     * @return access control manager for logs under the namespace.\n+     * @throws IOException\n+     */\n+    AccessControlManager getAccessControlManager()\n+            throws IOException;\n+\n+    /**\n+     * Retrieve the metadata accessor for log stream {@code streamName}.\n+     * (TODO: it is a legacy interface. should remove it if we have metadata of stream.)\n+     *\n+     * @param streamName name of log stream.\n+     * @return metadata accessor for log stream {@code streamName}.\n+     */\n+    MetadataAccessor getMetadataAccessor(String streamName)\n+            throws InvalidStreamNameException, IOException;\n+\n+    /**\n+     * Retrieve the subscriptions store for log stream {@code streamName}.\n+     *\n+     * @return the subscriptions store for log stream {@code streamName}\n+     */\n+    SubscriptionsStore getSubscriptionsStore(String streamName);\n+\n+}"},{"sha":"79945ad51c95176aa495c7fb77cd476297305ac7","filename":"src/main/java/com/twitter/distributedlog/namespace/NamespaceDriverManager.java","status":"added","additions":180,"deletions":0,"changes":180,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fnamespace%2FNamespaceDriverManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fnamespace%2FNamespaceDriverManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fnamespace%2FNamespaceDriverManager.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -0,0 +1,180 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.twitter.distributedlog.namespace;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.collect.Sets;\n+import com.twitter.distributedlog.DistributedLogConstants;\n+import com.twitter.distributedlog.impl.BKNamespaceDriver;\n+import org.apache.bookkeeper.util.ReflectionUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.URI;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import static com.google.common.base.Preconditions.*;\n+\n+/**\n+ * The basic service for managing a set of namespace drivers.\n+ */\n+public class NamespaceDriverManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(NamespaceDriverManager.class);\n+\n+    static class NamespaceDriverInfo {\n+\n+        final Class<? extends NamespaceDriver> driverClass;\n+        final String driverClassName;\n+\n+        NamespaceDriverInfo(Class<? extends NamespaceDriver> driverClass) {\n+            this.driverClass = driverClass;\n+            this.driverClassName = this.driverClass.getName();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"driver[\")\n+                    .append(driverClassName)\n+                    .append(\"]\");\n+            return sb.toString();\n+        }\n+    }\n+\n+    private static final ConcurrentMap<String, NamespaceDriverInfo> drivers;\n+    private static boolean initialized = false;\n+\n+    static {\n+        drivers = new ConcurrentHashMap<String, NamespaceDriverInfo>();\n+        initialize();\n+    }\n+\n+    static void initialize() {\n+        if (initialized) {\n+            return;\n+        }\n+        loadInitialDrivers();\n+        initialized = true;\n+        logger.info(\"DistributedLog NamespaceDriverManager initialized\");\n+    }\n+\n+    private static void loadInitialDrivers() {\n+        Set<String> driverList = Sets.newHashSet();\n+        // add default bookkeeper based driver\n+        driverList.add(BKNamespaceDriver.class.getName());\n+        // load drivers from system property\n+        String driversStr = System.getProperty(\"distributedlog.namespace.drivers\");\n+        if (null != driversStr) {\n+            String[] driversArray = StringUtils.split(driversStr, ':');\n+            for (String driver : driversArray) {\n+                driverList.add(driver);\n+            }\n+        }\n+        // initialize the drivers\n+        for (String driverClsName : driverList) {\n+            try {\n+                NamespaceDriver driver =\n+                        ReflectionUtils.newInstance(driverClsName, NamespaceDriver.class);\n+                NamespaceDriverInfo driverInfo = new NamespaceDriverInfo(driver.getClass());\n+                drivers.put(driver.getScheme().toLowerCase(), driverInfo);\n+            } catch (Exception ex) {\n+                logger.warn(\"Failed to load namespace driver {} : \", driverClsName, ex);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Prevent the NamespaceDriverManager class from being instantiated.\n+     */\n+    private NamespaceDriverManager() {}\n+\n+    /**\n+     * Register the namespace {@code driver}.\n+     *\n+     * @param driver the namespace driver\n+     * @return the namespace driver manager\n+     */\n+    public static void registerDriver(String backend, Class<? extends NamespaceDriver> driver) {\n+        if (!initialized) {\n+            initialize();\n+        }\n+\n+        String scheme = backend.toLowerCase();\n+        NamespaceDriverInfo oldDriverInfo = drivers.get(scheme);\n+        if (null != oldDriverInfo) {\n+            return;\n+        }\n+        NamespaceDriverInfo newDriverInfo = new NamespaceDriverInfo(driver);\n+        oldDriverInfo = drivers.putIfAbsent(scheme, newDriverInfo);\n+        if (null != oldDriverInfo) {\n+            logger.debug(\"Driver for {} is already there.\", scheme);\n+        }\n+    }\n+\n+    /**\n+     * Retrieve the namespace driver for {@code scheme}.\n+     *\n+     * @param scheme the scheme for the namespace driver\n+     * @return the namespace driver\n+     * @throws NullPointerException when scheme is null\n+     */\n+    public static NamespaceDriver getDriver(String scheme) {\n+        checkNotNull(scheme, \"Driver Scheme is null\");\n+        if (!initialized) {\n+            initialize();\n+        }\n+        NamespaceDriverInfo driverInfo = drivers.get(scheme.toLowerCase());\n+        if (null == driverInfo) {\n+            throw new IllegalArgumentException(\"Unknown backend \" + scheme);\n+        }\n+        return ReflectionUtils.newInstance(driverInfo.driverClass);\n+    }\n+\n+    /**\n+     * Retrieve the namespace driver for {@code uri}.\n+     *\n+     * @param uri the distributedlog uri\n+     * @return the namespace driver for {@code uri}\n+     * @throws NullPointerException if the distributedlog {@code uri} is null or doesn't have scheme\n+     *          or there is no namespace driver registered for the scheme\n+     * @throws IllegalArgumentException if the distributedlog {@code uri} scheme is illegal\n+     */\n+    public static NamespaceDriver getDriver(URI uri) {\n+        // Validate the uri and load the backend according to scheme\n+        checkNotNull(uri, \"DistributedLog uri is null\");\n+        String scheme = uri.getScheme();\n+        checkNotNull(scheme, \"Invalid distributedlog uri : \" + uri);\n+        scheme = scheme.toLowerCase();\n+        String[] schemeParts = StringUtils.split(scheme, '-');\n+        checkArgument(schemeParts.length > 0,\n+                \"Invalid distributedlog scheme found : \" + uri);\n+        checkArgument(Objects.equal(DistributedLogConstants.SCHEME_PREFIX, schemeParts[0].toLowerCase()),\n+                \"Unknown distributedlog scheme found : \" + uri);\n+        // bookkeeper is the default backend\n+        String backend = DistributedLogConstants.BACKEND_BK;\n+        if (schemeParts.length > 1) {\n+            backend = schemeParts[1];\n+        }\n+        return getDriver(backend);\n+    }\n+\n+}"},{"sha":"456592119e14925b15b40b441b9ce9c21b1d739b","filename":"src/main/java/com/twitter/distributedlog/tools/DistributedLogTool.java","status":"modified","additions":88,"deletions":89,"changes":177,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Ftools%2FDistributedLogTool.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Ftools%2FDistributedLogTool.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Ftools%2FDistributedLogTool.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -30,7 +30,6 @@\n import java.net.MalformedURLException;\n import java.net.URI;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.Enumeration;\n@@ -53,11 +52,16 @@\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n+import com.google.common.base.Preconditions;\n import com.twitter.distributedlog.BKDistributedLogNamespace;\n import com.twitter.distributedlog.Entry;\n+import com.twitter.distributedlog.MetadataAccessor;\n import com.twitter.distributedlog.callback.NamespaceListener;\n+import com.twitter.distributedlog.impl.BKNamespaceDriver;\n import com.twitter.distributedlog.logsegment.LogSegmentMetadataStore;\n import com.twitter.distributedlog.namespace.DistributedLogNamespace;\n+import com.twitter.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import com.twitter.distributedlog.namespace.NamespaceDriver;\n import com.twitter.distributedlog.util.Utils;\n import org.apache.bookkeeper.client.BKException;\n import org.apache.bookkeeper.client.BookKeeper;\n@@ -100,17 +104,15 @@\n import com.twitter.distributedlog.auditor.DLAuditor;\n import com.twitter.distributedlog.bk.LedgerAllocator;\n import com.twitter.distributedlog.bk.LedgerAllocatorUtils;\n-import com.twitter.distributedlog.metadata.BKDLConfig;\n+import com.twitter.distributedlog.impl.metadata.BKDLConfig;\n import com.twitter.distributedlog.metadata.MetadataUpdater;\n import com.twitter.distributedlog.metadata.LogSegmentMetadataStoreUpdater;\n import com.twitter.distributedlog.util.SchedulerUtils;\n import com.twitter.util.Await;\n-import com.twitter.util.Future;\n import com.twitter.util.FutureEventListener;\n \n import static com.google.common.base.Charsets.UTF_8;\n \n-@SuppressWarnings(\"deprecation\")\n public class DistributedLogTool extends Tool {\n \n     static final Logger logger = LoggerFactory.getLogger(DistributedLogTool.class);\n@@ -161,7 +163,7 @@ protected abstract static class PerDLCommand extends OptsCommand {\n         protected URI uri;\n         protected String zkAclId = null;\n         protected boolean force = false;\n-        protected com.twitter.distributedlog.DistributedLogManagerFactory factory = null;\n+        protected DistributedLogNamespace namespace = null;\n \n         protected PerDLCommand(String name, String description) {\n             super(name, description);\n@@ -187,8 +189,8 @@ protected int runCmd(CommandLine commandLine) throws Exception {\n                 return runCmd();\n             } finally {\n                 synchronized (this) {\n-                    if (null != factory) {\n-                        factory.close();\n+                    if (null != namespace) {\n+                        namespace.close();\n                     }\n                 }\n             }\n@@ -252,35 +254,33 @@ protected void setForce(boolean force) {\n             this.force = force;\n         }\n \n-        protected synchronized com.twitter.distributedlog.DistributedLogManagerFactory getFactory() throws IOException {\n-            if (null == this.factory) {\n-                this.factory = new com.twitter.distributedlog.DistributedLogManagerFactory(getConf(), getUri());\n-                logger.info(\"Construct DLM : uri = {}\", getUri());\n-            }\n-            return this.factory;\n-        }\n-\n         protected DistributedLogNamespace getNamespace() throws IOException {\n-            return getFactory().getNamespace();\n+            if (null == this.namespace) {\n+                this.namespace = DistributedLogNamespaceBuilder.newBuilder()\n+                        .uri(getUri())\n+                        .conf(getConf())\n+                        .build();\n+            }\n+            return this.namespace;\n         }\n \n         protected LogSegmentMetadataStore getLogSegmentMetadataStore() throws IOException {\n-            DistributedLogNamespace namespace = getFactory().getNamespace();\n-            assert(namespace instanceof BKDistributedLogNamespace);\n-            return ((BKDistributedLogNamespace) namespace).getWriterStreamMetadataStore()\n+            return getNamespace()\n+                    .getNamespaceDriver()\n+                    .getLogStreamMetadataStore(NamespaceDriver.Role.READER)\n                     .getLogSegmentMetadataStore();\n         }\n \n         protected ZooKeeperClient getZooKeeperClient() throws IOException {\n-            DistributedLogNamespace namespace = getFactory().getNamespace();\n-            assert(namespace instanceof BKDistributedLogNamespace);\n-            return ((BKDistributedLogNamespace) namespace).getSharedWriterZKCForDL();\n+            NamespaceDriver driver = getNamespace().getNamespaceDriver();\n+            assert(driver instanceof BKNamespaceDriver);\n+            return ((BKNamespaceDriver) driver).getWriterZKC();\n         }\n \n         protected BookKeeperClient getBookKeeperClient() throws IOException {\n-            DistributedLogNamespace namespace = getFactory().getNamespace();\n-            assert(namespace instanceof BKDistributedLogNamespace);\n-            return ((BKDistributedLogNamespace) namespace).getReaderBKC();\n+            NamespaceDriver driver = getNamespace().getNamespaceDriver();\n+            assert(driver instanceof BKNamespaceDriver);\n+            return ((BKNamespaceDriver) driver).getReaderBKC();\n         }\n     }\n \n@@ -347,6 +347,10 @@ protected void setStreamName(String streamName) {\n         }\n     }\n \n+    /**\n+     * NOTE: we might consider adding a command to 'delete' namespace. The implementation of the namespace\n+     *       driver should implement the 'delete' operation.\n+     */\n     protected static class DeleteAllocatorPoolCommand extends PerDLCommand {\n \n         int concurrency = 1;\n@@ -380,8 +384,12 @@ protected int runCmd() throws Exception {\n             String rootPath = getUri().getPath() + \"/\" + allocationPoolPath;\n             final ScheduledExecutorService allocationExecutor = Executors.newSingleThreadScheduledExecutor();\n             ExecutorService executorService = Executors.newFixedThreadPool(concurrency);\n+            Preconditions.checkArgument(getNamespace() instanceof BKDistributedLogNamespace);\n+            BKDistributedLogNamespace bkns = (BKDistributedLogNamespace) getNamespace();\n+            final ZooKeeperClient zkc = ((BKNamespaceDriver) bkns.getNamespaceDriver()).getWriterZKC();\n+            final BookKeeperClient bkc = ((BKNamespaceDriver) bkns.getNamespaceDriver()).getReaderBKC();\n             try {\n-                List<String> pools = getZooKeeperClient().get().getChildren(rootPath, false);\n+                List<String> pools = zkc.get().getChildren(rootPath, false);\n                 final LinkedBlockingQueue<String> poolsToDelete = new LinkedBlockingQueue<String>();\n                 if (getForce() || IOUtils.confirmPrompt(\"Are you sure you want to delete allocator pools : \" + pools)) {\n                     for (String pool : pools) {\n@@ -401,7 +409,7 @@ public void run() {\n                                     try {\n                                         LedgerAllocator allocator =\n                                                 LedgerAllocatorUtils.createLedgerAllocatorPool(poolPath, 0, getConf(),\n-                                                        getZooKeeperClient(), getBookKeeperClient(),\n+                                                        zkc, bkc,\n                                                         allocationExecutor);\n                                         allocator.delete();\n                                         System.out.println(\"Deleted allocator pool : \" + poolPath + \" .\");\n@@ -454,43 +462,35 @@ protected String getUsage() {\n \n         @Override\n         protected int runCmd() throws Exception {\n-            if (printMetadata) {\n-                printStreamsWithMetadata(getFactory());\n-            } else {\n-                printStreams(getFactory());\n-            }\n+            printStreams(getNamespace());\n             return 0;\n         }\n \n-        protected void printStreamsWithMetadata(com.twitter.distributedlog.DistributedLogManagerFactory factory)\n-                throws Exception {\n-            Map<String, byte[]> streams = factory.enumerateLogsWithMetadataInNamespace();\n+        protected void printStreams(DistributedLogNamespace namespace) throws Exception {\n+            Iterator<String> streams = namespace.getLogs();\n             System.out.println(\"Streams under \" + getUri() + \" : \");\n             System.out.println(\"--------------------------------\");\n-            for (Map.Entry<String, byte[]> entry : streams.entrySet()) {\n-                println(entry.getKey());\n-                if (null == entry.getValue() || entry.getValue().length == 0) {\n+            while (streams.hasNext()) {\n+                String streamName = streams.next();\n+                System.out.println(streamName);\n+                if (!printMetadata) {\n+                    continue;\n+                }\n+                MetadataAccessor accessor =\n+                        namespace.getNamespaceDriver().getMetadataAccessor(streamName);\n+                byte[] metadata = accessor.getMetadata();\n+                if (null == metadata || metadata.length == 0) {\n                     continue;\n                 }\n                 if (printHex) {\n-                    System.out.println(Hex.encodeHexString(entry.getValue()));\n+                    System.out.println(Hex.encodeHexString(metadata));\n                 } else {\n-                    System.out.println(new String(entry.getValue(), UTF_8));\n+                    System.out.println(new String(metadata, UTF_8));\n                 }\n                 System.out.println(\"\");\n             }\n             System.out.println(\"--------------------------------\");\n         }\n-\n-        protected void printStreams(com.twitter.distributedlog.DistributedLogManagerFactory factory) throws Exception {\n-            Collection<String> streams = factory.enumerateAllLogsInNamespace();\n-            System.out.println(\"Streams under \" + getUri() + \" : \");\n-            System.out.println(\"--------------------------------\");\n-            for (String stream : streams) {\n-                System.out.println(stream);\n-            }\n-            System.out.println(\"--------------------------------\");\n-        }\n     }\n \n     public static class WatchNamespaceCommand extends PerDLCommand implements NamespaceListener {\n@@ -609,16 +609,17 @@ protected int runCmd() throws Exception {\n \n         private void inspectStreams(final SortedMap<String, List<Pair<LogSegmentMetadata, List<String>>>> corruptedCandidates)\n                 throws Exception {\n-            Collection<String> streamCollection = getFactory().enumerateAllLogsInNamespace();\n+            Iterator<String> streamCollection = getNamespace().getLogs();\n             final List<String> streams = new ArrayList<String>();\n-            if (null != streamPrefix) {\n-                for (String s : streamCollection) {\n+            while (streamCollection.hasNext()) {\n+                String s = streamCollection.next();\n+                if (null != streamPrefix) {\n                     if (s.startsWith(streamPrefix)) {\n                         streams.add(s);\n                     }\n+                } else {\n+                    streams.add(s);\n                 }\n-            } else {\n-                streams.addAll(streamCollection);\n             }\n             if (0 == streams.size()) {\n                 return;\n@@ -660,8 +661,7 @@ private void inspectStreams(List<String> streams,\n             for (int i = startIdx; i < endIdx; i++) {\n                 String s = streams.get(i);\n                 BookKeeperClient bkc = getBookKeeperClient();\n-                DistributedLogManager dlm =\n-                        getFactory().createDistributedLogManagerWithSharedClients(s);\n+                DistributedLogManager dlm = getNamespace().openLog(s);\n                 try {\n                     List<LogSegmentMetadata> segments = dlm.getLogSegments();\n                     if (segments.size() <= 1) {\n@@ -782,20 +782,21 @@ protected void setFilter(String filter) {\n         @Override\n         protected int runCmd() throws Exception {\n             getConf().setZkAclId(getZkAclId());\n-            return truncateStreams(getFactory());\n+            return truncateStreams(getNamespace());\n         }\n \n-        private int truncateStreams(final com.twitter.distributedlog.DistributedLogManagerFactory factory) throws Exception {\n-            Collection<String> streamCollection = factory.enumerateAllLogsInNamespace();\n+        private int truncateStreams(final DistributedLogNamespace namespace) throws Exception {\n+            Iterator<String> streamCollection = namespace.getLogs();\n             final List<String> streams = new ArrayList<String>();\n-            if (null != streamPrefix) {\n-                for (String s : streamCollection) {\n+            while (streamCollection.hasNext()) {\n+                String s = streamCollection.next();\n+                if (null != streamPrefix) {\n                     if (s.startsWith(streamPrefix)) {\n                         streams.add(s);\n                     }\n+                } else {\n+                    streams.add(s);\n                 }\n-            } else {\n-                streams.addAll(streamCollection);\n             }\n             if (0 == streams.size()) {\n                 return 0;\n@@ -813,7 +814,7 @@ private int truncateStreams(final com.twitter.distributedlog.DistributedLogManag\n                     @Override\n                     public void run() {\n                         try {\n-                            truncateStreams(factory, streams, tid, numStreamsPerThreads);\n+                            truncateStreams(namespace, streams, tid, numStreamsPerThreads);\n                             System.out.println(\"Thread \" + tid + \" finished.\");\n                         } catch (IOException e) {\n                             System.err.println(\"Thread \" + tid + \" quits with exception : \" + e.getMessage());\n@@ -828,14 +829,13 @@ public void run() {\n             return 0;\n         }\n \n-        private void truncateStreams(com.twitter.distributedlog.DistributedLogManagerFactory factory, List<String> streams,\n+        private void truncateStreams(DistributedLogNamespace namespace, List<String> streams,\n                                      int tid, int numStreamsPerThreads) throws IOException {\n             int startIdx = tid * numStreamsPerThreads;\n             int endIdx = Math.min(streams.size(), (tid + 1) * numStreamsPerThreads);\n             for (int i = startIdx; i < endIdx; i++) {\n                 String s = streams.get(i);\n-                DistributedLogManager dlm =\n-                        factory.createDistributedLogManagerWithSharedClients(s);\n+                DistributedLogManager dlm = namespace.openLog(s);\n                 try {\n                     if (deleteStream) {\n                         dlm.delete();\n@@ -930,7 +930,7 @@ protected void parseCommandLine(CommandLine cmdline) throws ParseException {\n \n         @Override\n         protected int runCmd() throws Exception {\n-            DistributedLogManager dlm = getFactory().createDistributedLogManagerWithSharedClients(getStreamName());\n+            DistributedLogManager dlm = getNamespace().openLog(getStreamName());\n             try {\n                 if (listEppStats) {\n                     bkc = new SimpleBookKeeperClient(getConf(), getUri());\n@@ -1078,7 +1078,7 @@ protected void parseCommandLine(CommandLine cmdline) throws ParseException {\n \n         @Override\n         protected int runCmd() throws Exception {\n-            DistributedLogManager dlm = getFactory().createDistributedLogManagerWithSharedClients(getStreamName());\n+            DistributedLogManager dlm = getNamespace().openLog(getStreamName());\n             try {\n                 long count = 0;\n                 if (null == endDLSN) {\n@@ -1141,7 +1141,7 @@ protected DeleteCommand() {\n         @Override\n         protected int runCmd() throws Exception {\n             getConf().setZkAclId(getZkAclId());\n-            DistributedLogManager dlm = getFactory().createDistributedLogManagerWithSharedClients(getStreamName());\n+            DistributedLogManager dlm = getNamespace().openLog(getStreamName());\n             try {\n                 dlm.delete();\n             } finally {\n@@ -1347,7 +1347,7 @@ protected int runCmd() throws Exception {\n             }\n             getConf().setZkAclId(getZkAclId());\n             for (String stream : streams) {\n-                getFactory().getNamespace().createLog(stream);\n+                getNamespace().createLog(stream);\n             }\n             return 0;\n         }\n@@ -1435,7 +1435,7 @@ protected void parseCommandLine(CommandLine cmdline) throws ParseException {\n \n         @Override\n         protected int runCmd() throws Exception {\n-            DistributedLogManager dlm = getFactory().createDistributedLogManagerWithSharedClients(getStreamName());\n+            DistributedLogManager dlm = getNamespace().openLog(getStreamName());\n             long totalCount = dlm.getLogRecordCount();\n             try {\n                 AsyncLogReader reader;\n@@ -1536,7 +1536,7 @@ static class InspectStreamCommand extends PerStreamCommand {\n \n         @Override\n         protected int runCmd() throws Exception {\n-            DistributedLogManager dlm = getFactory().createDistributedLogManagerWithSharedClients(getStreamName());\n+            DistributedLogManager dlm = getNamespace().openLog(getStreamName());\n             try {\n                 return inspectAndRepair(dlm.getLogSegments());\n             } finally {\n@@ -2640,11 +2640,11 @@ protected void parseCommandLine(CommandLine cmdline) throws ParseException {\n         @Override\n         protected int runCmd() throws Exception {\n             getConf().setZkAclId(getZkAclId());\n-            return truncateStream(getFactory(), getStreamName(), dlsn);\n+            return truncateStream(getNamespace(), getStreamName(), dlsn);\n         }\n \n-        private int truncateStream(final com.twitter.distributedlog.DistributedLogManagerFactory factory, String streamName, DLSN dlsn) throws Exception {\n-            DistributedLogManager dlm = factory.createDistributedLogManagerWithSharedClients(streamName);\n+        private int truncateStream(final DistributedLogNamespace namespace, String streamName, DLSN dlsn) throws Exception {\n+            DistributedLogManager dlm = namespace.openLog(streamName);\n             try {\n                 long totalRecords = dlm.getLogRecordCount();\n                 long recordsAfterTruncate = Await.result(dlm.getLogRecordCountAsync(dlsn));\n@@ -2731,7 +2731,6 @@ public static class DeleteSubscriberCommand extends PerDLCommand {\n         int numThreads = 1;\n         String streamPrefix = null;\n         String subscriberId = null;\n-        AtomicInteger streamIndex = new AtomicInteger();\n \n         DeleteSubscriberCommand() {\n             super(\"delete_subscriber\", \"Delete the subscriber in subscription store. \");\n@@ -2764,20 +2763,21 @@ protected String getUsage() {\n         @Override\n         protected int runCmd() throws Exception {\n             getConf().setZkAclId(getZkAclId());\n-            return deleteSubscriber(getFactory());\n+            return deleteSubscriber(getNamespace());\n         }\n \n-        private int deleteSubscriber(final com.twitter.distributedlog.DistributedLogManagerFactory factory) throws Exception {\n-            Collection<String> streamCollection = factory.enumerateAllLogsInNamespace();\n+        private int deleteSubscriber(final DistributedLogNamespace namespace) throws Exception {\n+            Iterator<String> streamCollection = namespace.getLogs();\n             final List<String> streams = new ArrayList<String>();\n-            if (null != streamPrefix) {\n-                for (String s : streamCollection) {\n+            while (streamCollection.hasNext()) {\n+                String s = streamCollection.next();\n+                if (null != streamPrefix) {\n                     if (s.startsWith(streamPrefix)) {\n                         streams.add(s);\n                     }\n+                } else {\n+                    streams.add(s);\n                 }\n-            } else {\n-                streams.addAll(streamCollection);\n             }\n             if (0 == streams.size()) {\n                 return 0;\n@@ -2796,7 +2796,7 @@ private int deleteSubscriber(final com.twitter.distributedlog.DistributedLogMana\n                     @Override\n                     public void run() {\n                         try {\n-                            deleteSubscriber(factory, streams, tid, numStreamsPerThreads);\n+                            deleteSubscriber(namespace, streams, tid, numStreamsPerThreads);\n                             System.out.println(\"Thread \" + tid + \" finished.\");\n                         } catch (Exception e) {\n                             System.err.println(\"Thread \" + tid + \" quits with exception : \" + e.getMessage());\n@@ -2811,14 +2811,13 @@ public void run() {\n             return 0;\n         }\n \n-        private void deleteSubscriber(com.twitter.distributedlog.DistributedLogManagerFactory factory, List<String> streams,\n+        private void deleteSubscriber(DistributedLogNamespace namespace, List<String> streams,\n                                       int tid, int numStreamsPerThreads) throws Exception {\n             int startIdx = tid * numStreamsPerThreads;\n             int endIdx = Math.min(streams.size(), (tid + 1) * numStreamsPerThreads);\n             for (int i = startIdx; i < endIdx; i++) {\n                 final String s = streams.get(i);\n-                DistributedLogManager dlm =\n-                    factory.createDistributedLogManagerWithSharedClients(s);\n+                DistributedLogManager dlm = namespace.openLog(s);\n                 final CountDownLatch countDownLatch = new CountDownLatch(1);\n                 dlm.getSubscriptionsStore().deleteSubscriber(subscriberId)\n                     .addEventListener(new FutureEventListener<Boolean>() {"},{"sha":"2f9e0919d260c8490ea1e20c0217590bd61a2047","filename":"src/main/java/com/twitter/distributedlog/util/DLUtils.java","status":"modified","additions":109,"deletions":15,"changes":124,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Futil%2FDLUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Futil%2FDLUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Futil%2FDLUtils.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -17,34 +17,27 @@\n  */\n package com.twitter.distributedlog.util;\n \n+import com.google.common.base.Objects;\n+import com.twitter.distributedlog.DistributedLogConstants;\n import com.twitter.distributedlog.LogSegmentMetadata;\n+import com.twitter.distributedlog.exceptions.InvalidStreamNameException;\n import com.twitter.distributedlog.exceptions.UnexpectedException;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n+import org.apache.commons.lang.StringUtils;\n \n+import java.net.InetAddress;\n import java.net.URI;\n+import java.net.URISyntaxException;\n import java.util.List;\n \n import static com.google.common.base.Charsets.UTF_8;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n \n /**\n  * Utilities about DL implementations like uri, log segments, metadata serialization and deserialization.\n  */\n public class DLUtils {\n \n-    static final Logger logger = LoggerFactory.getLogger(DLUtils.class);\n-\n-    /**\n-     * Extract zk servers fro dl <i>uri</i>.\n-     *\n-     * @param uri\n-     *          dl uri\n-     * @return zk servers\n-     */\n-    public static String getZKServersFromDLUri(URI uri) {\n-        return uri.getAuthority().replace(\";\", \",\");\n-    }\n-\n     /**\n      * Find the log segment whose transaction ids are not less than provided <code>transactionId</code>.\n      *\n@@ -224,4 +217,105 @@ public static byte[] logSegmentId2Bytes(long logSegmentId) {\n     public static long bytes2LogSegmentId(byte[] data) {\n         return Long.parseLong(new String(data, UTF_8));\n     }\n+\n+    /**\n+     * Normalize the uri.\n+     *\n+     * @param uri the distributedlog uri.\n+     * @return the normalized uri\n+     */\n+    public static URI normalizeURI(URI uri) {\n+        checkNotNull(uri, \"DistributedLog uri is null\");\n+        String scheme = uri.getScheme();\n+        checkNotNull(scheme, \"Invalid distributedlog uri : \" + uri);\n+        scheme = scheme.toLowerCase();\n+        String[] schemeParts = StringUtils.split(scheme, '-');\n+        checkArgument(Objects.equal(DistributedLogConstants.SCHEME_PREFIX, schemeParts[0].toLowerCase()),\n+                \"Unknown distributedlog scheme found : \" + uri);\n+        URI normalizedUri;\n+        try {\n+            normalizedUri = new URI(\n+                    schemeParts[0],     // remove backend info\n+                    uri.getAuthority(),\n+                    uri.getPath(),\n+                    uri.getQuery(),\n+                    uri.getFragment());\n+        } catch (URISyntaxException e) {\n+            throw new IllegalArgumentException(\"Invalid distributedlog uri found : \" + uri, e);\n+        }\n+        return normalizedUri;\n+    }\n+\n+    private static String getHostIpLockClientId() {\n+        try {\n+            return InetAddress.getLocalHost().toString();\n+        } catch(Exception ex) {\n+            return DistributedLogConstants.UNKNOWN_CLIENT_ID;\n+        }\n+    }\n+\n+    /**\n+     * Normalize the client id.\n+     *\n+     * @return the normalized client id.\n+     */\n+    public static String normalizeClientId(String clientId) {\n+        String normalizedClientId;\n+        if (clientId.equals(DistributedLogConstants.UNKNOWN_CLIENT_ID)) {\n+            normalizedClientId = getHostIpLockClientId();\n+        } else {\n+            normalizedClientId = clientId;\n+        }\n+        return normalizedClientId;\n+    }\n+\n+    /**\n+     * Is it a reserved stream name in bkdl namespace?\n+     *\n+     * @param name\n+     *          stream name\n+     * @return true if it is reserved name, otherwise false.\n+     */\n+    public static boolean isReservedStreamName(String name) {\n+        return name.startsWith(\".\");\n+    }\n+\n+    /**\n+     * Validate the stream name.\n+     *\n+     * @param nameOfStream\n+     *          name of stream\n+     * @throws InvalidStreamNameException\n+     */\n+    public static void validateName(String nameOfStream)\n+            throws InvalidStreamNameException {\n+        String reason = null;\n+        char chars[] = nameOfStream.toCharArray();\n+        char c;\n+        // validate the stream to see if meet zookeeper path's requirement\n+        for (int i = 0; i < chars.length; i++) {\n+            c = chars[i];\n+\n+            if (c == 0) {\n+                reason = \"null character not allowed @\" + i;\n+                break;\n+            } else if (c == '/') {\n+                reason = \"'/' not allowed @\" + i;\n+                break;\n+            } else if (c > '\\u0000' && c < '\\u001f'\n+                    || c > '\\u007f' && c < '\\u009F'\n+                    || c > '\\ud800' && c < '\\uf8ff'\n+                    || c > '\\ufff0' && c < '\\uffff') {\n+                reason = \"invalid charater @\" + i;\n+                break;\n+            }\n+        }\n+        if (null != reason) {\n+            throw new InvalidStreamNameException(nameOfStream, reason);\n+        }\n+        if (isReservedStreamName(nameOfStream)) {\n+            throw new InvalidStreamNameException(nameOfStream,\n+                    \"Stream Name is reserved\");\n+        }\n+    }\n }"},{"sha":"f206a2511c64c7de2ec5068a6943ccbb4d3bb3c6","filename":"src/main/java/com/twitter/distributedlog/util/FutureUtils.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Futil%2FFutureUtils.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Futil%2FFutureUtils.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Fmain%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Futil%2FFutureUtils.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -271,7 +271,7 @@ public static <T> T bkResult(Future<T> result) throws BKException {\n      *\n      * @param throwable the cause of the exception\n      * @return the bk exception return code. if the exception isn't bk exceptions,\n-     *         it would return bk exception code.\n+     *         it would return {@link BKException.Code#UnexpectedConditionException}.\n      */\n     public static int bkResultCode(Throwable throwable) {\n         if (throwable instanceof BKException) {\n@@ -455,13 +455,13 @@ public static <T> boolean setValue(Promise<T> promise, T value) {\n      * @param key submit key of the ordered scheduler\n      */\n     public static <T> void setException(final Promise<T> promise,\n-                                        final Throwable throwable,\n+                                        final Throwable cause,\n                                         OrderedScheduler scheduler,\n                                         Object key) {\n         scheduler.submit(key, new Runnable() {\n             @Override\n             public void run() {\n-                setException(promise, throwable);\n+                setException(promise, cause);\n             }\n         });\n     }"},{"sha":"c403e26552748ffedc755b8691275b73a21d8b47","filename":"src/test/java/com/twitter/distributedlog/DLMTestUtil.java","status":"modified","additions":22,"deletions":98,"changes":120,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDLMTestUtil.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDLMTestUtil.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FDLMTestUtil.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -17,12 +17,12 @@\n  */\n package com.twitter.distributedlog;\n \n+import com.twitter.distributedlog.impl.BKNamespaceDriver;\n import com.twitter.distributedlog.impl.logsegment.BKLogSegmentEntryWriter;\n-import com.twitter.distributedlog.logsegment.LogSegmentFilter;\n-import com.twitter.distributedlog.metadata.BKDLConfig;\n-import com.twitter.distributedlog.metadata.DLMetadata;\n+import com.twitter.distributedlog.logsegment.LogSegmentEntryStore;\n import com.twitter.distributedlog.namespace.DistributedLogNamespace;\n import com.twitter.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import com.twitter.distributedlog.namespace.NamespaceDriver;\n import com.twitter.distributedlog.util.ConfUtils;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.PermitLimiter;\n@@ -35,11 +35,7 @@\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.conf.ServerConfiguration;\n import org.apache.bookkeeper.feature.SettableFeatureProvider;\n-import org.apache.bookkeeper.stats.NullStatsLogger;\n import org.apache.bookkeeper.versioning.Version;\n-import org.apache.zookeeper.CreateMode;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.ZooDefs;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -89,11 +85,6 @@ public static Map<Long, LogSegmentMetadata> readLogSegments(ZooKeeperClient zkc,\n         return segments;\n     }\n \n-    static void updateBKDLConfig(URI uri, String zkServers, String ledgersPath, boolean sanityCheckTxnID) throws Exception {\n-        BKDLConfig bkdlConfig = new BKDLConfig(zkServers, ledgersPath).setSanityCheckTxnID(sanityCheckTxnID);\n-        DLMetadata.create(bkdlConfig).update(uri);\n-    }\n-\n     public static URI createDLMURI(int port, String path) throws Exception {\n         return LocalDLMEmulator.createDLMURI(\"127.0.0.1:\" + port, path);\n     }\n@@ -111,93 +102,18 @@ static MetadataAccessor createNewMetadataAccessor(DistributedLogConfiguration co\n                                                       URI uri) throws Exception {\n         // TODO: Metadata Accessor seems to be a legacy object which only used by kestrel\n         //       (we might consider deprecating this)\n-        BKDistributedLogNamespace namespace = BKDistributedLogNamespace.newBuilder()\n+        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n                 .conf(conf).uri(uri).build();\n-        return namespace.createMetadataAccessor(name);\n-    }\n-\n-    public static class BKLogPartitionWriteHandlerAndClients {\n-        private BKLogWriteHandler writeHandler;\n-        private ZooKeeperClient zooKeeperClient;\n-        private BookKeeperClient bookKeeperClient;\n-\n-        public BKLogPartitionWriteHandlerAndClients(BKLogWriteHandler writeHandler, ZooKeeperClient zooKeeperClient, BookKeeperClient bookKeeperClient) {\n-            this.writeHandler = writeHandler;\n-            this.zooKeeperClient = zooKeeperClient;\n-            this.bookKeeperClient = bookKeeperClient;\n-        }\n-\n-        public void close() {\n-            bookKeeperClient.close();\n-            zooKeeperClient.close();\n-            Utils.closeQuietly(writeHandler);\n-        }\n-\n-        public BKLogWriteHandler getWriteHandler() {\n-            return writeHandler;\n-        }\n-    }\n-\n-    static BKLogPartitionWriteHandlerAndClients createNewBKDLM(DistributedLogConfiguration conf,\n-                                                               String logName,\n-                                                               int zkPort) throws Exception {\n-        URI uri = createDLMURI(zkPort, \"/\" + logName);\n-\n-        ZooKeeperClientBuilder zkcBuilder = TestZooKeeperClientBuilder.newBuilder(conf)\n-            .name(String.format(\"dlzk:%s:handler_dedicated\", logName))\n-            .uri(uri);\n-\n-        ZooKeeperClient zkClient = zkcBuilder.build();\n-\n-        try {\n-            zkClient.get().create(uri.getPath(), new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-        } catch (KeeperException.NodeExistsException nee) {\n-            // ignore\n-        }\n-\n-        // resolve uri\n-        BKDLConfig bkdlConfig = BKDLConfig.resolveDLConfig(zkClient, uri);\n-        BKDLConfig.propagateConfiguration(bkdlConfig, conf);\n-        BookKeeperClientBuilder bkcBuilder = BookKeeperClientBuilder.newBuilder()\n-            .dlConfig(conf)\n-            .name(String.format(\"bk:%s:handler_dedicated\", logName))\n-            .zkServers(bkdlConfig.getBkZkServersForWriter())\n-            .ledgersPath(bkdlConfig.getBkLedgersPath())\n-            .statsLogger(NullStatsLogger.INSTANCE);\n-\n-        BKDistributedLogManager bkdlm = new BKDistributedLogManager(\n-                logName,\n-                conf,\n-                uri,\n-                zkcBuilder,\n-                zkcBuilder,\n-                zkClient,\n-                zkClient,\n-                bkcBuilder,\n-                bkcBuilder,\n-                new SettableFeatureProvider(\"\", 0),\n-                PermitLimiter.NULL_PERMIT_LIMITER,\n-                NullStatsLogger.INSTANCE);\n-\n-        BKLogWriteHandler writeHandler = bkdlm.createWriteHandler(true);\n-        return new BKLogPartitionWriteHandlerAndClients(writeHandler, zkClient, bkcBuilder.build());\n+        return namespace.getNamespaceDriver().getMetadataAccessor(name);\n     }\n \n     public static void fenceStream(DistributedLogConfiguration conf, URI uri, String name) throws Exception {\n-        BKDistributedLogManager dlm = (BKDistributedLogManager) createNewDLM(name, conf, uri);\n+        DistributedLogManager dlm = createNewDLM(name, conf, uri);\n         try {\n-            BKLogReadHandler readHandler = dlm.createReadHandler();\n-            List<LogSegmentMetadata> ledgerList = FutureUtils.result(\n-                    readHandler.readLogSegmentsFromStore(\n-                            LogSegmentMetadata.COMPARATOR,\n-                            LogSegmentFilter.DEFAULT_FILTER,\n-                            null)\n-            ).getValue();\n-            LogSegmentMetadata lastSegment = ledgerList.get(ledgerList.size() - 1);\n-            BookKeeperClient bkc = dlm.getWriterBKC();\n-            LedgerHandle lh = bkc.get().openLedger(lastSegment.getLogSegmentId(),\n-                    BookKeeper.DigestType.CRC32, conf.getBKDigestPW().getBytes(UTF_8));\n-            lh.close();\n+            List<LogSegmentMetadata> logSegmentList = dlm.getLogSegments();\n+            LogSegmentMetadata lastSegment = logSegmentList.get(logSegmentList.size() - 1);\n+            LogSegmentEntryStore entryStore = dlm.getNamespaceDriver().getLogSegmentEntryStore(NamespaceDriver.Role.READER);\n+            Utils.close(FutureUtils.result(entryStore.openRandomAccessReader(lastSegment, true)));\n         } finally {\n             dlm.close();\n         }\n@@ -409,6 +325,14 @@ public static long generateLogSegmentNonPartitioned(DistributedLogManager dlm, i\n         return txid - startTxid;\n     }\n \n+    public static ZooKeeperClient getZooKeeperClient(BKDistributedLogManager dlm) {\n+        return ((BKNamespaceDriver) dlm.getNamespaceDriver()).getWriterZKC();\n+    }\n+\n+    public static BookKeeperClient getBookKeeperClient(BKDistributedLogManager dlm) {\n+        return ((BKNamespaceDriver) dlm.getNamespaceDriver()).getReaderBKC();\n+    }\n+\n     public static void injectLogSegmentWithGivenLogSegmentSeqNo(DistributedLogManager manager, DistributedLogConfiguration conf,\n                                                                 long logSegmentSeqNo, long startTxID, boolean writeEntries, long segmentSize,\n                                                                 boolean completeLogSegment)\n@@ -417,7 +341,7 @@ public static void injectLogSegmentWithGivenLogSegmentSeqNo(DistributedLogManage\n         BKLogWriteHandler writeHandler = dlm.createWriteHandler(false);\n         FutureUtils.result(writeHandler.lockHandler());\n         // Start a log segment with a given ledger seq number.\n-        BookKeeperClient bkc = dlm.getWriterBKC();\n+        BookKeeperClient bkc = getBookKeeperClient(dlm);\n         LedgerHandle lh = bkc.get().createLedger(conf.getEnsembleSize(), conf.getWriteQuorumSize(),\n                 conf.getAckQuorumSize(), BookKeeper.DigestType.CRC32, conf.getBKDigestPW().getBytes());\n         String inprogressZnodeName = writeHandler.inprogressZNodeName(lh.getId(), startTxID, logSegmentSeqNo);\n@@ -429,7 +353,7 @@ public static void injectLogSegmentWithGivenLogSegmentSeqNo(DistributedLogManage\n                 .setLogSegmentSequenceNo(logSegmentSeqNo)\n                 .setEnvelopeEntries(LogSegmentMetadata.supportsEnvelopedEntries(logSegmentMetadataVersion))\n                 .build();\n-        l.write(dlm.writerZKC);\n+        l.write(getZooKeeperClient(dlm));\n         writeHandler.maxTxId.update(Version.ANY, startTxID);\n         writeHandler.addLogSegmentToCache(inprogressZnodeName, l);\n         BKLogSegmentWriter writer = new BKLogSegmentWriter(\n@@ -468,7 +392,7 @@ public static void injectLogSegmentWithLastDLSN(DistributedLogManager manager, D\n         BKLogWriteHandler writeHandler = dlm.createWriteHandler(false);\n         FutureUtils.result(writeHandler.lockHandler());\n         // Start a log segment with a given ledger seq number.\n-        BookKeeperClient bkc = dlm.getReaderBKC();\n+        BookKeeperClient bkc = getBookKeeperClient(dlm);\n         LedgerHandle lh = bkc.get().createLedger(conf.getEnsembleSize(), conf.getWriteQuorumSize(),\n                 conf.getAckQuorumSize(), BookKeeper.DigestType.CRC32, conf.getBKDigestPW().getBytes());\n         String inprogressZnodeName = writeHandler.inprogressZNodeName(lh.getId(), startTxID, logSegmentSeqNo);\n@@ -479,7 +403,7 @@ public static void injectLogSegmentWithLastDLSN(DistributedLogManager manager, D\n             .setLogSegmentSequenceNo(logSegmentSeqNo)\n             .setInprogress(false)\n             .build();\n-        l.write(dlm.writerZKC);\n+        l.write(getZooKeeperClient(dlm));\n         writeHandler.maxTxId.update(Version.ANY, startTxID);\n         writeHandler.addLogSegmentToCache(inprogressZnodeName, l);\n         BKLogSegmentWriter writer = new BKLogSegmentWriter("},{"sha":"124ea77f2c91a25e16d56cbee270561ab7cda81f","filename":"src/test/java/com/twitter/distributedlog/TestAsyncReaderLock.java","status":"modified","additions":24,"deletions":5,"changes":29,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderLock.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderLock.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderLock.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -29,9 +29,11 @@\n import com.twitter.distributedlog.exceptions.LockCancelledException;\n import com.twitter.distributedlog.exceptions.LockingException;\n import com.twitter.distributedlog.exceptions.OwnershipAcquireFailedException;\n+import com.twitter.distributedlog.impl.BKNamespaceDriver;\n import com.twitter.distributedlog.lock.LockClosedException;\n import com.twitter.distributedlog.namespace.DistributedLogNamespace;\n import com.twitter.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import com.twitter.distributedlog.namespace.NamespaceDriver;\n import com.twitter.distributedlog.subscription.SubscriptionsStore;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.Utils;\n@@ -85,7 +87,8 @@ public void testReaderLockIfLockPathDoesntExist() throws Exception {\n         Utils.close(reader1);\n \n         // simulate a old stream created without readlock path\n-        writer.bkDistributedLogManager.getWriterZKC().get().delete(readLockPath, -1);\n+        NamespaceDriver driver = dlm.getNamespaceDriver();\n+        ((BKNamespaceDriver) driver).getWriterZKC().get().delete(readLockPath, -1);\n         Future<AsyncLogReader> futureReader2 = dlm.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n         AsyncLogReader reader2 = Await.result(futureReader2);\n         record = Await.result(reader2.readNext());\n@@ -230,7 +233,7 @@ public void testReaderLockDlmClosed() throws Exception {\n \n         DistributedLogManager dlm1 = createNewDLM(conf, name);\n         Future<AsyncLogReader> futureReader1 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n-        Await.result(futureReader1);\n+        AsyncLogReader reader1 = Await.result(futureReader1);\n \n         BKDistributedLogManager dlm2 = (BKDistributedLogManager) createNewDLM(conf, name);\n         Future<AsyncLogReader> futureReader2 = dlm2.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n@@ -243,23 +246,34 @@ public void testReaderLockDlmClosed() throws Exception {\n         } catch (LockCancelledException ex) {\n         }\n \n+        Utils.close(reader1);\n         dlm0.close();\n         dlm1.close();\n     }\n \n     @Test(timeout = 60000)\n     public void testReaderLockSessionExpires() throws Exception {\n         String name = runtime.getMethodName();\n-        DistributedLogManager dlm0 = createNewDLM(conf, name);\n+        URI uri = createDLMURI(\"/\" + name);\n+        ensureURICreated(uri);\n+        DistributedLogNamespace ns0 = DistributedLogNamespaceBuilder.newBuilder()\n+                .conf(conf)\n+                .uri(uri)\n+                .build();\n+        DistributedLogManager dlm0 = ns0.openLog(name);\n         BKAsyncLogWriter writer = (BKAsyncLogWriter)(dlm0.startAsyncLogSegmentNonPartitioned());\n         writer.write(DLMTestUtil.getLogRecordInstance(1L));\n         writer.write(DLMTestUtil.getLogRecordInstance(2L));\n         writer.closeAndComplete();\n \n-        DistributedLogManager dlm1 = createNewDLM(conf, name);\n+        DistributedLogNamespace ns1 = DistributedLogNamespaceBuilder.newBuilder()\n+                .conf(conf)\n+                .uri(uri)\n+                .build();\n+        DistributedLogManager dlm1 = ns1.openLog(name);\n         Future<AsyncLogReader> futureReader1 = dlm1.getAsyncLogReaderWithLock(DLSN.InitialDLSN);\n         AsyncLogReader reader1 = Await.result(futureReader1);\n-        ZooKeeperClientUtils.expireSession(((BKDistributedLogManager)dlm1).getWriterZKC(), zkServers, 1000);\n+        ZooKeeperClientUtils.expireSession(((BKNamespaceDriver) ns1.getNamespaceDriver()).getWriterZKC(), zkServers, 1000);\n \n         // The result of expireSession is somewhat non-deterministic with this lock.\n         // It may fail with LockingException or it may succesfully reacquire, so for\n@@ -276,7 +290,9 @@ public void testReaderLockSessionExpires() throws Exception {\n \n         Utils.close(reader1);\n         dlm0.close();\n+        ns0.close();\n         dlm1.close();\n+        ns1.close();\n     }\n \n     @Test(timeout = 60000)\n@@ -511,8 +527,11 @@ public void testReaderLockMultiReadersScenario() throws Exception {\n         Utils.close(Await.result(futureReader3));\n \n         dlm1.close();\n+        namespace1.close();\n         dlm2.close();\n+        namespace2.close();\n         dlm3.close();\n+        namespace3.close();\n \n         executorService.shutdown();\n     }"},{"sha":"46c85232d3a7e23d631739abf4e40ed3a09c6562","filename":"src/test/java/com/twitter/distributedlog/TestAsyncReaderWriter.java","status":"modified","additions":10,"deletions":4,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestAsyncReaderWriter.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -36,6 +36,7 @@\n import com.twitter.distributedlog.config.DynamicDistributedLogConfiguration;\n import com.twitter.distributedlog.exceptions.BKTransmitException;\n import com.twitter.distributedlog.exceptions.LockingException;\n+import com.twitter.distributedlog.impl.BKNamespaceDriver;\n import com.twitter.distributedlog.io.CompressionCodec;\n import com.twitter.distributedlog.util.Utils;\n import com.twitter.util.Promise;\n@@ -1270,8 +1271,9 @@ public void testCloseAndCompleteLogSegmentWhenStreamIsInError() throws Exception\n \n         BKLogSegmentWriter logWriter = writer.getCachedLogWriter();\n \n+        BKNamespaceDriver driver = (BKNamespaceDriver) dlm.getNamespaceDriver();\n         // fence the ledger\n-        dlm.getWriterBKC().get().openLedger(logWriter.getLogSegmentId(),\n+        driver.getReaderBKC().get().openLedger(logWriter.getLogSegmentId(),\n                 BookKeeper.DigestType.CRC32, confLocal.getBKDigestPW().getBytes(UTF_8));\n \n         try {\n@@ -1313,8 +1315,9 @@ public void testCloseAndCompleteLogSegmentWhenCloseFailed() throws Exception {\n \n         BKLogSegmentWriter logWriter = writer.getCachedLogWriter();\n \n+        BKNamespaceDriver driver = (BKNamespaceDriver) dlm.getNamespaceDriver();\n         // fence the ledger\n-        dlm.getWriterBKC().get().openLedger(logWriter.getLogSegmentId(),\n+        driver.getReaderBKC().get().openLedger(logWriter.getLogSegmentId(),\n                 BookKeeper.DigestType.CRC32, confLocal.getBKDigestPW().getBytes(UTF_8));\n \n         try {\n@@ -1500,6 +1503,7 @@ public void testAsyncReadMissingLogSegmentsNotification() throws Exception {\n         confLocal.setImmediateFlushEnabled(true);\n         confLocal.setReadAheadBatchSize(1);\n         confLocal.setReadAheadMaxRecords(1);\n+        confLocal.setReadLACLongPollTimeout(49);\n         confLocal.setReaderIdleWarnThresholdMillis(100);\n         confLocal.setReaderIdleErrorThresholdMillis(20000);\n         final DistributedLogManager dlm = createNewDLM(confLocal, name);\n@@ -1976,7 +1980,7 @@ public void testCreateLogStreamWithDifferentReplicationFactor() throws Exception\n         List<LogSegmentMetadata> segments = dlm.getLogSegments();\n         assertEquals(1, segments.size());\n         long ledgerId = segments.get(0).getLogSegmentId();\n-        LedgerHandle lh = ((BKDistributedLogNamespace) namespace).getReaderBKC()\n+        LedgerHandle lh = ((BKNamespaceDriver) namespace.getNamespaceDriver()).getReaderBKC()\n                 .get().openLedgerNoRecovery(ledgerId, BookKeeper.DigestType.CRC32, confLocal.getBKDigestPW().getBytes(UTF_8));\n         LedgerMetadata metadata = BookKeeperAccessor.getLedgerMetadata(lh);\n         assertEquals(DistributedLogConfiguration.BKDL_BOOKKEEPER_ENSEMBLE_SIZE_DEFAULT, metadata.getEnsembleSize());\n@@ -1995,7 +1999,7 @@ public void testCreateLogStreamWithDifferentReplicationFactor() throws Exception\n         segments = dlm.getLogSegments();\n         assertEquals(1, segments.size());\n         ledgerId = segments.get(0).getLogSegmentId();\n-        lh = ((BKDistributedLogNamespace) namespace).getReaderBKC()\n+        lh = ((BKNamespaceDriver) namespace.getNamespaceDriver()).getReaderBKC()\n                 .get().openLedgerNoRecovery(ledgerId, BookKeeper.DigestType.CRC32, confLocal.getBKDigestPW().getBytes(UTF_8));\n         metadata = BookKeeperAccessor.getLedgerMetadata(lh);\n         assertEquals(DistributedLogConfiguration.BKDL_BOOKKEEPER_ENSEMBLE_SIZE_DEFAULT - 1, metadata.getEnsembleSize());\n@@ -2147,6 +2151,7 @@ public void testIdleReaderExceptionWhenKeepAliveIsDisabled() throws Exception {\n         confLocal.setImmediateFlushEnabled(false);\n         confLocal.setPeriodicFlushFrequencyMilliSeconds(0);\n         confLocal.setPeriodicKeepAliveMilliSeconds(0);\n+        confLocal.setReadLACLongPollTimeout(9);\n         confLocal.setReaderIdleWarnThresholdMillis(20);\n         confLocal.setReaderIdleErrorThresholdMillis(40);\n \n@@ -2178,6 +2183,7 @@ public void testIdleReaderExceptionWhenKeepAliveIsEnabled() throws Exception {\n         confLocal.setImmediateFlushEnabled(false);\n         confLocal.setPeriodicFlushFrequencyMilliSeconds(0);\n         confLocal.setPeriodicKeepAliveMilliSeconds(1000);\n+        confLocal.setReadLACLongPollTimeout(999);\n         confLocal.setReaderIdleWarnThresholdMillis(2000);\n         confLocal.setReaderIdleErrorThresholdMillis(4000);\n "},{"sha":"f7d587d5b4168aee1262cf1179dd97a7c04f677f","filename":"src/test/java/com/twitter/distributedlog/TestBKDistributedLogManager.java","status":"modified","additions":26,"deletions":73,"changes":99,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKDistributedLogManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKDistributedLogManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKDistributedLogManager.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -22,6 +22,7 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.Random;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -32,6 +33,7 @@\n import com.twitter.distributedlog.exceptions.LogNotFoundException;\n import com.twitter.distributedlog.exceptions.LogReadException;\n import com.twitter.distributedlog.impl.ZKLogSegmentMetadataStore;\n+import com.twitter.distributedlog.io.Abortables;\n import com.twitter.distributedlog.logsegment.LogSegmentMetadataStore;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.OrderedScheduler;\n@@ -48,14 +50,12 @@\n import com.twitter.distributedlog.exceptions.EndOfStreamException;\n import com.twitter.distributedlog.exceptions.InvalidStreamNameException;\n import com.twitter.distributedlog.exceptions.LogRecordTooLongException;\n-import com.twitter.distributedlog.exceptions.OwnershipAcquireFailedException;\n import com.twitter.distributedlog.exceptions.TransactionIdOutOfOrderException;\n import com.twitter.distributedlog.metadata.LogMetadata;\n import com.twitter.distributedlog.metadata.MetadataUpdater;\n import com.twitter.distributedlog.metadata.LogSegmentMetadataStoreUpdater;\n import com.twitter.distributedlog.namespace.DistributedLogNamespace;\n import com.twitter.distributedlog.namespace.DistributedLogNamespaceBuilder;\n-import com.twitter.distributedlog.subscription.SubscriptionStateStore;\n import com.twitter.distributedlog.subscription.SubscriptionsStore;\n import com.twitter.util.Await;\n import com.twitter.util.Duration;\n@@ -67,6 +67,8 @@\n public class TestBKDistributedLogManager extends TestDistributedLogBase {\n     static final Logger LOG = LoggerFactory.getLogger(TestBKDistributedLogManager.class);\n \n+    private static final Random RAND = new Random(System.currentTimeMillis());\n+\n     @Rule\n     public TestName testNames = new TestName();\n \n@@ -253,20 +255,6 @@ public void testWriteRestartFrom1() throws Exception {\n         dlm.close();\n     }\n \n-    @Test(timeout = 60000)\n-    public void testTwoWriters() throws Exception {\n-        DLMTestUtil.BKLogPartitionWriteHandlerAndClients bkdlm1 =\n-                createNewBKDLM(conf, \"distrlog-dualWriter\");\n-        try {\n-             createNewBKDLM(conf, \"distrlog-dualWriter\");\n-            fail(\"Shouldn't have been able to open the second writer\");\n-        } catch (OwnershipAcquireFailedException ioe) {\n-            assertEquals(ioe.getCurrentOwner(), DistributedLogConstants.UNKNOWN_CLIENT_ID);\n-        }\n-\n-        bkdlm1.close();\n-    }\n-\n     @Test(timeout = 60000)\n     public void testTwoWritersOnLockDisabled() throws Exception {\n         DistributedLogConfiguration confLocal = new DistributedLogConfiguration();\n@@ -468,11 +456,10 @@ public void testCheckLogExists() throws Exception {\n         writer.setReadyToFlush();\n         writer.flushAndSync();\n         writer.close();\n-        dlm.createOrUpdateMetadata(name.getBytes());\n-        assertEquals(name, new String(dlm.getMetadata()));\n+        dlm.close();\n \n         URI uri = createDLMURI(\"/\" + name);\n-        BKDistributedLogNamespace namespace = BKDistributedLogNamespace.newBuilder()\n+        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n                 .conf(conf).uri(uri).build();\n         assertTrue(namespace.logExists(name));\n         assertFalse(namespace.logExists(\"non-existent-log\"));\n@@ -490,9 +477,7 @@ public void testCheckLogExists() throws Exception {\n         }\n         assertEquals(1, logCount);\n \n-        for(Map.Entry<String, byte[]> logEntry: namespace.enumerateLogsWithMetadataInNamespace().entrySet()) {\n-            assertEquals(name, new String(logEntry.getValue()));\n-        }\n+        namespace.close();\n     }\n \n     @Test(timeout = 60000)\n@@ -506,28 +491,6 @@ public void testMetadataAccessor() throws Exception {\n         assertEquals(null, metadata.getMetadata());\n     }\n \n-    @Test(timeout = 60000)\n-    @Deprecated\n-    public void testSubscriptionStateStore() throws Exception {\n-        String name = \"distrlog-subscription-state\";\n-        String subscriberId = \"defaultSubscriber\";\n-        DLSN commitPosition0 = new DLSN(4, 33, 5);\n-        DLSN commitPosition1 = new DLSN(4, 34, 5);\n-        DLSN commitPosition2 = new DLSN(5, 34, 5);\n-\n-        DistributedLogManager dlm = createNewDLM(conf, name);\n-        SubscriptionStateStore store = dlm.getSubscriptionStateStore(subscriberId);\n-        assertEquals(Await.result(store.getLastCommitPosition()), DLSN.NonInclusiveLowerBound);\n-        Await.result(store.advanceCommitPosition(commitPosition1));\n-        assertEquals(Await.result(store.getLastCommitPosition()), commitPosition1);\n-        Await.result(store.advanceCommitPosition(commitPosition0));\n-        assertEquals(Await.result(store.getLastCommitPosition()), commitPosition1);\n-        Await.result(store.advanceCommitPosition(commitPosition2));\n-        assertEquals(Await.result(store.getLastCommitPosition()), commitPosition2);\n-        SubscriptionStateStore store1 = dlm.getSubscriptionStateStore(subscriberId);\n-        assertEquals(Await.result(store1.getLastCommitPosition()), commitPosition2);\n-    }\n-\n     @Test(timeout = 60000)\n     public void testSubscriptionsStore() throws Exception {\n         String name = \"distrlog-subscriptions-store\";\n@@ -732,50 +695,40 @@ private void markEndOfStreamOnEmptyLogSegment(int numCompletedSegments) throws E\n         reader.close();\n     }\n \n-    @Test(timeout = 60000)\n+    @Test(timeout = 60000, expected = LogRecordTooLongException.class)\n     public void testMaxLogRecSize() throws Exception {\n-        DLMTestUtil.BKLogPartitionWriteHandlerAndClients bkdlmAndClients =\n-                createNewBKDLM(conf, \"distrlog-maxlogRecSize\");\n-        long txid = 1;\n-        BKLogSegmentWriter out = bkdlmAndClients.getWriteHandler().startLogSegment(1);\n-        boolean exceptionEncountered = false;\n-        try {\n-            LogRecord op = new LogRecord(txid, DLMTestUtil.repeatString(\n-                                DLMTestUtil.repeatString(\"abcdefgh\", 256), 512).getBytes());\n-            out.write(op);\n-        } catch (LogRecordTooLongException exc) {\n-            exceptionEncountered = true;\n-        } finally {\n-            FutureUtils.result(out.asyncClose());\n-        }\n-        bkdlmAndClients.close();\n-        assertTrue(exceptionEncountered);\n+        DistributedLogManager dlm = createNewDLM(conf, \"distrlog-maxlogRecSize\");\n+        AsyncLogWriter writer = FutureUtils.result(dlm.openAsyncLogWriter());\n+        FutureUtils.result(writer.write(new LogRecord(1L, DLMTestUtil.repeatString(\n+                                DLMTestUtil.repeatString(\"abcdefgh\", 256), 512).getBytes())));\n     }\n \n     @Test(timeout = 60000)\n     public void testMaxTransmissionSize() throws Exception {\n         DistributedLogConfiguration confLocal = new DistributedLogConfiguration();\n         confLocal.loadConf(conf);\n         confLocal.setOutputBufferSize(1024 * 1024);\n-        DLMTestUtil.BKLogPartitionWriteHandlerAndClients bkdlmAndClients =\n-                createNewBKDLM(confLocal, \"distrlog-transmissionSize\");\n-        long txid = 1;\n-        BKLogSegmentWriter out = bkdlmAndClients.getWriteHandler().startLogSegment(1);\n+        BKDistributedLogManager dlm =\n+                createNewDLM(confLocal, \"distrlog-transmissionSize\");\n+        AsyncLogWriter out = FutureUtils.result(dlm.openAsyncLogWriter());\n         boolean exceptionEncountered = false;\n-        byte[] largePayload = DLMTestUtil.repeatString(DLMTestUtil.repeatString(\"abcdefgh\", 256), 256).getBytes();\n+        byte[] largePayload = new byte[(LogRecord.MAX_LOGRECORDSET_SIZE / 2) + 2];\n+        RAND.nextBytes(largePayload);\n         try {\n-            while (txid < 3) {\n-                LogRecord op = new LogRecord(txid, largePayload);\n-                out.write(op);\n-                txid++;\n-            }\n+            LogRecord op = new LogRecord(1L, largePayload);\n+            Future<DLSN> firstWriteFuture = out.write(op);\n+            op = new LogRecord(2L, largePayload);\n+            // the second write will flush the first one, since we reached the maximum transmission size.\n+            out.write(op);\n+            FutureUtils.result(firstWriteFuture);\n         } catch (LogRecordTooLongException exc) {\n             exceptionEncountered = true;\n         } finally {\n             FutureUtils.result(out.asyncClose());\n         }\n-        bkdlmAndClients.close();\n-        assertTrue(!exceptionEncountered);\n+        assertFalse(exceptionEncountered);\n+        Abortables.abortQuietly(out);\n+        dlm.close();\n     }\n \n     @Test(timeout = 60000)"},{"sha":"a8a82fa25f0ef07823d06665ffbc3f2c66c7117f","filename":"src/test/java/com/twitter/distributedlog/TestBKDistributedLogNamespace.java","status":"modified","additions":7,"deletions":61,"changes":68,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKDistributedLogNamespace.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKDistributedLogNamespace.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKDistributedLogNamespace.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -34,9 +34,10 @@\n import com.twitter.distributedlog.exceptions.InvalidStreamNameException;\n import com.twitter.distributedlog.exceptions.LockingException;\n import com.twitter.distributedlog.exceptions.ZKException;\n-import com.twitter.distributedlog.impl.BKDLUtils;\n+import com.twitter.distributedlog.impl.BKNamespaceDriver;\n import com.twitter.distributedlog.namespace.DistributedLogNamespace;\n import com.twitter.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import com.twitter.distributedlog.util.DLUtils;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.KeeperException;\n import org.apache.zookeeper.ZooDefs;\n@@ -111,64 +112,14 @@ public void testCreateIfNotExists() throws Exception {\n         newDLM.close();\n     }\n \n-    @Test(timeout = 60000)\n-    @SuppressWarnings(\"deprecation\")\n-    public void testClientSharingOptions() throws Exception {\n-        URI uri = createDLMURI(\"/clientSharingOptions\");\n-        BKDistributedLogNamespace namespace = BKDistributedLogNamespace.newBuilder()\n-                .conf(conf).uri(uri).build();\n-\n-        {\n-            BKDistributedLogManager bkdlm1 = (BKDistributedLogManager)namespace.createDistributedLogManager(\"perstream1\",\n-                                        DistributedLogManagerFactory.ClientSharingOption.PerStreamClients);\n-\n-            BKDistributedLogManager bkdlm2 = (BKDistributedLogManager)namespace.createDistributedLogManager(\"perstream2\",\n-                DistributedLogManagerFactory.ClientSharingOption.PerStreamClients);\n-\n-            assertThat(bkdlm1.getReaderBKC(), not(bkdlm2.getReaderBKC()));\n-            assertThat(bkdlm1.getWriterBKC(), not(bkdlm2.getWriterBKC()));\n-            assertThat(bkdlm1.getReaderZKC(), not(bkdlm2.getReaderZKC()));\n-            assertThat(bkdlm1.getWriterZKC(), not(bkdlm2.getWriterZKC()));\n-\n-        }\n-\n-        {\n-            BKDistributedLogManager bkdlm1 = (BKDistributedLogManager)namespace.createDistributedLogManager(\"sharedZK1\",\n-                DistributedLogManagerFactory.ClientSharingOption.SharedZKClientPerStreamBKClient);\n-\n-            BKDistributedLogManager bkdlm2 = (BKDistributedLogManager)namespace.createDistributedLogManager(\"sharedZK2\",\n-                DistributedLogManagerFactory.ClientSharingOption.SharedZKClientPerStreamBKClient);\n-\n-            assertThat(bkdlm1.getReaderBKC(), not(bkdlm2.getReaderBKC()));\n-            assertThat(bkdlm1.getWriterBKC(), not(bkdlm2.getWriterBKC()));\n-            assertEquals(bkdlm1.getReaderZKC(), bkdlm2.getReaderZKC());\n-            assertEquals(bkdlm1.getWriterZKC(), bkdlm2.getWriterZKC());\n-        }\n-\n-        {\n-            BKDistributedLogManager bkdlm1 = (BKDistributedLogManager)namespace.createDistributedLogManager(\"sharedBoth1\",\n-                DistributedLogManagerFactory.ClientSharingOption.SharedClients);\n-\n-            BKDistributedLogManager bkdlm2 = (BKDistributedLogManager)namespace.createDistributedLogManager(\"sharedBoth2\",\n-                DistributedLogManagerFactory.ClientSharingOption.SharedClients);\n-\n-            assertEquals(bkdlm1.getReaderBKC(), bkdlm2.getReaderBKC());\n-            assertEquals(bkdlm1.getWriterBKC(), bkdlm2.getWriterBKC());\n-            assertEquals(bkdlm1.getReaderZKC(), bkdlm2.getReaderZKC());\n-            assertEquals(bkdlm1.getWriterZKC(), bkdlm2.getWriterZKC());\n-        }\n-\n-    }\n-\n-\n     @Test(timeout = 60000)\n     public void testInvalidStreamName() throws Exception {\n-        assertFalse(BKDLUtils.isReservedStreamName(\"test\"));\n-        assertTrue(BKDLUtils.isReservedStreamName(\".test\"));\n+        assertFalse(DLUtils.isReservedStreamName(\"test\"));\n+        assertTrue(DLUtils.isReservedStreamName(\".test\"));\n \n         URI uri = createDLMURI(\"/\" + runtime.getMethodName());\n \n-        BKDistributedLogNamespace namespace = BKDistributedLogNamespace.newBuilder()\n+        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n                 .conf(conf).uri(uri).build();\n \n         try {\n@@ -238,11 +189,6 @@ public void testInvalidStreamName() throws Exception {\n         assertTrue(streamSet.contains(\"test1\"));\n         assertTrue(streamSet.contains(\"test_2-3\"));\n \n-        Map<String, byte[]> streamMetadatas = namespace.enumerateLogsWithMetadataInNamespace();\n-        assertEquals(2, streamMetadatas.size());\n-        assertTrue(streamMetadatas.containsKey(\"test1\"));\n-        assertTrue(streamMetadatas.containsKey(\"test_2-3\"));\n-\n         namespace.close();\n     }\n \n@@ -385,7 +331,7 @@ public void testAclModifyPermsDlmNoConflict() throws Exception {\n \n     static void validateBadAllocatorConfiguration(DistributedLogConfiguration conf, URI uri) throws Exception {\n         try {\n-            BKDistributedLogNamespace.validateAndGetFullLedgerAllocatorPoolPath(conf, uri);\n+            BKNamespaceDriver.validateAndGetFullLedgerAllocatorPoolPath(conf, uri);\n             fail(\"Should throw exception when bad allocator configuration provided\");\n         } catch (IOException ioe) {\n             // expected\n@@ -425,7 +371,7 @@ public void testValidateAndGetFullLedgerAllocatorPoolPath() throws Exception {\n     @Test(timeout = 60000)\n     public void testUseNamespaceAfterCloseShouldFailFast() throws Exception {\n         URI uri = createDLMURI(\"/\" + runtime.getMethodName());\n-        BKDistributedLogNamespace namespace = BKDistributedLogNamespace.newBuilder()\n+        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n             .conf(conf)\n             .uri(uri)\n             .build();"},{"sha":"854cb745d99770befd8069bf4db145b4cb72601a","filename":"src/test/java/com/twitter/distributedlog/TestBKLogReadHandler.java","status":"modified","additions":1,"deletions":22,"changes":23,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKLogReadHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKLogReadHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKLogReadHandler.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -50,27 +50,6 @@ public class TestBKLogReadHandler extends TestDistributedLogBase {\n     @Rule\n     public TestName runtime = new TestName();\n \n-    private void prepareLogSegments(String name, int numSegments, int numEntriesPerSegment) throws Exception {\n-        DLMTestUtil.BKLogPartitionWriteHandlerAndClients bkdlmAndClients = createNewBKDLM(conf, name);\n-        long txid = 1;\n-        for (int sid = 0; sid < numSegments; ++sid) {\n-            BKLogSegmentWriter out = bkdlmAndClients.getWriteHandler().startLogSegment(txid);\n-            for (int eid = 0; eid < numEntriesPerSegment; ++eid) {\n-                LogRecord record = DLMTestUtil.getLargeLogRecordInstance(txid);\n-                out.write(record);\n-                ++txid;\n-            }\n-            FutureUtils.result(out.asyncClose());\n-            bkdlmAndClients.getWriteHandler().completeAndCloseLogSegment(\n-                    out.getLogSegmentSequenceNumber(),\n-                    out.getLogSegmentId(),\n-                    1 + sid * numEntriesPerSegment,\n-                    (sid + 1) * numEntriesPerSegment,\n-                    numEntriesPerSegment);\n-        }\n-        bkdlmAndClients.close();\n-    }\n-\n     private void prepareLogSegmentsNonPartitioned(String name, int numSegments, int numEntriesPerSegment) throws Exception {\n         DistributedLogManager dlm = createNewDLM(conf, name);\n         long txid = 1;\n@@ -134,8 +113,8 @@ public void testGetFirstDLSNNoLogSegments() throws Exception {\n     @Test(timeout = 60000)\n     public void testGetFirstDLSNWithLogSegments() throws Exception {\n         String dlName = runtime.getMethodName();\n-        prepareLogSegments(dlName, 3, 3);\n         BKDistributedLogManager dlm = createNewDLM(conf, dlName);\n+        DLMTestUtil.generateCompletedLogSegments(dlm, conf, 3, 3);\n         BKLogReadHandler readHandler = dlm.createReadHandler();\n         Future<LogRecordWithDLSN> futureRecord = readHandler.asyncGetFirstLogRecord();\n         try {"},{"sha":"8f861923aa6349d8704edac8265e7d34a35c56ae","filename":"src/test/java/com/twitter/distributedlog/TestBKLogSegmentWriter.java","status":"modified","additions":3,"deletions":3,"changes":6,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKLogSegmentWriter.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKLogSegmentWriter.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKLogSegmentWriter.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -21,14 +21,14 @@\n import com.twitter.distributedlog.exceptions.EndOfStreamException;\n import com.twitter.distributedlog.exceptions.WriteCancelledException;\n import com.twitter.distributedlog.exceptions.WriteException;\n+import com.twitter.distributedlog.impl.BKNamespaceDriver;\n import com.twitter.distributedlog.impl.logsegment.BKLogSegmentEntryWriter;\n import com.twitter.distributedlog.io.Abortables;\n import com.twitter.distributedlog.lock.SessionLockFactory;\n import com.twitter.distributedlog.lock.ZKDistributedLock;\n import com.twitter.distributedlog.lock.ZKSessionLockFactory;\n-import com.twitter.distributedlog.metadata.BKDLConfig;\n+import com.twitter.distributedlog.impl.metadata.BKDLConfig;\n import com.twitter.distributedlog.util.ConfUtils;\n-import com.twitter.distributedlog.util.DLUtils;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.OrderedScheduler;\n import com.twitter.distributedlog.util.PermitLimiter;\n@@ -96,7 +96,7 @@ public void setup() throws Exception {\n                 .dlConfig(conf)\n                 .name(\"test-bkc\")\n                 .ledgersPath(bkdlConfig.getBkLedgersPath())\n-                .zkServers(DLUtils.getZKServersFromDLUri(uri))\n+                .zkServers(BKNamespaceDriver.getZKServersFromDLUri(uri))\n                 .build();\n     }\n "},{"sha":"a0485bde9313025c02d8353df745342d4c11415e","filename":"src/test/java/com/twitter/distributedlog/TestBKLogWriteHandler.java","status":"modified","additions":3,"deletions":1,"changes":4,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKLogWriteHandler.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKLogWriteHandler.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestBKLogWriteHandler.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -19,6 +19,7 @@\n \n import com.twitter.distributedlog.bk.LedgerAllocator;\n import com.twitter.distributedlog.bk.LedgerAllocatorPool;\n+import com.twitter.distributedlog.impl.BKNamespaceDriver;\n import com.twitter.distributedlog.namespace.DistributedLogNamespaceBuilder;\n import com.twitter.distributedlog.util.FailpointUtils;\n import com.twitter.distributedlog.util.FutureUtils;\n@@ -75,7 +76,8 @@ public void testAbortTransactionOnStartLogSegment() throws Exception {\n                     FailpointUtils.FailPointName.FP_StartLogSegmentOnAssignLogSegmentSequenceNumber);\n         }\n \n-        LedgerAllocator allocator = namespace.getLedgerAllocator();\n+        LedgerAllocator allocator = ((BKNamespaceDriver) namespace.getNamespaceDriver())\n+                .getLedgerAllocator();\n         assertTrue(allocator instanceof LedgerAllocatorPool);\n         LedgerAllocatorPool allocatorPool = (LedgerAllocatorPool) allocator;\n         assertEquals(0, allocatorPool.obtainMapSize());"},{"sha":"d850db40e0d609fc94618c42e94cb2f316b49b4e","filename":"src/test/java/com/twitter/distributedlog/TestDistributedLogBase.java","status":"modified","additions":72,"deletions":45,"changes":117,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestDistributedLogBase.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestDistributedLogBase.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestDistributedLogBase.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -19,11 +19,24 @@\n \n import static org.junit.Assert.assertTrue;\n \n+import com.google.common.base.Optional;\n+import com.google.common.base.Ticker;\n+import com.twitter.distributedlog.impl.BKNamespaceDriver;\n import com.twitter.distributedlog.impl.logsegment.BKLogSegmentEntryWriter;\n+import com.twitter.distributedlog.injector.AsyncFailureInjector;\n+import com.twitter.distributedlog.injector.AsyncRandomFailureInjector;\n+import com.twitter.distributedlog.io.AsyncCloseable;\n import com.twitter.distributedlog.logsegment.LogSegmentEntryWriter;\n+import com.twitter.distributedlog.logsegment.LogSegmentMetadataCache;\n import com.twitter.distributedlog.logsegment.LogSegmentMetadataStore;\n import com.twitter.distributedlog.namespace.DistributedLogNamespace;\n+import com.twitter.distributedlog.namespace.DistributedLogNamespaceBuilder;\n+import com.twitter.distributedlog.namespace.NamespaceDriver;\n+import com.twitter.distributedlog.util.ConfUtils;\n+import com.twitter.distributedlog.util.OrderedScheduler;\n import com.twitter.distributedlog.util.PermitLimiter;\n+import com.twitter.distributedlog.util.SchedulerUtils;\n+import com.twitter.util.Future;\n import org.apache.bookkeeper.client.LedgerHandle;\n import org.apache.bookkeeper.feature.SettableFeatureProvider;\n import org.apache.bookkeeper.shims.zk.ZooKeeperServerShim;\n@@ -43,9 +56,11 @@\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.IOException;\n import java.net.URI;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.concurrent.TimeUnit;\n \n public class TestDistributedLogBase {\n     static final Logger LOG = LoggerFactory.getLogger(TestDistributedLogBase.class);\n@@ -87,6 +102,12 @@ public static void setupCluster() throws Exception {\n                 .build();\n         bkutil.start();\n         zkServers = \"127.0.0.1:\" + zkPort;\n+        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n+            @Override\n+            public void uncaughtException(Thread t, Throwable e) {\n+                LOG.warn(\"Uncaught exception at Thread {} : \", t.getName(), e);\n+            }\n+        });\n     }\n \n     @AfterClass\n@@ -141,22 +162,7 @@ protected void ensureURICreated(ZooKeeper zkc, URI uri) throws Exception {\n \n     public BKDistributedLogManager createNewDLM(DistributedLogConfiguration conf,\n                                                 String name) throws Exception {\n-        URI uri = createDLMURI(\"/\" + name);\n-        ensureURICreated(uri);\n-        return new BKDistributedLogManager(\n-                name,\n-                conf,\n-                uri,\n-                null,\n-                null,\n-                null,\n-                null,\n-                null,\n-                null,\n-                new SettableFeatureProvider(\"\", 0),\n-                PermitLimiter.NULL_PERMIT_LIMITER,\n-                NullStatsLogger.INSTANCE\n-        );\n+        return createNewDLM(conf, name, PermitLimiter.NULL_PERMIT_LIMITER);\n     }\n \n     public BKDistributedLogManager createNewDLM(DistributedLogConfiguration conf,\n@@ -165,48 +171,69 @@ public BKDistributedLogManager createNewDLM(DistributedLogConfiguration conf,\n             throws Exception {\n         URI uri = createDLMURI(\"/\" + name);\n         ensureURICreated(uri);\n+        final DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+                .uri(uri)\n+                .conf(conf)\n+                .build();\n+        final OrderedScheduler scheduler = OrderedScheduler.newBuilder()\n+                .corePoolSize(1)\n+                .name(\"test-scheduler\")\n+                .build();\n+        AsyncCloseable resourcesCloseable = new AsyncCloseable() {\n+            @Override\n+            public Future<Void> asyncClose() {\n+                LOG.info(\"Shutting down the scheduler\");\n+                SchedulerUtils.shutdownScheduler(scheduler, 1, TimeUnit.SECONDS);\n+                LOG.info(\"Shut down the scheduler\");\n+                LOG.info(\"Closing the namespace\");\n+                namespace.close();\n+                LOG.info(\"Closed the namespace\");\n+                return Future.Void();\n+            }\n+        };\n+        AsyncFailureInjector failureInjector = AsyncRandomFailureInjector.newBuilder()\n+                .injectDelays(conf.getEIInjectReadAheadDelay(),\n+                        conf.getEIInjectReadAheadDelayPercent(),\n+                        conf.getEIInjectMaxReadAheadDelayMs())\n+                .injectErrors(false, 10)\n+                .injectStops(conf.getEIInjectReadAheadStall(), 10)\n+                .injectCorruption(conf.getEIInjectReadAheadBrokenEntries())\n+                .build();\n         return new BKDistributedLogManager(\n                 name,\n                 conf,\n+                ConfUtils.getConstDynConf(conf),\n                 uri,\n-                null,\n-                null,\n-                null,\n-                null,\n-                null,\n-                null,\n-                new SettableFeatureProvider(\"\", 0),\n+                namespace.getNamespaceDriver(),\n+                new LogSegmentMetadataCache(conf, Ticker.systemTicker()),\n+                scheduler,\n+                DistributedLogConstants.UNKNOWN_CLIENT_ID,\n+                DistributedLogConstants.LOCAL_REGION_ID,\n                 writeLimiter,\n-                NullStatsLogger.INSTANCE\n-        );\n-    }\n-\n-    public DLMTestUtil.BKLogPartitionWriteHandlerAndClients createNewBKDLM(\n-            DistributedLogConfiguration conf,\n-            String path) throws Exception {\n-        return DLMTestUtil.createNewBKDLM(conf, path, zkPort);\n+                new SettableFeatureProvider(\"\", 0),\n+                failureInjector,\n+                NullStatsLogger.INSTANCE,\n+                NullStatsLogger.INSTANCE,\n+                Optional.of(resourcesCloseable));\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    protected LogSegmentMetadataStore getLogSegmentMetadataStore(DistributedLogManagerFactory factory) {\n-        DistributedLogNamespace namespace = factory.getNamespace();\n-        assertTrue(namespace instanceof BKDistributedLogNamespace);\n-        return ((BKDistributedLogNamespace) namespace).getWriterStreamMetadataStore()\n+    protected LogSegmentMetadataStore getLogSegmentMetadataStore(DistributedLogNamespace namespace)\n+            throws IOException {\n+        return namespace.getNamespaceDriver().getLogStreamMetadataStore(NamespaceDriver.Role.READER)\n                 .getLogSegmentMetadataStore();\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    protected ZooKeeperClient getZooKeeperClient(DistributedLogManagerFactory factory) throws Exception {\n-        DistributedLogNamespace namespace = factory.getNamespace();\n-        assertTrue(namespace instanceof BKDistributedLogNamespace);\n-        return ((BKDistributedLogNamespace) namespace).getSharedWriterZKCForDL();\n+    protected ZooKeeperClient getZooKeeperClient(DistributedLogNamespace namespace) throws Exception {\n+        NamespaceDriver driver = namespace.getNamespaceDriver();\n+        assertTrue(driver instanceof BKNamespaceDriver);\n+        return ((BKNamespaceDriver) driver).getWriterZKC();\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    protected BookKeeperClient getBookKeeperClient(DistributedLogManagerFactory factory) throws Exception {\n-        DistributedLogNamespace namespace = factory.getNamespace();\n-        assertTrue(namespace instanceof BKDistributedLogNamespace);\n-        return ((BKDistributedLogNamespace) namespace).getReaderBKC();\n+    protected BookKeeperClient getBookKeeperClient(DistributedLogNamespace namespace) throws Exception {\n+        NamespaceDriver driver = namespace.getNamespaceDriver();\n+        assertTrue(driver instanceof BKNamespaceDriver);\n+        return ((BKNamespaceDriver) driver).getReaderBKC();\n     }\n \n     protected LedgerHandle getLedgerHandle(BKLogSegmentWriter segmentWriter) {"},{"sha":"e86e45a45fe1d99a96d9d7ee75e27a6d6b2c071d","filename":"src/test/java/com/twitter/distributedlog/TestFailureAndRecovery.java","status":"removed","additions":0,"deletions":257,"changes":257,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/a83b233a79300c0bf1b3dcac0a24fef628ad48f8/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestFailureAndRecovery.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/a83b233a79300c0bf1b3dcac0a24fef628ad48f8/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestFailureAndRecovery.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestFailureAndRecovery.java?ref=a83b233a79300c0bf1b3dcac0a24fef628ad48f8","patch":"@@ -1,257 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package com.twitter.distributedlog;\n-\n-import com.twitter.distributedlog.exceptions.BKTransmitException;\n-import com.twitter.distributedlog.io.Abortables;\n-import com.twitter.distributedlog.util.FutureUtils;\n-import org.apache.bookkeeper.client.BKException;\n-import org.apache.bookkeeper.proto.BookieServer;\n-import org.apache.commons.logging.Log;\n-import org.apache.commons.logging.LogFactory;\n-import org.junit.Test;\n-\n-import static org.junit.Assert.*;\n-\n-public class TestFailureAndRecovery extends TestDistributedLogBase {\n-    static final Log LOG = LogFactory.getLog(TestFailureAndRecovery.class);\n-\n-    @Test(timeout = 60000)\n-    public void testSimpleRecovery() throws Exception {\n-        DLMTestUtil.BKLogPartitionWriteHandlerAndClients bkdlmAndClients = createNewBKDLM(conf, \"distrlog-simplerecovery\");\n-        BKLogSegmentWriter out = bkdlmAndClients.getWriteHandler().startLogSegment(1);\n-        long txid = 1;\n-        for (long i = 1; i <= 100; i++) {\n-            LogRecord op = DLMTestUtil.getLogRecordInstance(txid++);\n-            out.write(op);\n-            if ((i % 10) == 0) {\n-                FutureUtils.result(out.flushAndCommit());\n-            }\n-\n-        }\n-        FutureUtils.result(out.flushAndCommit());\n-\n-        Abortables.abort(out, false);\n-        FutureUtils.result(out.asyncClose());\n-\n-        assertNull(zkc.exists(bkdlmAndClients.getWriteHandler().completedLedgerZNode(1, 100, out.getLogSegmentSequenceNumber()), false));\n-        assertNotNull(zkc.exists(bkdlmAndClients.getWriteHandler().inprogressZNode(out.getLogSegmentId(), 1, out.getLogSegmentSequenceNumber()), false));\n-\n-        FutureUtils.result(bkdlmAndClients.getWriteHandler().recoverIncompleteLogSegments());\n-\n-        assertNotNull(zkc.exists(bkdlmAndClients.getWriteHandler().completedLedgerZNode(1, 100, out.getLogSegmentSequenceNumber()), false));\n-        assertNull(zkc.exists(bkdlmAndClients.getWriteHandler().inprogressZNode(out.getLogSegmentId(), 1, out.getLogSegmentSequenceNumber()), false));\n-    }\n-\n-    /**\n-     * Test that if enough bookies fail to prevent an ensemble,\n-     * writes the bookkeeper will fail. Test that when once again\n-     * an ensemble is available, it can continue to write.\n-     */\n-    @Test(timeout = 60000)\n-    public void testAllBookieFailure() throws Exception {\n-        BookieServer bookieToFail = bkutil.newBookie();\n-        BookieServer replacementBookie = null;\n-\n-        try {\n-            int ensembleSize = numBookies + 1;\n-            assertEquals(\"Begin: New bookie didn't start\",\n-                ensembleSize, bkutil.checkBookiesUp(ensembleSize, 10));\n-\n-            // ensure that the journal manager has to use all bookies,\n-            // so that a failure will fail the journal manager\n-            DistributedLogConfiguration conf = new DistributedLogConfiguration();\n-            conf.setEnsembleSize(ensembleSize);\n-            conf.setWriteQuorumSize(ensembleSize);\n-            conf.setAckQuorumSize(ensembleSize);\n-            long txid = 1;\n-            DLMTestUtil.BKLogPartitionWriteHandlerAndClients bkdlmAndClients = createNewBKDLM(conf, \"distrlog-allbookiefailure\");\n-            BKLogSegmentWriter out = bkdlmAndClients.getWriteHandler().startLogSegment(txid);\n-\n-            for (long i = 1; i <= 3; i++) {\n-                LogRecord op = DLMTestUtil.getLogRecordInstance(txid++);\n-                out.write(op);\n-            }\n-            FutureUtils.result(out.flushAndCommit());\n-            bookieToFail.shutdown();\n-            assertEquals(\"New bookie didn't die\",\n-                numBookies, bkutil.checkBookiesUp(numBookies, 10));\n-\n-            try {\n-                for (long i = 1; i <= 3; i++) {\n-                    LogRecord op = DLMTestUtil.getLogRecordInstance(txid++);\n-                    out.write(op);\n-                    txid++;\n-                }\n-                FutureUtils.result(out.flushAndCommit());\n-                fail(\"should not get to this stage\");\n-            } catch (BKTransmitException bkte) {\n-                LOG.debug(\"Error writing to bookkeeper\", bkte);\n-                assertEquals(\"Invalid exception message\",\n-                        BKException.Code.NotEnoughBookiesException, bkte.getBKResultCode());\n-            }\n-            replacementBookie = bkutil.newBookie();\n-\n-            assertEquals(\"Replacement: New bookie didn't start\",\n-                numBookies + 1, bkutil.checkBookiesUp(numBookies + 1, 10));\n-            out = bkdlmAndClients.getWriteHandler().startLogSegment(txid);\n-            for (long i = 1; i <= 3; i++) {\n-                LogRecord op = DLMTestUtil.getLogRecordInstance(txid++);\n-                out.write(op);\n-            }\n-\n-            FutureUtils.result(out.flushAndCommit());\n-        } catch (Exception e) {\n-            LOG.error(\"Exception in test\", e);\n-            throw e;\n-        } finally {\n-            if (replacementBookie != null) {\n-                replacementBookie.shutdown();\n-            }\n-            bookieToFail.shutdown();\n-\n-            if (bkutil.checkBookiesUp(numBookies, 30) != numBookies) {\n-                LOG.warn(\"Not all bookies from this test shut down, expect errors\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Test that a BookKeeper JM can continue to work across the\n-     * failure of a bookie. This should be handled transparently\n-     * by bookkeeper.\n-     */\n-    @Test(timeout = 60000)\n-    public void testOneBookieFailure() throws Exception {\n-        BookieServer bookieToFail = bkutil.newBookie();\n-        BookieServer replacementBookie = null;\n-\n-        try {\n-            int ensembleSize = numBookies + 1;\n-            assertEquals(\"New bookie didn't start\",\n-                ensembleSize, bkutil.checkBookiesUp(ensembleSize, 10));\n-\n-            // ensure that the journal manager has to use all bookies,\n-            // so that a failure will fail the journal manager\n-            DistributedLogConfiguration conf = new DistributedLogConfiguration();\n-            conf.setEnsembleSize(ensembleSize);\n-            conf.setWriteQuorumSize(ensembleSize);\n-            conf.setAckQuorumSize(ensembleSize);\n-            long txid = 1;\n-            DLMTestUtil.BKLogPartitionWriteHandlerAndClients bkdlmAndClients = createNewBKDLM(conf, \"distrlog-onebookiefailure\");\n-            BKLogSegmentWriter out = bkdlmAndClients.getWriteHandler().startLogSegment(txid);\n-            for (long i = 1; i <= 3; i++) {\n-                LogRecord op = DLMTestUtil.getLogRecordInstance(txid++);\n-                out.write(op);\n-            }\n-            FutureUtils.result(out.flushAndCommit());\n-\n-            replacementBookie = bkutil.newBookie();\n-            assertEquals(\"replacement bookie didn't start\",\n-                ensembleSize + 1, bkutil.checkBookiesUp(ensembleSize + 1, 10));\n-            bookieToFail.shutdown();\n-            assertEquals(\"New bookie didn't die\",\n-                ensembleSize, bkutil.checkBookiesUp(ensembleSize, 10));\n-\n-            for (long i = 1; i <= 3; i++) {\n-                LogRecord op = DLMTestUtil.getLogRecordInstance(txid++);\n-                out.write(op);\n-            }\n-            FutureUtils.result(out.flushAndCommit());\n-        } catch (Exception e) {\n-            LOG.error(\"Exception in test\", e);\n-            throw e;\n-        } finally {\n-            if (replacementBookie != null) {\n-                replacementBookie.shutdown();\n-            }\n-            bookieToFail.shutdown();\n-\n-            if (bkutil.checkBookiesUp(numBookies, 30) != numBookies) {\n-                LOG.warn(\"Not all bookies from this test shut down, expect errors\");\n-            }\n-        }\n-    }\n-\n-    @Test(timeout = 60000)\n-    public void testRecoveryEmptyLedger() throws Exception {\n-        DLMTestUtil.BKLogPartitionWriteHandlerAndClients bkdlmAndClients = createNewBKDLM(conf, \"distrlog-recovery-empty-ledger\");\n-        BKLogSegmentWriter out = bkdlmAndClients.getWriteHandler().startLogSegment(1);\n-        long txid = 1;\n-        for (long i = 1; i <= 100; i++) {\n-            LogRecord op = DLMTestUtil.getLogRecordInstance(txid++);\n-            out.write(op);\n-            if ((i % 10) == 0) {\n-                FutureUtils.result(out.flushAndCommit());\n-            }\n-\n-        }\n-        FutureUtils.result(out.flushAndCommit());\n-        FutureUtils.result(out.asyncClose());\n-        bkdlmAndClients.getWriteHandler().completeAndCloseLogSegment(out.getLogSegmentSequenceNumber(), out.getLogSegmentId(), 1, 100, 100);\n-        assertNotNull(zkc.exists(bkdlmAndClients.getWriteHandler().completedLedgerZNode(1, 100, out.getLogSegmentSequenceNumber()), false));\n-        BKLogSegmentWriter outEmpty = bkdlmAndClients.getWriteHandler().startLogSegment(101);\n-        Abortables.abort(outEmpty, false);\n-\n-        assertNull(zkc.exists(bkdlmAndClients.getWriteHandler().completedLedgerZNode(101, 101, outEmpty.getLogSegmentSequenceNumber()), false));\n-        assertNotNull(zkc.exists(bkdlmAndClients.getWriteHandler().inprogressZNode(outEmpty.getLogSegmentId(), 101, outEmpty.getLogSegmentSequenceNumber()), false));\n-\n-        FutureUtils.result(bkdlmAndClients.getWriteHandler().recoverIncompleteLogSegments());\n-\n-        assertNull(zkc.exists(bkdlmAndClients.getWriteHandler().inprogressZNode(outEmpty.getLogSegmentId(), outEmpty.getLogSegmentSequenceNumber(), 101), false));\n-        assertNotNull(zkc.exists(bkdlmAndClients.getWriteHandler().completedLedgerZNode(101, 101, outEmpty.getLogSegmentSequenceNumber()), false));\n-    }\n-\n-    @Test(timeout = 60000)\n-    public void testRecoveryAPI() throws Exception {\n-        DistributedLogManager dlm = createNewDLM(conf, \"distrlog-recovery-api\");\n-        BKSyncLogWriter out = (BKSyncLogWriter) dlm.startLogSegmentNonPartitioned();\n-        long txid = 1;\n-        for (long i = 1; i <= 100; i++) {\n-            LogRecord op = DLMTestUtil.getLogRecordInstance(txid++);\n-            out.write(op);\n-            if ((i % 10) == 0) {\n-                out.setReadyToFlush();\n-                out.flushAndSync();\n-            }\n-\n-        }\n-        BKLogSegmentWriter perStreamLogWriter = out.getCachedLogWriter();\n-        out.setReadyToFlush();\n-        out.flushAndSync();\n-\n-        out.abort();\n-\n-        BKLogWriteHandler blplm1 = ((BKDistributedLogManager) (dlm)).createWriteHandler(true);\n-\n-        assertNull(zkc.exists(blplm1.completedLedgerZNode(1, 100,\n-                                                          perStreamLogWriter.getLogSegmentSequenceNumber()), false));\n-        assertNotNull(zkc.exists(blplm1.inprogressZNode(perStreamLogWriter.getLogSegmentId(), 1,\n-                                                        perStreamLogWriter.getLogSegmentSequenceNumber()), false));\n-\n-        dlm.recover();\n-\n-        assertNotNull(zkc.exists(blplm1.completedLedgerZNode(1, 100,\n-                                                             perStreamLogWriter.getLogSegmentSequenceNumber()), false));\n-        assertNull(zkc.exists(blplm1.inprogressZNode(perStreamLogWriter.getLogSegmentId(), 1,\n-                                                     perStreamLogWriter.getLogSegmentSequenceNumber()), false));\n-        FutureUtils.result(blplm1.asyncClose());\n-        assertEquals(100, dlm.getLogRecordCount());\n-        dlm.close();\n-    }\n-}"},{"sha":"830e0596c69855426fbfa5062e82902c982dd81a","filename":"src/test/java/com/twitter/distributedlog/TestInterleavedReaders.java","status":"modified","additions":0,"deletions":70,"changes":70,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestInterleavedReaders.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestInterleavedReaders.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestInterleavedReaders.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -22,8 +22,6 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.net.URI;\n-\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n \n@@ -337,72 +335,4 @@ public void testInterleavedReadersWithRollingEdgeUnPartitioned() throws Exceptio\n         dlmreader1.close();\n     }\n \n-    @Test(timeout = 60000)\n-    public void testFactorySharedClients() throws Exception {\n-        String name = \"distrlog-factorysharedclients\";\n-        testFactory(name, true);\n-    }\n-\n-    @Test(timeout = 60000)\n-    public void testFactorySharedZK() throws Exception {\n-        String name = \"distrlog-factorysharedZK\";\n-        testFactory(name, false);\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    private void testFactory(String name, boolean shareBK) throws Exception {\n-        int count = 3;\n-        URI uri = createDLMURI(\"/\" + name);\n-        ensureURICreated(uri);\n-        BKDistributedLogNamespace namespace = BKDistributedLogNamespace.newBuilder()\n-                .conf(conf).uri(uri).build();\n-        DistributedLogManager[] dlms = new DistributedLogManager[count];\n-        for (int s = 0; s < count; s++) {\n-            if (shareBK) {\n-                dlms[s] = namespace.createDistributedLogManager(name + String.format(\"%d\", s),\n-                        DistributedLogManagerFactory.ClientSharingOption.SharedClients);\n-            } else {\n-                dlms[s] = namespace.createDistributedLogManager(name + String.format(\"%d\", s),\n-                        DistributedLogManagerFactory.ClientSharingOption.SharedZKClientPerStreamBKClient);\n-            }\n-        }\n-\n-        int txid = 1;\n-        for (long i = 0; i < 3; i++) {\n-            BKSyncLogWriter[] writers = new BKSyncLogWriter[count];\n-            for (int s = 0; s < count; s++) {\n-                writers[s] = (BKSyncLogWriter)(dlms[s].startLogSegmentNonPartitioned());\n-            }\n-\n-            for (long j = 0; j < 1; j++) {\n-                final LogRecord record = DLMTestUtil.getLargeLogRecordInstance(txid++);\n-                for (int s = 0; s < count; s++) {\n-                    writers[s].write(record);\n-                }\n-            }\n-            for (int s = 0; s < count; s++) {\n-                writers[s].closeAndComplete();\n-            }\n-\n-            if (i < 2) {\n-                // Restart the zeroth stream and make sure that the other streams can\n-                // continue without restart\n-                dlms[0].close();\n-                if (shareBK) {\n-                    dlms[0] = namespace.createDistributedLogManager(name + String.format(\"%d\", 0),\n-                            DistributedLogManagerFactory.ClientSharingOption.SharedClients);\n-                } else {\n-                    dlms[0] = namespace.createDistributedLogManager(name + String.format(\"%d\", 0),\n-                            DistributedLogManagerFactory.ClientSharingOption.SharedZKClientPerStreamBKClient);\n-                }\n-            }\n-\n-        }\n-\n-        for (int s = 0; s < count; s++) {\n-            dlms[s].close();\n-        }\n-\n-        namespace.close();\n-    }\n }"},{"sha":"06c7bbacc2a1091575abebd6c6fb6caf9c371204","filename":"src/test/java/com/twitter/distributedlog/TestLogSegmentsZK.java","status":"modified","additions":12,"deletions":12,"changes":24,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestLogSegmentsZK.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestLogSegmentsZK.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestLogSegmentsZK.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -80,10 +80,10 @@ public void testCreateLogSegmentOnPrecreatedStream() throws Exception {\n                 .setImmediateFlushEnabled(true)\n                 .setEnableLedgerAllocatorPool(true)\n                 .setLedgerAllocatorPoolName(\"test\");\n-        BKDistributedLogNamespace namespace = BKDistributedLogNamespace.newBuilder().conf(conf).uri(uri).build();\n+        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder().conf(conf).uri(uri).build();\n \n         namespace.createLog(streamName);\n-        MaxLogSegmentSequenceNo max1 = getMaxLogSegmentSequenceNo(namespace.getSharedWriterZKCForDL(), uri, streamName, conf);\n+        MaxLogSegmentSequenceNo max1 = getMaxLogSegmentSequenceNo(getZooKeeperClient(namespace), uri, streamName, conf);\n         assertEquals(DistributedLogConstants.UNASSIGNED_LOGSEGMENT_SEQNO, max1.getSequenceNumber());\n         DistributedLogManager dlm = namespace.openLog(streamName);\n         final int numSegments = 3;\n@@ -92,7 +92,7 @@ public void testCreateLogSegmentOnPrecreatedStream() throws Exception {\n             out.write(DLMTestUtil.getLogRecordInstance(i));\n             out.closeAndComplete();\n         }\n-        MaxLogSegmentSequenceNo max2 = getMaxLogSegmentSequenceNo(namespace.getSharedWriterZKCForDL(), uri, streamName, conf);\n+        MaxLogSegmentSequenceNo max2 = getMaxLogSegmentSequenceNo(getZooKeeperClient(namespace), uri, streamName, conf);\n         assertEquals(3, max2.getSequenceNumber());\n         dlm.close();\n         namespace.close();\n@@ -111,10 +111,10 @@ public void testCreateLogSegmentMissingMaxSequenceNumber() throws Exception {\n                 .setImmediateFlushEnabled(true)\n                 .setEnableLedgerAllocatorPool(true)\n                 .setLedgerAllocatorPoolName(\"test\");\n-        BKDistributedLogNamespace namespace = BKDistributedLogNamespace.newBuilder().conf(conf).uri(uri).build();\n+        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder().conf(conf).uri(uri).build();\n \n         namespace.createLog(streamName);\n-        MaxLogSegmentSequenceNo max1 = getMaxLogSegmentSequenceNo(namespace.getSharedWriterZKCForDL(), uri, streamName, conf);\n+        MaxLogSegmentSequenceNo max1 = getMaxLogSegmentSequenceNo(getZooKeeperClient(namespace), uri, streamName, conf);\n         assertEquals(DistributedLogConstants.UNASSIGNED_LOGSEGMENT_SEQNO, max1.getSequenceNumber());\n         DistributedLogManager dlm = namespace.openLog(streamName);\n         final int numSegments = 3;\n@@ -123,11 +123,11 @@ public void testCreateLogSegmentMissingMaxSequenceNumber() throws Exception {\n             out.write(DLMTestUtil.getLogRecordInstance(i));\n             out.closeAndComplete();\n         }\n-        MaxLogSegmentSequenceNo max2 = getMaxLogSegmentSequenceNo(namespace.getSharedWriterZKCForDL(), uri, streamName, conf);\n+        MaxLogSegmentSequenceNo max2 = getMaxLogSegmentSequenceNo(getZooKeeperClient(namespace), uri, streamName, conf);\n         assertEquals(3, max2.getSequenceNumber());\n \n         // nuke the max ledger sequence number\n-        updateMaxLogSegmentSequenceNo(namespace.getSharedWriterZKCForDL(), uri, streamName, conf, new byte[0]);\n+        updateMaxLogSegmentSequenceNo(getZooKeeperClient(namespace), uri, streamName, conf, new byte[0]);\n         DistributedLogManager dlm1 = namespace.openLog(streamName);\n         try {\n             dlm1.startLogSegmentNonPartitioned();\n@@ -139,7 +139,7 @@ public void testCreateLogSegmentMissingMaxSequenceNumber() throws Exception {\n         }\n \n         // invalid max ledger sequence number\n-        updateMaxLogSegmentSequenceNo(namespace.getSharedWriterZKCForDL(), uri, streamName, conf, \"invalid-max\".getBytes(UTF_8));\n+        updateMaxLogSegmentSequenceNo(getZooKeeperClient(namespace), uri, streamName, conf, \"invalid-max\".getBytes(UTF_8));\n         DistributedLogManager dlm2 = namespace.openLog(streamName);\n         try {\n             dlm2.startLogSegmentNonPartitioned();\n@@ -167,10 +167,10 @@ public void testCreateLogSegmentUnmatchMaxSequenceNumber() throws Exception {\n                 .setImmediateFlushEnabled(true)\n                 .setEnableLedgerAllocatorPool(true)\n                 .setLedgerAllocatorPoolName(\"test\");\n-        BKDistributedLogNamespace namespace = BKDistributedLogNamespace.newBuilder().conf(conf).uri(uri).build();\n+        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder().conf(conf).uri(uri).build();\n \n         namespace.createLog(streamName);\n-        MaxLogSegmentSequenceNo max1 = getMaxLogSegmentSequenceNo(namespace.getSharedWriterZKCForDL(), uri, streamName, conf);\n+        MaxLogSegmentSequenceNo max1 = getMaxLogSegmentSequenceNo(getZooKeeperClient(namespace), uri, streamName, conf);\n         assertEquals(DistributedLogConstants.UNASSIGNED_LOGSEGMENT_SEQNO, max1.getSequenceNumber());\n         DistributedLogManager dlm = namespace.openLog(streamName);\n         final int numSegments = 3;\n@@ -179,11 +179,11 @@ public void testCreateLogSegmentUnmatchMaxSequenceNumber() throws Exception {\n             out.write(DLMTestUtil.getLogRecordInstance(i));\n             out.closeAndComplete();\n         }\n-        MaxLogSegmentSequenceNo max2 = getMaxLogSegmentSequenceNo(namespace.getSharedWriterZKCForDL(), uri, streamName, conf);\n+        MaxLogSegmentSequenceNo max2 = getMaxLogSegmentSequenceNo(getZooKeeperClient(namespace), uri, streamName, conf);\n         assertEquals(3, max2.getSequenceNumber());\n \n         // update the max ledger sequence number\n-        updateMaxLogSegmentSequenceNo(namespace.getSharedWriterZKCForDL(), uri, streamName, conf,\n+        updateMaxLogSegmentSequenceNo(getZooKeeperClient(namespace), uri, streamName, conf,\n                 DLUtils.serializeLogSegmentSequenceNumber(99));\n \n         DistributedLogManager dlm1 = namespace.openLog(streamName);"},{"sha":"9553637a5a2265392375b8abe21d3041b59614d4","filename":"src/test/java/com/twitter/distributedlog/TestNonBlockingReads.java","status":"modified","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestNonBlockingReads.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestNonBlockingReads.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestNonBlockingReads.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -54,6 +54,7 @@ public void testNonBlockingRead() throws Exception {\n         confLocal.setReadAheadBatchSize(1);\n         confLocal.setReadAheadMaxRecords(1);\n         confLocal.setReaderIdleWarnThresholdMillis(100);\n+        confLocal.setReadLACLongPollTimeout(49);\n         final DistributedLogManager dlm = createNewDLM(confLocal, name);\n         ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1);\n         ScheduledFuture writerClosedFuture = null;\n@@ -129,6 +130,7 @@ public void testNonBlockingReadIdleError() throws Exception {\n         confLocal.loadConf(conf);\n         confLocal.setReadAheadBatchSize(1);\n         confLocal.setReadAheadMaxRecords(1);\n+        confLocal.setReadLACLongPollTimeout(24);\n         confLocal.setReaderIdleWarnThresholdMillis(50);\n         confLocal.setReaderIdleErrorThresholdMillis(100);\n         final DistributedLogManager dlm = createNewDLM(confLocal, name);\n@@ -174,6 +176,7 @@ public void testNonBlockingReadAheadStall() throws Exception {\n         confLocal.loadConf(conf);\n         confLocal.setReadAheadBatchSize(1);\n         confLocal.setReadAheadMaxRecords(3);\n+        confLocal.setReadLACLongPollTimeout(249);\n         confLocal.setReaderIdleWarnThresholdMillis(500);\n         confLocal.setReaderIdleErrorThresholdMillis(30000);\n         final DistributedLogManager dlm = createNewDLM(confLocal, name);"},{"sha":"cf4fc4fc3f59050377639ff7e890cb45ee2ae865","filename":"src/test/java/com/twitter/distributedlog/TestReadAheadEntryReader.java","status":"modified","additions":46,"deletions":6,"changes":52,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestReadAheadEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestReadAheadEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestReadAheadEntryReader.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -25,6 +25,7 @@\n import com.twitter.distributedlog.impl.logsegment.BKLogSegmentEntryStore;\n import com.twitter.distributedlog.injector.AsyncFailureInjector;\n import com.twitter.distributedlog.logsegment.LogSegmentEntryStore;\n+import com.twitter.distributedlog.util.ConfUtils;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.OrderedScheduler;\n import com.twitter.distributedlog.util.Utils;\n@@ -38,6 +39,7 @@\n import org.junit.rules.TestName;\n \n import java.util.List;\n+import java.util.concurrent.TimeUnit;\n \n import static org.junit.Assert.*;\n \n@@ -54,6 +56,7 @@ public class TestReadAheadEntryReader extends TestDistributedLogBase {\n     private DistributedLogConfiguration baseConf;\n     private OrderedScheduler scheduler;\n     private BookKeeperClient bkc;\n+    private ZooKeeperClient zkc;\n \n     @Before\n     public void setup() throws Exception {\n@@ -66,6 +69,12 @@ public void setup() throws Exception {\n         baseConf.setReadAheadMaxRecords(MAX_CACHED_ENTRIES);\n         baseConf.setNumPrefetchEntriesPerLogSegment(NUM_PREFETCH_ENTRIES);\n         baseConf.setMaxPrefetchEntriesPerLogSegment(NUM_PREFETCH_ENTRIES);\n+        zkc = ZooKeeperClientBuilder.newBuilder()\n+                .name(\"test-zk\")\n+                .zkServers(bkutil.getZkServers())\n+                .sessionTimeoutMs(conf.getZKSessionTimeoutMilliseconds())\n+                .zkAclId(conf.getZkAclId())\n+                .build();\n         bkc = BookKeeperClientBuilder.newBuilder()\n                 .name(\"test-bk\")\n                 .dlConfig(conf)\n@@ -86,6 +95,9 @@ public void teardown() throws Exception {\n         if (null != scheduler) {\n             scheduler.shutdown();\n         }\n+        if (null != zkc) {\n+            zkc.close();\n+        }\n         super.teardown();\n     }\n \n@@ -99,8 +111,11 @@ private ReadAheadEntryReader createEntryReader(String streamName,\n                 true);\n         LogSegmentEntryStore entryStore = new BKLogSegmentEntryStore(\n                 conf,\n+                ConfUtils.getConstDynConf(conf),\n+                zkc,\n                 bkc,\n                 scheduler,\n+                null,\n                 NullStatsLogger.INSTANCE,\n                 AsyncFailureInjector.NULL);\n         return new ReadAheadEntryReader(\n@@ -309,7 +324,7 @@ public void testPositioningAtInvalidLogSegment() throws Exception {\n         BKDistributedLogManager dlm = createNewDLM(baseConf, streamName);\n \n         // generate list of log segments\n-        generateCompletedLogSegments(dlm, 3, 2);\n+        generateCompletedLogSegments(dlm, 3, 3);\n         AsyncLogWriter writer = FutureUtils.result(dlm.openAsyncLogWriter());\n         FutureUtils.result(writer.truncate(new DLSN(2L, 1L, 0L)));\n \n@@ -321,23 +336,39 @@ public void testPositioningAtInvalidLogSegment() throws Exception {\n         readAheadEntryReader.start(segments);\n         // ensure initialization to complete\n         ensureOrderSchedulerEmpty(streamName);\n-        expectAlreadyTruncatedTransactionException(readAheadEntryReader,\n-                \"should fail on positioning to a truncated log segment\");\n+        expectNoException(readAheadEntryReader);\n+        Entry.Reader entryReader =\n+                readAheadEntryReader.getNextReadAheadEntry(Long.MAX_VALUE, TimeUnit.MILLISECONDS);\n+        assertEquals(2L, entryReader.getLSSN());\n+        assertEquals(1L, entryReader.getEntryId());\n+        Utils.close(readAheadEntryReader);\n \n         // positioning on a partially truncated log segment (segment 2) before min active dlsn\n         readAheadEntryReader = createEntryReader(streamName, new DLSN(2L, 0L, 0L), dlm, baseConf);\n         readAheadEntryReader.start(segments);\n         // ensure initialization to complete\n         ensureOrderSchedulerEmpty(streamName);\n-        expectAlreadyTruncatedTransactionException(readAheadEntryReader,\n-                \"should fail on positioning to a partially truncated log segment\");\n+        expectNoException(readAheadEntryReader);\n+        entryReader =\n+                readAheadEntryReader.getNextReadAheadEntry(Long.MAX_VALUE, TimeUnit.MILLISECONDS);\n+        assertEquals(2L, entryReader.getLSSN());\n+        assertEquals(1L, entryReader.getEntryId());\n+        Utils.close(readAheadEntryReader);\n \n         // positioning on a partially truncated log segment (segment 2) after min active dlsn\n-        readAheadEntryReader = createEntryReader(streamName, new DLSN(2L, 1L, 0L), dlm, baseConf);\n+        readAheadEntryReader = createEntryReader(streamName, new DLSN(2L, 2L, 0L), dlm, baseConf);\n         readAheadEntryReader.start(segments);\n         // ensure initialization to complete\n         ensureOrderSchedulerEmpty(streamName);\n         expectNoException(readAheadEntryReader);\n+        entryReader =\n+                readAheadEntryReader.getNextReadAheadEntry(Long.MAX_VALUE, TimeUnit.MILLISECONDS);\n+        assertEquals(2L, entryReader.getLSSN());\n+        assertEquals(2L, entryReader.getEntryId());\n+        Utils.close(readAheadEntryReader);\n+\n+        Utils.close(writer);\n+        dlm.close();\n     }\n \n     @Test(timeout = 60000)\n@@ -363,20 +394,26 @@ public void testPositioningIgnoreTruncationStatus() throws Exception {\n         // ensure initialization to complete\n         ensureOrderSchedulerEmpty(streamName);\n         expectNoException(readAheadEntryReader);\n+        Utils.close(readAheadEntryReader);\n \n         // positioning on a partially truncated log segment (segment 2) before min active dlsn\n         readAheadEntryReader = createEntryReader(streamName, new DLSN(2L, 0L, 0L), dlm, confLocal);\n         readAheadEntryReader.start(segments);\n         // ensure initialization to complete\n         ensureOrderSchedulerEmpty(streamName);\n         expectNoException(readAheadEntryReader);\n+        Utils.close(readAheadEntryReader);\n \n         // positioning on a partially truncated log segment (segment 2) after min active dlsn\n         readAheadEntryReader = createEntryReader(streamName, new DLSN(2L, 1L, 0L), dlm, confLocal);\n         readAheadEntryReader.start(segments);\n         // ensure initialization to complete\n         ensureOrderSchedulerEmpty(streamName);\n         expectNoException(readAheadEntryReader);\n+        Utils.close(readAheadEntryReader);\n+\n+        Utils.close(writer);\n+        dlm.close();\n     }\n \n     //\n@@ -418,6 +455,9 @@ public void testLogSegmentSequenceNumberGap() throws Exception {\n         ensureOrderSchedulerEmpty(streamName);\n         expectIllegalStateException(readAheadEntryReader,\n                 \"inconsistent log segment found\");\n+\n+        Utils.close(readAheadEntryReader);\n+        dlm.close();\n     }\n \n }"},{"sha":"b183b84ddea297212d8d826d1714e28970d7a03f","filename":"src/test/java/com/twitter/distributedlog/TestRollLogSegments.java","status":"modified","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestRollLogSegments.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestRollLogSegments.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2FTestRollLogSegments.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -331,6 +331,7 @@ private void checkAndWaitWriterReaderPosition(BKLogSegmentWriter writer, long ex\n \n     @FlakyTest\n     @Test(timeout = 60000)\n+    @SuppressWarnings(\"deprecation\")\n     public void testCaughtUpReaderOnLogSegmentRolling() throws Exception {\n         String name = \"distrlog-caughtup-reader-on-logsegment-rolling\";\n \n@@ -344,6 +345,8 @@ public void testCaughtUpReaderOnLogSegmentRolling() throws Exception {\n         confLocal.setWriteQuorumSize(1);\n         confLocal.setAckQuorumSize(1);\n         confLocal.setReadLACLongPollTimeout(99999999);\n+        confLocal.setReaderIdleWarnThresholdMillis(2 * 99999999 + 1);\n+        confLocal.setBKClientReadTimeout(99999999 + 1);\n \n         DistributedLogManager dlm = createNewDLM(confLocal, name);\n         BKSyncLogWriter writer = (BKSyncLogWriter) dlm.startLogSegmentNonPartitioned();\n@@ -368,7 +371,7 @@ public void testCaughtUpReaderOnLogSegmentRolling() throws Exception {\n         }\n \n         BKLogSegmentWriter perStreamWriter = writer.segmentWriter;\n-        BookKeeperClient bkc = readDLM.getReaderBKC();\n+        BookKeeperClient bkc = DLMTestUtil.getBookKeeperClient(readDLM);\n         LedgerHandle readLh = bkc.get().openLedgerNoRecovery(getLedgerHandle(perStreamWriter).getId(),\n                 BookKeeper.DigestType.CRC32, conf.getBKDigestPW().getBytes(UTF_8));\n "},{"sha":"ff924f88e5c4ac21da6ac075db4527f183ab3d3f","filename":"src/test/java/com/twitter/distributedlog/acl/TestZKAccessControl.java","status":"modified","additions":3,"deletions":2,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Facl%2FTestZKAccessControl.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Facl%2FTestZKAccessControl.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Facl%2FTestZKAccessControl.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -20,6 +20,7 @@\n import com.twitter.distributedlog.TestZooKeeperClientBuilder;\n import com.twitter.distributedlog.ZooKeeperClient;\n import com.twitter.distributedlog.ZooKeeperClusterTestCase;\n+import com.twitter.distributedlog.impl.acl.ZKAccessControl;\n import com.twitter.distributedlog.thrift.AccessControlEntry;\n import com.twitter.util.Await;\n import org.apache.zookeeper.CreateMode;\n@@ -103,7 +104,7 @@ public void testEmptyZKAccessControl() throws Exception {\n \n         ZKAccessControl readZKAC = Await.result(ZKAccessControl.read(zkc, zkPath, null));\n \n-        assertEquals(zkPath, readZKAC.zkPath);\n+        assertEquals(zkPath, readZKAC.getZKPath());\n         assertEquals(ZKAccessControl.DEFAULT_ACCESS_CONTROL_ENTRY, readZKAC.getAccessControlEntry());\n         assertTrue(ZKAccessControl.DEFAULT_ACCESS_CONTROL_ENTRY == readZKAC.getAccessControlEntry());\n     }\n@@ -145,7 +146,7 @@ public void testUpdateZKAccessControl() throws Exception {\n         } catch (KeeperException.BadVersionException bve) {\n             // expected\n         }\n-        readZKAC2.accessControlEntry.setDenyTruncate(true);\n+        readZKAC2.getAccessControlEntry().setDenyTruncate(true);\n         Await.result(readZKAC2.update(zkc));\n         ZKAccessControl readZKAC3 = Await.result(ZKAccessControl.read(zkc, zkPath, null));\n         assertEquals(readZKAC2, readZKAC3);"},{"sha":"562530625611c684872e09ac24824220e87650be","filename":"src/test/java/com/twitter/distributedlog/acl/TestZKAccessControlManager.java","status":"modified","additions":2,"deletions":0,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Facl%2FTestZKAccessControlManager.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Facl%2FTestZKAccessControlManager.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Facl%2FTestZKAccessControlManager.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -22,6 +22,8 @@\n import com.twitter.distributedlog.ZooKeeperClient;\n import com.twitter.distributedlog.ZooKeeperClientUtils;\n import com.twitter.distributedlog.ZooKeeperClusterTestCase;\n+import com.twitter.distributedlog.impl.acl.ZKAccessControl;\n+import com.twitter.distributedlog.impl.acl.ZKAccessControlManager;\n import com.twitter.distributedlog.thrift.AccessControlEntry;\n import com.twitter.util.Await;\n import org.junit.After;"},{"sha":"60bc4205fb0ad2e6cc1aa3ab869f0eacaf5b17a1","filename":"src/test/java/com/twitter/distributedlog/admin/TestDLCK.java","status":"modified","additions":22,"deletions":12,"changes":34,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fadmin%2FTestDLCK.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fadmin%2FTestDLCK.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fadmin%2FTestDLCK.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -28,6 +28,8 @@\n import com.twitter.distributedlog.ZooKeeperClient;\n import com.twitter.distributedlog.metadata.DryrunLogSegmentMetadataStoreUpdater;\n import com.twitter.distributedlog.metadata.LogSegmentMetadataStoreUpdater;\n+import com.twitter.distributedlog.namespace.DistributedLogNamespace;\n+import com.twitter.distributedlog.namespace.DistributedLogNamespaceBuilder;\n import com.twitter.distributedlog.util.OrderedScheduler;\n import com.twitter.distributedlog.util.SchedulerUtils;\n import org.apache.zookeeper.CreateMode;\n@@ -103,8 +105,10 @@ public void testCheckAndRepairDLNamespace() throws Exception {\n         confLocal.setLogSegmentCacheEnabled(false);\n         URI uri = createDLMURI(\"/check-and-repair-dl-namespace\");\n         zkc.get().create(uri.getPath(), new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-        com.twitter.distributedlog.DistributedLogManagerFactory factory =\n-                new com.twitter.distributedlog.DistributedLogManagerFactory(confLocal, uri);\n+        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+                .conf(confLocal)\n+                .uri(uri)\n+                .build();\n         OrderedScheduler scheduler = OrderedScheduler.newBuilder()\n                 .name(\"dlck-tool\")\n                 .corePoolSize(1)\n@@ -114,17 +118,20 @@ public void testCheckAndRepairDLNamespace() throws Exception {\n         String streamName = \"check-and-repair-dl-namespace\";\n \n         // Create completed log segments\n-        DistributedLogManager dlm = factory.createDistributedLogManagerWithSharedClients(streamName);\n+        DistributedLogManager dlm = namespace.openLog(streamName);\n         DLMTestUtil.injectLogSegmentWithLastDLSN(dlm, confLocal, 1L, 1L, 10, false);\n         DLMTestUtil.injectLogSegmentWithLastDLSN(dlm, confLocal, 2L, 11L, 10, true);\n         DLMTestUtil.injectLogSegmentWithLastDLSN(dlm, confLocal, 3L, 21L, 10, false);\n         DLMTestUtil.injectLogSegmentWithLastDLSN(dlm, confLocal, 4L, 31L, 10, true);\n \n         // dryrun\n-        BookKeeperClient bkc = getBookKeeperClient(factory);\n-        DistributedLogAdmin.checkAndRepairDLNamespace(uri, factory,\n-                new DryrunLogSegmentMetadataStoreUpdater(confLocal, getLogSegmentMetadataStore(factory)),\n-                scheduler, bkc, confLocal.getBKDigestPW(), false, false);\n+        DistributedLogAdmin.checkAndRepairDLNamespace(\n+                uri,\n+                namespace,\n+                new DryrunLogSegmentMetadataStoreUpdater(confLocal, getLogSegmentMetadataStore(namespace)),\n+                scheduler,\n+                false,\n+                false);\n \n         Map<Long, LogSegmentMetadata> segments = getLogSegments(dlm);\n         LOG.info(\"segments after drynrun {}\", segments);\n@@ -134,10 +141,13 @@ public void testCheckAndRepairDLNamespace() throws Exception {\n         verifyLogSegment(segments, new DLSN(4L, 16L, 0L), 4L, 9, 39L);\n \n         // check and repair\n-        bkc = getBookKeeperClient(factory);\n-        DistributedLogAdmin.checkAndRepairDLNamespace(uri, factory,\n-                LogSegmentMetadataStoreUpdater.createMetadataUpdater(confLocal, getLogSegmentMetadataStore(factory)),\n-                scheduler, bkc, confLocal.getBKDigestPW(), false, false);\n+        DistributedLogAdmin.checkAndRepairDLNamespace(\n+                uri,\n+                namespace,\n+                LogSegmentMetadataStoreUpdater.createMetadataUpdater(confLocal, getLogSegmentMetadataStore(namespace)),\n+                scheduler,\n+                false,\n+                false);\n \n         segments = getLogSegments(dlm);\n         LOG.info(\"segments after repair {}\", segments);\n@@ -148,7 +158,7 @@ public void testCheckAndRepairDLNamespace() throws Exception {\n \n         dlm.close();\n         SchedulerUtils.shutdownScheduler(executorService, 5, TimeUnit.MINUTES);\n-        factory.close();\n+        namespace.close();\n     }\n \n }"},{"sha":"1e39e4952464496bf8e49a34a395c082b31762b0","filename":"src/test/java/com/twitter/distributedlog/admin/TestDistributedLogAdmin.java","status":"modified","additions":19,"deletions":13,"changes":32,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fadmin%2FTestDistributedLogAdmin.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fadmin%2FTestDistributedLogAdmin.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fadmin%2FTestDistributedLogAdmin.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -24,6 +24,8 @@\n import com.twitter.distributedlog.TestZooKeeperClientBuilder;\n import com.twitter.distributedlog.annotations.DistributedLogAnnotations;\n import com.twitter.distributedlog.exceptions.UnexpectedException;\n+import com.twitter.distributedlog.namespace.DistributedLogNamespace;\n+import com.twitter.distributedlog.namespace.DistributedLogNamespaceBuilder;\n import com.twitter.distributedlog.util.Utils;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.ZooDefs;\n@@ -90,21 +92,25 @@ public void testChangeSequenceNumber() throws Exception {\n \n         URI uri = createDLMURI(\"/change-sequence-number\");\n         zooKeeperClient.get().create(uri.getPath(), new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n-        com.twitter.distributedlog.DistributedLogManagerFactory factory =\n-                new com.twitter.distributedlog.DistributedLogManagerFactory(confLocal, uri);\n-        com.twitter.distributedlog.DistributedLogManagerFactory readFactory =\n-                new com.twitter.distributedlog.DistributedLogManagerFactory(readConf, uri);\n+        DistributedLogNamespace namespace = DistributedLogNamespaceBuilder.newBuilder()\n+                .conf(confLocal)\n+                .uri(uri)\n+                .build();\n+        DistributedLogNamespace readNamespace = DistributedLogNamespaceBuilder.newBuilder()\n+                .conf(readConf)\n+                .uri(uri)\n+                .build();\n \n         String streamName = \"change-sequence-number\";\n \n         // create completed log segments\n-        DistributedLogManager dlm = factory.createDistributedLogManagerWithSharedClients(streamName);\n+        DistributedLogManager dlm = namespace.openLog(streamName);\n         DLMTestUtil.generateCompletedLogSegments(dlm, confLocal, 4, 10);\n         DLMTestUtil.injectLogSegmentWithGivenLogSegmentSeqNo(dlm, confLocal, 5, 41, false, 10, true);\n         dlm.close();\n \n         // create a reader\n-        DistributedLogManager readDLM = readFactory.createDistributedLogManagerWithSharedClients(streamName);\n+        DistributedLogManager readDLM = readNamespace.openLog(streamName);\n         AsyncLogReader reader = readDLM.getAsyncLogReader(DLSN.InitialDLSN);\n \n         // read the records\n@@ -121,7 +127,7 @@ public void testChangeSequenceNumber() throws Exception {\n \n         LOG.info(\"Injecting bad log segment '3'\");\n \n-        dlm = factory.createDistributedLogManagerWithSharedClients(streamName);\n+        dlm = namespace.openLog(streamName);\n         DLMTestUtil.injectLogSegmentWithGivenLogSegmentSeqNo(dlm, confLocal, 3L, 5 * 10 + 1, true, 10, false);\n \n         LOG.info(\"Injected bad log segment '3'\");\n@@ -140,8 +146,8 @@ public void testChangeSequenceNumber() throws Exception {\n         LOG.info(\"Dryrun fix inprogress segment that has lower sequence number\");\n \n         // Dryrun\n-        DistributedLogAdmin.fixInprogressSegmentWithLowerSequenceNumber(factory,\n-                new DryrunLogSegmentMetadataStoreUpdater(confLocal, getLogSegmentMetadataStore(factory)), streamName, false, false);\n+        DistributedLogAdmin.fixInprogressSegmentWithLowerSequenceNumber(namespace,\n+                new DryrunLogSegmentMetadataStoreUpdater(confLocal, getLogSegmentMetadataStore(namespace)), streamName, false, false);\n \n         try {\n             reader = readDLM.getAsyncLogReader(lastDLSN);\n@@ -154,8 +160,8 @@ public void testChangeSequenceNumber() throws Exception {\n         LOG.info(\"Actual run fix inprogress segment that has lower sequence number\");\n \n         // Actual run\n-        DistributedLogAdmin.fixInprogressSegmentWithLowerSequenceNumber(factory,\n-                LogSegmentMetadataStoreUpdater.createMetadataUpdater(confLocal, getLogSegmentMetadataStore(factory)), streamName, false, false);\n+        DistributedLogAdmin.fixInprogressSegmentWithLowerSequenceNumber(namespace,\n+                LogSegmentMetadataStoreUpdater.createMetadataUpdater(confLocal, getLogSegmentMetadataStore(namespace)), streamName, false, false);\n \n         // be able to read more after fix\n         reader = readDLM.getAsyncLogReader(lastDLSN);\n@@ -182,7 +188,7 @@ public void testChangeSequenceNumber() throws Exception {\n         readDLM.close();\n \n         dlm.close();\n-        factory.close();\n-        readFactory.close();\n+        namespace.close();\n+        readNamespace.close();\n     }\n }"},{"sha":"de7016a1a37e415236806700dbafc30e58bcef59","filename":"src/test/java/com/twitter/distributedlog/impl/TestZKLogSegmentMetadataStore.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FTestZKLogSegmentMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FTestZKLogSegmentMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FTestZKLogSegmentMetadataStore.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -531,7 +531,7 @@ public void onLogStreamDeleted() {\n                 children, firstSegmentList);\n \n         ZooKeeperClientUtils.expireSession(zkc,\n-                DLUtils.getZKServersFromDLUri(uri), conf.getZKSessionTimeoutMilliseconds());\n+                BKNamespaceDriver.getZKServersFromDLUri(uri), conf.getZKSessionTimeoutMilliseconds());\n \n         logger.info(\"Create another {} segments.\", numSegments);\n "},{"sha":"c9a2e5babdeb2970befd3bbb5c21c32bb0a91b98","filename":"src/test/java/com/twitter/distributedlog/impl/TestZKNamespaceWatcher.java","status":"modified","additions":1,"deletions":1,"changes":2,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FTestZKNamespaceWatcher.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FTestZKNamespaceWatcher.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2FTestZKNamespaceWatcher.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -174,7 +174,7 @@ public void onStreamsChanged(Iterator<String> streams) {\n         createLogInNamespace(uri, \"test2\");\n         latches[2].await();\n         assertEquals(2, receivedLogs.get().size());\n-        ZooKeeperClientUtils.expireSession(zkc, DLUtils.getZKServersFromDLUri(uri), zkSessionTimeoutMs);\n+        ZooKeeperClientUtils.expireSession(zkc, BKNamespaceDriver.getZKServersFromDLUri(uri), zkSessionTimeoutMs);\n         latches[3].await();\n         assertEquals(2, receivedLogs.get().size());\n         createLogInNamespace(uri, \"test3\");"},{"sha":"0ce9f46be2329f188a5f99a39401437f53125595","filename":"src/test/java/com/twitter/distributedlog/impl/federated/TestFederatedZKLogMetadataStore.java","status":"modified","additions":2,"deletions":1,"changes":3,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Ffederated%2FTestFederatedZKLogMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Ffederated%2FTestFederatedZKLogMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Ffederated%2FTestFederatedZKLogMetadataStore.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -30,6 +30,7 @@\n import com.twitter.distributedlog.callback.NamespaceListener;\n import com.twitter.distributedlog.exceptions.LogExistsException;\n import com.twitter.distributedlog.exceptions.UnexpectedException;\n+import com.twitter.distributedlog.impl.BKNamespaceDriver;\n import com.twitter.distributedlog.metadata.LogMetadataStore;\n import com.twitter.distributedlog.util.DLUtils;\n import com.twitter.distributedlog.util.FutureUtils;\n@@ -422,7 +423,7 @@ public void testZooKeeperSessionExpired() throws Exception {\n         TestNamespaceListenerWithExpectedSize listener =\n                 new TestNamespaceListenerWithExpectedSize(2 * maxLogsPerSubnamespace + 1);\n         metadataStore.registerNamespaceListener(listener);\n-        ZooKeeperClientUtils.expireSession(zkc, DLUtils.getZKServersFromDLUri(uri), zkSessionTimeoutMs);\n+        ZooKeeperClientUtils.expireSession(zkc, BKNamespaceDriver.getZKServersFromDLUri(uri), zkSessionTimeoutMs);\n         String testLogName = \"test-log-name\";\n         allLogs.add(testLogName);\n "},{"sha":"183a40551e702f8e5d6b7b83749fab2611844e65","filename":"src/test/java/com/twitter/distributedlog/impl/logsegment/TestBKLogSegmentEntryReader.java","status":"modified","additions":21,"deletions":1,"changes":22,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FTestBKLogSegmentEntryReader.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FTestBKLogSegmentEntryReader.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Flogsegment%2FTestBKLogSegmentEntryReader.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -30,10 +30,13 @@\n import com.twitter.distributedlog.LogRecordWithDLSN;\n import com.twitter.distributedlog.LogSegmentMetadata;\n import com.twitter.distributedlog.TestDistributedLogBase;\n+import com.twitter.distributedlog.ZooKeeperClient;\n+import com.twitter.distributedlog.ZooKeeperClientBuilder;\n import com.twitter.distributedlog.exceptions.EndOfLogSegmentException;\n import com.twitter.distributedlog.exceptions.ReadCancelledException;\n import com.twitter.distributedlog.injector.AsyncFailureInjector;\n import com.twitter.distributedlog.logsegment.LogSegmentEntryStore;\n+import com.twitter.distributedlog.util.ConfUtils;\n import com.twitter.distributedlog.util.FutureUtils;\n import com.twitter.distributedlog.util.OrderedScheduler;\n import com.twitter.distributedlog.util.Utils;\n@@ -59,10 +62,17 @@ public class TestBKLogSegmentEntryReader extends TestDistributedLogBase {\n     public TestName runtime = new TestName();\n     private OrderedScheduler scheduler;\n     private BookKeeperClient bkc;\n+    private ZooKeeperClient zkc;\n \n     @Before\n     public void setup() throws Exception {\n         super.setup();\n+        zkc = ZooKeeperClientBuilder.newBuilder()\n+                .name(\"test-zk\")\n+                .zkServers(bkutil.getZkServers())\n+                .sessionTimeoutMs(conf.getZKSessionTimeoutMilliseconds())\n+                .zkAclId(conf.getZkAclId())\n+                .build();\n         bkc = BookKeeperClientBuilder.newBuilder()\n                 .name(\"test-bk\")\n                 .dlConfig(conf)\n@@ -83,6 +93,9 @@ public void teardown() throws Exception {\n         if (null != scheduler) {\n             scheduler.shutdown();\n         }\n+        if (null != zkc) {\n+            zkc.close();\n+        }\n         super.teardown();\n     }\n \n@@ -91,7 +104,14 @@ BKLogSegmentEntryReader createEntryReader(LogSegmentMetadata segment,\n                                               DistributedLogConfiguration conf)\n             throws Exception {\n         LogSegmentEntryStore store = new BKLogSegmentEntryStore(\n-                conf, bkc, scheduler, NullStatsLogger.INSTANCE, AsyncFailureInjector.NULL);\n+                conf,\n+                ConfUtils.getConstDynConf(conf),\n+                zkc,\n+                bkc,\n+                scheduler,\n+                null,\n+                NullStatsLogger.INSTANCE,\n+                AsyncFailureInjector.NULL);\n         return (BKLogSegmentEntryReader) FutureUtils.result(store.openReader(segment, startEntryId));\n     }\n "},{"sha":"1b19b2e7cce5c0fd2d8f29b91043f25226907cdf","filename":"src/test/java/com/twitter/distributedlog/impl/metadata/TestZKLogStreamMetadataStore.java","status":"modified","additions":7,"deletions":7,"changes":14,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fmetadata%2FTestZKLogStreamMetadataStore.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fmetadata%2FTestZKLogStreamMetadataStore.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fmetadata%2FTestZKLogStreamMetadataStore.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -17,16 +17,16 @@\n  */\n package com.twitter.distributedlog.impl.metadata;\n \n-import com.twitter.distributedlog.TestZooKeeperClientBuilder;\n-import com.twitter.distributedlog.metadata.BKDLConfig;\n-import com.twitter.distributedlog.metadata.DLMetadata;\n import com.google.common.collect.Lists;\n import com.twitter.distributedlog.DLMTestUtil;\n import com.twitter.distributedlog.DistributedLogConfiguration;\n+import com.twitter.distributedlog.MetadataAccessor;\n+import com.twitter.distributedlog.TestZooKeeperClientBuilder;\n+import com.twitter.distributedlog.impl.metadata.BKDLConfig;\n+import com.twitter.distributedlog.metadata.DLMetadata;\n import com.twitter.distributedlog.metadata.LogMetadataForWriter;\n import com.twitter.distributedlog.namespace.DistributedLogNamespace;\n import com.twitter.distributedlog.namespace.DistributedLogNamespaceBuilder;\n-import com.twitter.distributedlog.DistributedLogManager;\n import com.twitter.distributedlog.DistributedLogConstants;\n import com.twitter.distributedlog.exceptions.LogNotFoundException;\n import com.twitter.distributedlog.ZooKeeperClient;\n@@ -317,9 +317,9 @@ public void testCreateLogMetadataWithCustomMetadata() throws Exception {\n             .uri(uri)\n             .build();\n \n-        DistributedLogManager dlm = namespace.openLog(logName);\n-        dlm.createOrUpdateMetadata(logName.getBytes(\"UTF-8\"));\n-        dlm.close();\n+        MetadataAccessor accessor = namespace.getNamespaceDriver().getMetadataAccessor(logName);\n+        accessor.createOrUpdateMetadata(logName.getBytes(\"UTF-8\"));\n+        accessor.close();\n \n         testCreateLogMetadataWithMissingPaths(uri, logName, logIdentifier, pathsToDelete, true, false);\n     }"},{"sha":"bbabbb24968748ca3c2e8ce7ce0379561fa7a414","filename":"src/test/java/com/twitter/distributedlog/impl/metadata/TestZkMetadataResolver.java","status":"renamed","additions":4,"deletions":1,"changes":5,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fmetadata%2FTestZkMetadataResolver.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fmetadata%2FTestZkMetadataResolver.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fimpl%2Fmetadata%2FTestZkMetadataResolver.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -15,11 +15,14 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package com.twitter.distributedlog.metadata;\n+package com.twitter.distributedlog.impl.metadata;\n \n import com.twitter.distributedlog.DistributedLogConfiguration;\n import com.twitter.distributedlog.DistributedLogConstants;\n import com.twitter.distributedlog.TestZooKeeperClientBuilder;\n+import com.twitter.distributedlog.impl.metadata.BKDLConfig;\n+import com.twitter.distributedlog.impl.metadata.ZkMetadataResolver;\n+import com.twitter.distributedlog.metadata.DLMetadata;\n import com.twitter.distributedlog.util.Utils;\n import com.twitter.distributedlog.ZooKeeperClient;\n import com.twitter.distributedlog.ZooKeeperClientBuilder;","previous_filename":"src/test/java/com/twitter/distributedlog/metadata/TestZkMetadataResolver.java"},{"sha":"e3cc239e893c4b93b02957e31bb6bb9a39e01918","filename":"src/test/java/com/twitter/distributedlog/metadata/TestDLMetadata.java","status":"modified","additions":1,"deletions":0,"changes":1,"blob_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/blob/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fmetadata%2FTestDLMetadata.java","raw_url":"https://github.com/EnricoDAlessandro97UNI/bookkeeper/raw/d15bc06466e345651f53ef7a7f5a771ac4880446/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fmetadata%2FTestDLMetadata.java","contents_url":"https://api.github.com/repos/EnricoDAlessandro97UNI/bookkeeper/contents/src%2Ftest%2Fjava%2Fcom%2Ftwitter%2Fdistributedlog%2Fmetadata%2FTestDLMetadata.java?ref=d15bc06466e345651f53ef7a7f5a771ac4880446","patch":"@@ -19,6 +19,7 @@\n \n import com.twitter.distributedlog.LocalDLMEmulator;\n import com.twitter.distributedlog.ZooKeeperClusterTestCase;\n+import com.twitter.distributedlog.impl.metadata.BKDLConfig;\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.data.Stat;\n import org.junit.After;"}]}